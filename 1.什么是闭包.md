### 1.什么是闭包

《JavaScript高级程序设计》这样描述：

> [闭包](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fcn%2Fdocs%2FWeb%2FJavaScript%2FClosures)是指有权访问另一个函数[作用域](https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5afb0ae56fb9a07aa2138425)中的变量的函数；

最常见的闭包结构如下

```jsx
function aaa(){
  var name = "xxx"
  return function bbb(){
    alert(name);
  }
}
```

如上代码，`bbb函数`内可以访问`aaa函数`作用域内的变量

### 2.闭包的作用

正常函数执行完毕后,里面声明的变量被垃圾回收处理掉,但是闭包可以让作用域里的 变量,在函数执行完之后依旧保持没有被垃圾回收处理掉

### 3.闭包的特性

外部的方法和变量就不会污染闭包内部的东西，同时，闭包内的变量也会有效的保存下来

```js
function person(name) {
    // 变量作用域为函数内部，外部无法访问，防止了变量名冲突和污染
    var name = '小明';
    this.sayName= function() {
        alert(name)
    }
    this.changeName= function(newName) {
        name = newName
    }
}
// 外部无法访问内部变量
let a = new person()
console.log(a.name) // undefiend
a.changeName('小白')
// 这里修改的name会保存下来
a.sayName() // 小白
```

### 4.闭包的实例

#### 返回函数

```js
// 创建闭包最常见的方式函数作为返回值
function foo() {
  var name = "kebi";
  return function() {
    console.log(name);
  };
}
var bar = foo();
bar(); //打印kebi    --外部函数访问内部变量
```

#### 常见的定时器问题

```jsx
for( var i = 0; i < 5; i++ ) {
    setTimeout(() => {
        console.log( i );
    }, 1000)
}
```

得到结果 5个5
setTimeout函数在当前执行队列的最后执行，获取到的`i`是最外部作用域的`i=5`,所以得到5个5

那么如果想1s后得到0-4怎么做？在for循环内创建闭包

```jsx
//方法一:
for (var i = 0; i < 5; i++) {
  setTimeout(
    (function(i) {
      return function() {
        console.log(i);
      };
    })(i),
    1000
  );
}
// 或者
for (var i = 0; i < 5; i++) {
  setTimeout(
    (function() {
      var temp = i;
      return function() {
        console.log(temp);
      };
    })(),
    1000
  );
}
//这个是通过自执行函数返回一个函数,然后在调用返回的函数去获取自执行函数内部的变量,此为闭包

//方法二:
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, 1000);
  })(i);
}
```

大部分都认为方法一和方法二都是闭包,我认为方法一是闭包,而方法二是通过创建一个自执行函数,使变量存在这个自执行函数的作用域里；

> 此外，还可以通过将`var`改为`let`，这样`for`循环就拥有了块级作用域，也能解决这个问题；

#### 计数器

接下来实现一个计数器大家肯定会觉得这不是很简单吗

```javascript
var count = 0;

function add() {
  count = count + 1;
  console.log(count);
}
add(); //确实实现了需求
//但是如果需要第二个计数器呢?
//难道要如下这样写吗?
var count1 = 0;

function add1() {
  count1 = count1 + 1;
  console.log(count1);
}
add1(); //确实实现了需求
```

**当我们需要更多的时候,这样明显是不现实的,这里我们就需要用到闭包.**

```javascript
function addCount() {
  var conut = 0;
  return function() {
    count = count + 1;
    console.log(count);
  };
}
```

这里解释一下上边的过程:

- addCount() 执行的时候, **返回一个函数**；
- 函数是可以**创建自己的作用域的**, 但是此时返回的这个函数内部需要引用 addCount() **作用域下的变量 count**, **因此这个 count 是不能被销毁的**；
- 接下来需要几个计数器我们就定义几个变量就可以，**并且他们都不会互相影响，每个函数作用域中还会保存 count 变量不被销毁，进行不断的累加**

```javascript
var fun1 = addCount();
fun1(); //1
fun1(); //2
var fun2 = addCount();
fun2(); //1
fun2(); //2
```

### 5.注意事项

由于闭包会常驻内存，使用不当会导致内存溢出。

### async

1. async其实就是对Generator的封装，只不过async可以自动执行next()。
2. async必须等到里面所有的await执行完，async才开始return，返回的Promise状态才改变。除非遇到return和错误。
3. async默认返回一个Promise，如果return不是一个Promise对象，就会被转为立即resolve的Promise，可以在then函数中获取返回值。

### 例一

```js
async function async1() {
    console.log("async1_start_2");
    await async2();
    console.log("async1_end_6");
    return 'async_return_8';
}
 
async function async2() {
    console.log("async2_3");
}
 
console.log("script_start_1");
 
setTimeout(function() {
    console.log("setTimeout_9");
}, 0);
 
async1().then(function (message) { console.log(message) });
 
new Promise(function(resolve) {
    console.log("promise_4");
    resolve();
}).then(function() {
    console.log("promise_7");
});
 
console.log("script_end_5");
```

输出为：

![image-20200830003450311](http://ahuntsun.gitee.io/blogimagebed/img/others/3/1.png)

这道题目考查的是我们对 **事件循环 任务队列** 的理解：

事件循环(Event Loop):

1. JS会首先判断代码是同步还是异步，同步进入主线程，异步进入任务队列；
2. 同步任务进入主线程后一直执行，直到主线程空闲后，才会去任务队列中查看是否有可执行的异步任务，如果有就推入主线程中执行；
3. 事件循环是一个先进先出（FIFO）队列，这说明回调是按照它们被加入队列的顺序执行的。

[ 分析 ]：

1. **在单线程的js中，异步代码会被放入一个事件队列，等到所有其他代码执行后再执行，而不会阻塞线程。**我们从上到下看，首先打印：`1`；

2. **setTimeout / setInterval 要放到任务队列的末尾**，等待后续执行。继续往下走；

   **此时的任务队列：**

- **宏任务队列： setTimeout**
- **微任务队列：none**

1. async1 开始执行，当函数里遇到await时，暂停执行（await所在行放在本次执行完），而 **async1 函数** 未完成部分被添加到宏任务队列；

   **此时的任务队列：**

- **宏任务队列：async1， setTimeout**
- **微任务队列：none**

1. new Promise() 实例对象被new出来后，它里面的promise1会立刻打印，然后又遇到 then, 此时 **promise 实例** 被添加到微任务队列；

   **此时的任务队列：**

- **宏任务队列：async1 ，setTimeout**
- **微任务队列： promise实例**

1. 接着打印：script end。至此，同步代码（第一个宏任务）已执行完毕。而我们的任务队列中还存在着 async1, promise对象, setTimeout异步回调；
2. 由于异步代码第一次执行时，**async1 函数** 要早于 promise对象，所以紧接着 async1 函数继续执行没有执行完成的部分（例三中promise.then先于await，所以then先执行），执行完毕后，退出任务队列，打印：async1 end。然后把它的 then 逻辑添加到任务微任务队列中;

 **此时的任务队列：**

- **宏任务队列：setTimeout**
- **微任务队列：promise实例 ，async1的then逻辑部分**

1. 先清空微任务队列，**promise 实例** 继续执行它的 then 的逻辑，打印：promise2。执行完毕后，退出微任务队列；

 **此时的任务队列：**

- **宏任务队列：setTimeout**
- **微任务队列：async1的then逻辑部分**

1. async 函数执行 then 逻辑；

 **此时的任务队列：**

- **宏任务队列：setTimeout**
- **微任务队列：none**

1. setTimeout是宏任务会在最后执行。

### 例二

```js
console.log(1);
async function asyncfn1(){
    console.log(2);
    await asyncfn2();
    console.log(5);
};
setTimeout(() => {
    console.log('setTimeout')
}, 0)
 
async function asyncfn2(){
    console.log(3)
};
 
asyncfn1();
console.log(4);
```

输出：

```javascript
1
2
3
4
5
setTimeout
```

细品：

1. 首先执行全局同步代码，先输出 `1`；
2. 随后执行`asyncfn1`，输出 `2` 遇到`awati`后，先执行`asyncfn2`，将后面的代码放入宏任务队列，

**此时的任务队列：**

- 宏任务队列：`asyncfn1`剩余代码；
- 微任务队列：none；

1. 执行`asyncfn2`输出 `3`；
2. 继续执行全局同步代码，输出 `4`；
3. 执行宏任务输出 `5`；

### 例三

```javascript
var p = new Promise((res,rej) => {
  res('hello_6')
  console.log('1')
})

function hello() {
  console.log('hello_begins_2')
  return p
}

hello().then(res => {
  console.log(res)
  console.log('hello_7')
  return 'hello_10'
}).then(res => {
  console.log(res)
  console.log('hello_11')
  return 'hello_13'
}).then(res => {
  console.log(res)
  console.log('hello_14')
})

function test1 () {
  console.log('test1_5')
}

async function asy () {
  console.log('asy_begins_3')
  await console.log('asy_4')

  console.log('async_8')
  await console.log('asy_9')

  console.log('asy_ends_12')
}

asy()

test1()
```

结果：
![image-20200829235047575](http://ahuntsun.gitee.io/blogimagebed/img/others/3/3.png)

看官们可以根据输出结果细品；

**注意：**`await`后面的代码虽然算作宏任务，但是和普通的微任务不在一个维度，位于更上一层的任务队列，所以优先度要比其他（下层）微任务要高；

> 参考思路：

1. 执行同步的全局代码输出 `1`（遇到new Promise()的需要立即执行）
2. 第 `11` 行执行 `hello`函数，输出`2`，并返回一个`Promise`对象`p`，将hello函数的第一层then函数放入微任务队列；

**此时的任务队列：**

- **宏任务队列：none**
- **微任务队列：hello.then（0）**

1. 继续执行同步代码，到第`38`行，执行`asy`函数；
2. 在第`29`行输出`3`，随后遇到`await`，执行该行，输出`4`，剩下的代码被放入了宏任务队列（为了区分任务的层次，标明了序号，先执行完同层的任务，再到其他层）

**此时的任务队列：**

- **宏任务队列：asy await后代码（0）**
- **微任务队列：hello.then（0），hello.then.then（1），hello.then.then.then（2）**

1. 继续执行同步全局代码，第40行，执行test函数，输出`5`；
2. 执行微任务队列中的hello.then，输出返回的promise对象p中的处理结果`6`（第12->8->2行），随后第13行输出`7`；

**此时的任务队列：**

- **宏任务队列：asy await后代码（0）**
- **微任务队列：hello.then.then（1），hello.then.then.then（2）**

1. 执行第0层的宏任务，也就是asy await后的代码，第`32`行输出`8`，第`39`行遇到await，执行完该行输出`9`后，将后面的代码推进宏任务队列；

**此时的任务队列：**

- **宏任务队列：asy await后代码（1）**
- **微任务队列：hello.then.then（1），hello.then.then.then（2）**

1. 第`15`行，执行hello函数的第二个then函数，返回处理结果res，输出`10`和`11`；

**此时的任务队列：**

- **宏任务队列：asy await后代码（1）**
- **微任务队列：hello.then.then.then（2）**

1. 同层的还有一个宏任务，执行asy await后的代码，第`35`行，输出`12`；

**此时的任务队列：**

- **宏任务队列：none**
- **微任务队列：hello.then.then.then（2）**

1. 取出微任务队列中的最后一个任务，回到第`19`行输出hello的第二个then函数的处理结果，分别是`13`和`14`；

至此程序执行完成；

多抽出1分钟来学习，让你的生命更加精彩！

## 一.同源策略如下：

| URL                                                        |              说明              |              是否允许通信              |
| :--------------------------------------------------------- | :----------------------------: | :------------------------------------: |
| `http://www.a.com/a.js`  `http://www.a.com/b.js`           |           同一域名下           |                  允许                  |
| `http://www.a.com/lab/a.js` `http://www.a.com/script/b.js` |      同一域名下不同文件夹      |                  允许                  |
| `http://www.a.com:8000/a.js ` `http://www.a.com/b.js`      |       同一域名，不同端口       |                 不允许                 |
| `http://www.a.com/a.js ` `https://www.a.com/b.js`          |       同一域名，不同协议       |                 不允许                 |
| `http://www.a.com/a.js` `http://70.32.92.74/b.js`          |        域名和域名对应ip        |                 不允许                 |
| `http://www.a.com/a.js ` `http://script.a.com/b.js`        |       主域相同，子域不同       |                 不允许                 |
| `http://www.a.com/a.js` `http://a.com/b.js`                | 同一域名，不同二级域名（同上） | 不允许（cookie这种情况下也不允许访问） |
| `http://www.cnblogs.com/a.js ` `http://www.a.com/b.js`     |            不同域名            |                 不允许                 |

总的来说同源需要满足以下三个条件都相等：

- 协议
- 端口号
- 域名

**特别注意两点：**

**第一**：如果是协议和端口造成的跨域问题“前台”是无能为力的；

**第二**：在跨域问题上，域仅仅是通过“`URL`的首部”来识别而不会去尝试判断相同的`ip`地址对应着两个域或两个域是否在同一个`ip`上。

**同源策略限制以下几种行为**：

```x86asm
1.) Cookie、LocalStorage 和 IndexedDB 无法读取
2.) DOM 和 Js对象无法获得
3.) AJAX 请求不能发送
```

## 二.跨域解决方案

1、 通过`jsonp`跨域

2、 跨域资源共享（`CORS`）

3、`nodejs`中间件代理跨域（`webpack`）

4、 `nginx`反向代理

5、` postMessage`跨域

6、`WebSocket`协议跨域

7、 `document.domain + iframe`跨域

8、` location.hash + iframe`

9、` window.name + iframe`跨域

### 1 .通过jsonp跨域

#### 原理

通常为了减轻web服务器的负载，我们把`js`、`css`，`img`等静态资源分离到另一台独立域名的服务器上，在`html`页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，也就是说：

- script
- img
- link
- iframe

通过这些属性引入的链接地址，没有同源限制；

基于此原理，我们可以通过动态创建`script`，再请求一个带参网址实现跨域通信。原理：

![image-20200829134353000](http://ahuntsun.gitee.io/blogimagebed/img/others/2/1.png)

注意：

- 服务器段返回数据是通过看起来执行了func的形式将数据和func函数转换成字符串返回的；
- 客户端收到该字符串后，经过解析就会执行该函数；
- 所以，Func必须是一个全局函数；
- 并且JSONP需要服务器支持；

**1.）原生实现：**

```javascript
 <script>
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```

服务端返回如下（返回时即执行全局函数）：

```javascript
handleCallback({"status": true, "user": "admin"})
```

**2.）vue.js：**

```javascript
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

**后端node.js代码示例：**

```javascript
var querystring = require('querystring');
var http = require('http');
var server = http.createServer();

server.on('request', function(req, res) {
    var params = qs.parse(req.url.split('?')[1]);
    var fn = params.callback;

    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');

    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

#### 缺点：

- 只能处理`get`一种请求。由于`JSONP`借助于`script`标签的 `src`属性实现的，而`src`属性都是资源文件请求，也就是`get`请求。
- 不安全，被截获串改，返回木马也执行；

### 2.跨域资源共享（CORS）

**普通跨域请求**：

只服务端设置`Access-Control-Allow-Origin`即可，前端无须设置，若要带`cookie`请求：前后端都需要设置。比较常用

**需注意的是**：

由于同源策略的限制，所读取的`cookie`为跨域请求接口所在域的`cookie`，而非当前页。如果想实现当前页`cookie`的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。

目前，所有浏览器都支持该功能(`IE8+`：`IE8/9`需要使用`XDomainRequest`对象来支持`CORS`）)，`CORS`也已经成为主流的跨域解决方案。

#### 前端设置：

**1.）原生ajax**

```javascript
// 前端设置是否带cookie
xhr.withCredentials = true;
```

示例代码：

```javascript
var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
    }
};
```

**2.）vue框架**

a.) axios设置：

```javascript
axios.defaults.withCredentials = true
```

b.) vue-resource设置：

```javascript
Vue.http.options.credentials = true
```

#### 服务端设置

若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。

**1.）Nodejs后台示例：**

```javascript
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var postData = '';

    // 数据块接收中
    req.addListener('data', function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener('end', function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
            'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
            /* 
             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
             */
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

#### 缺点

设置`Access-Control-Allow-Origin`头信息时，只能设置一个具体地址或通配符；

并且一旦设置为了通配符就不再允许携带`cookie`了；

### 3.nodejs中间件代理跨域（webpack）

结合webpack和webpack-dev-server 实现http请求代理；

只需要在webpack.config.js中配置devServer即可：

```js
devServer: {
	port: 3000,
    progress: true,
    contentBase: './build',
    proxy: {
        '/':{
            target: 'http://127.0.0.1:3000',
            changeOrigin: true
        }
    }
}
```

### 4.ngnix反向代理

不需要前端进行任何操作，仅靠后端完成；

### 5.postMessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
a.） 页面和其打开的新窗口的数据传递
b.） 多窗口之间消息传递
c.） 页面与嵌套的iframe消息传递
d.） 上面三个场景的跨域数据传递

用法：postMessage(data,origin)方法接受两个参数
data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

1.）a.html：(http://www.domain1.com/a.html)

```xml
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };

    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);
</script>
```

2.）b.html：(http://www.domain2.com/b.html)

```xml
<script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---> ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
</script>
```

### 6.WebSocket协议跨域

WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

1.）前端代码：

```xml
<div>user input：<input type="text"></div>
<script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
<script>
var socket = io('http://www.domain2.com:8080');

// 连接成功处理
socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg); 
    });

    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.'); 
    });
});

document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
```

2.）Nodejs socket后台：

```javascript
var http = require('http');
var socket = require('socket.io');

// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        'Content-type': 'text/html'
    });
    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');

// 监听socket连接
socket.listen(server).on('connection', function(client) {
    // 接收信息
    client.on('message', function(msg) {
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);
    });

    // 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.'); 
    });
});
```

### 7.document.domain + iframe跨域

此方案仅限主域相同，子域不同的跨域应用场景。

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

1.）父窗口：(http://www.domain.com/a.html)

```xml
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
```

2.）子窗口：(http://child.domain.com/b.html)

```xml
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>
```

### 8.location.hash + iframe跨域

实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

1.）a.html：(http://www.domain1.com/a.html)

```xml
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);
    
    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>
```

2.）b.html：(http://www.domain2.com/b.html)

```xml
<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>
```

3.）c.html：(http://www.domain1.com/c.html)

```xml
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```

### 9.window.name + iframe跨域

window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

1.）a.html：(http://www.domain1.com/a.html)

```javascript
var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement('iframe');

    // 加载跨域页面
    iframe.src = url;

    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();

        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
            state = 1;
        }
    };

    document.body.appendChild(iframe);

    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write('');
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};

// 请求跨域b页面数据
proxy('http://www.domain2.com/b.html', function(data){
    alert(data);
});
```

2.）proxy.html：([http://www.domain1.com/proxy....](http://www.domain1.com/proxy.html))
中间代理页，与a.html同域，内容为空即可。

3.）b.html：(http://www.domain2.com/b.html)

```xml
<script>
    window.name = 'This is domain2 data!';
</script>
```

总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。

多抽出1分钟来学习，让你的生命更加精彩！

## 配置文件

如果想保留eslint的语法检测，那就把不符合自己习惯的规则去掉吧。

配置文件在项目根目录里，文件名以 `.eslintrc.*` 为名。

```ruby
module.exports = {
  root: true,
  parser: 'babel-eslint',
  parserOptions: {
    //设置"script"（默认）或"module"如果你的代码是在ECMAScript中的模块。
    sourceType: 'module'
  },
  env: {
    browser: true,
  },
  // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style
  extends: 'standard',
  // required to lint *.vue files
  plugins: [
    'html'
  ],
  // add your custom rules here
  'rules': {
    // allow paren-less arrow functions
    'arrow-parens': 0,
    // allow async-await
    'generator-star-spacing': 0,
    // allow debugger during development
    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0,
    "no-unused-vars": [2, { 
      // 允许声明未使用变量
      "vars": "local",
      // 参数不检查
      "args": "none" 
    }],
    // 关闭语句强制分号结尾
    "semi": [0],
    //空行最多不能超过100行
    "no-multiple-empty-lines": [0, {"max": 100}],
    //关闭禁止混用tab和空格
    "no-mixed-spaces-and-tabs": [0],
  }
}
```

其中 `rules` 就是配置规则的

## 配置参数

```css
rules: {
    "规则名": [规则值, 规则配置]
}
```

规则值：

```cpp
"off"或者0    //关闭规则关闭
"warn"或者1    //在打开的规则作为警告（不影响退出代码）
"error"或者2    //把规则作为一个错误（退出代码触发时为1）
```

更多详细的说明请移步 [configuring](http://eslint.org/docs/user-guide/configuring)

## 常见规则列表

以下规则列表来自网络

```json
"no-alert": 0,//禁止使用alert confirm prompt
"no-array-constructor": 2,//禁止使用数组构造器
"no-bitwise": 0,//禁止使用按位运算符
"no-caller": 1,//禁止使用arguments.caller或arguments.callee
"no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名
"no-class-assign": 2,//禁止给类赋值
"no-cond-assign": 2,//禁止在条件表达式中使用赋值语句
"no-console": 2,//禁止使用console
"no-const-assign": 2,//禁止修改const声明的变量
"no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1)
"no-continue": 0,//禁止使用continue
"no-control-regex": 2,//禁止在正则表达式中使用控制字符
"no-debugger": 2,//禁止使用debugger
"no-delete-var": 2,//不能对var声明的变量使用delete操作符
"no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/
"no-dupe-keys": 2,//在创建对象字面量时不允许键重复 {a:1,a:1}
"no-dupe-args": 2,//函数参数不能重复
"no-duplicate-case": 2,//switch中的case标签不能重复
"no-else-return": 2,//如果if语句里面有return,后面不能跟else语句
"no-empty": 2,//块语句中的内容不能为空
"no-empty-character-class": 2,//正则表达式中的[]内容不能为空
"no-empty-label": 2,//禁止使用空label
"no-eq-null": 2,//禁止对null使用==或!=运算符
"no-eval": 1,//禁止使用eval
"no-ex-assign": 2,//禁止给catch语句中的异常参数赋值
"no-extend-native": 2,//禁止扩展native对象
"no-extra-bind": 2,//禁止不必要的函数绑定
"no-extra-boolean-cast": 2,//禁止不必要的bool转换
"no-extra-parens": 2,//禁止非必要的括号
"no-extra-semi": 2,//禁止多余的冒号
"no-fallthrough": 1,//禁止switch穿透
"no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3.
"no-func-assign": 2,//禁止重复的函数声明
"no-implicit-coercion": 1,//禁止隐式转换
"no-implied-eval": 2,//禁止使用隐式eval
"no-inline-comments": 0,//禁止行内备注
"no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数）
"no-invalid-regexp": 2,//禁止无效的正则表达式
"no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量
"no-irregular-whitespace": 2,//不能有不规则的空格
"no-iterator": 2,//禁止使用__iterator__ 属性
"no-label-var": 2,//label名不能与var声明的变量名相同
"no-labels": 2,//禁止标签声明
"no-lone-blocks": 2,//禁止不必要的嵌套块
"no-lonely-if": 2,//禁止else语句内只有if语句
"no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）
"no-mixed-requires": [0, false],//声明时不能混用声明类型
"no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格
"linebreak-style": [0, "windows"],//换行风格
"no-multi-spaces": 1,//不能用多余的空格
"no-multi-str": 2,//字符串不能用\换行
"no-multiple-empty-lines": [1, {"max": 2}],//空行最多不能超过2行
"no-native-reassign": 2,//不能重写native对象
"no-negated-in-lhs": 2,//in 操作符的左边不能有!
"no-nested-ternary": 0,//禁止使用嵌套的三目运算
"no-new": 1,//禁止在使用new构造一个实例后不赋值
"no-new-func": 1,//禁止使用new Function
"no-new-object": 2,//禁止使用new Object()
"no-new-require": 2,//禁止使用new require
"no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number
"no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON()
"no-octal": 2,//禁止使用八进制数字
"no-octal-escape": 2,//禁止使用八进制转义序列
"no-param-reassign": 2,//禁止给参数重新赋值
"no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接
"no-plusplus": 0,//禁止使用++，--
"no-process-env": 0,//禁止使用process.env
"no-process-exit": 0,//禁止使用process.exit()
"no-proto": 2,//禁止使用__proto__属性
"no-redeclare": 2,//禁止重复声明变量
"no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/
"no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错
"no-return-assign": 1,//return 语句中不能有赋值表达式
"no-script-url": 0,//禁止使用javascript:void(0)
"no-self-compare": 2,//不能比较自身
"no-sequences": 0,//禁止使用逗号运算符
"no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名
"no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用
"no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格
"no-sparse-arrays": 2,//禁止稀疏数组， [1,,2]
"no-sync": 0,//nodejs 禁止同步方法
"no-ternary": 0,//禁止使用三目运算符
"no-trailing-spaces": 1,//一行结束后面不要有空格
"no-this-before-super": 0,//在调用super()之前不能使用this或super
"no-throw-literal": 2,//禁止抛出字面量错误 throw "error";
"no-undef": 1,//不能有未定义的变量
"no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined
"no-undefined": 2,//不能使用undefined
"no-unexpected-multiline": 2,//避免多行表达式
"no-underscore-dangle": 1,//标识符不能以_开头或结尾
"no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;
"no-unreachable": 2,//不能有无法执行的代码
"no-unused-expressions": 2,//禁止无用的表达式
"no-unused-vars": [2, {"vars": "all", "args": "after-used"}],//不能有声明后未被使用的变量或参数
"no-use-before-define": 2,//未定义前不能使用
"no-useless-call": 2,//禁止不必要的call和apply
"no-void": 2,//禁用void操作符
"no-var": 0,//禁用var，用let和const代替
"no-warning-comments": [1, { "terms": ["todo", "fixme", "xxx"], "location": "start" }],//不能有警告备注
"no-with": 2,//禁用with

"array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格
"arrow-parens": 0,//箭头函数用小括号括起来
"arrow-spacing": 0,//=>的前/后括号
"accessor-pairs": 0,//在对象中使用getter/setter
"block-scoped-var": 0,//块语句中使用var
"brace-style": [1, "1tbs"],//大括号风格
"callback-return": 1,//避免多次调用回调什么的
"camelcase": 2,//强制驼峰法命名
"comma-dangle": [2, "never"],//对象字面量项尾不能有逗号
"comma-spacing": 0,//逗号前后的空格
"comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾
"complexity": [0, 11],//循环复杂度
"computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的
"consistent-return": 0,//return 后面是否允许省略
"consistent-this": [2, "that"],//this别名
"constructor-super": 0,//非派生类不能调用super，派生类必须调用super
"curly": [2, "all"],//必须使用 if(){} 中的{}
"default-case": 2,//switch语句最后必须有default
"dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾
"dot-notation": [0, { "allowKeywords": true }],//避免不必要的方括号
"eol-last": 0,//文件以单一的换行符结束
"eqeqeq": 2,//必须使用全等
"func-names": 0,//函数表达式必须有名字
"func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式
"generator-star-spacing": 0,//生成器函数*的前后空格
"guard-for-in": 0,//for in循环要用if语句过滤
"handle-callback-err": 0,//nodejs 处理错误
"id-length": 0,//变量名长度
"indent": [2, 4],//缩进风格
"init-declarations": 0,//声明时必须赋初值
"key-spacing": [0, { "beforeColon": false, "afterColon": true }],//对象字面量中冒号的前后空格
"lines-around-comment": 0,//行前/行后备注
"max-depth": [0, 4],//嵌套块深度
"max-len": [0, 80, 4],//字符串最大长度
"max-nested-callbacks": [0, 2],//回调嵌套深度
"max-params": [0, 3],//函数最多只能有3个参数
"max-statements": [0, 10],//函数内最多有几个声明
"new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用
"new-parens": 2,//new时必须加小括号
"newline-after-var": 2,//变量声明后是否需要空一行
"object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格
"object-shorthand": 0,//强制对象字面量缩写语法
"one-var": 1,//连续声明
"operator-assignment": [0, "always"],//赋值运算符 += -=什么的
"operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首
"padded-blocks": 0,//块语句内行首行尾是否要空行
"prefer-const": 0,//首选const
"prefer-spread": 0,//首选展开运算
"prefer-reflect": 0,//首选Reflect的方法
"quotes": [1, "single"],//引号类型 `` "" ''
"quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号
"radix": 2,//parseInt必须指定第二个参数
"id-match": 0,//命名检测
"require-yield": 0,//生成器函数必须有yield
"semi": [2, "always"],//语句强制分号结尾
"semi-spacing": [0, {"before": false, "after": true}],//分号前后空格
"sort-vars": 0,//变量声明时排序
"space-after-keywords": [0, "always"],//关键字后面是否要空一格
"space-before-blocks": [0, "always"],//不以新行开始的块{前面要不要有空格
"space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格
"space-in-parens": [0, "never"],//小括号里面要不要有空格
"space-infix-ops": 0,//中缀操作符周围要不要有空格
"space-return-throw-case": 2,//return throw case后面要不要加空格
"space-unary-ops": [0, { "words": true, "nonwords": false }],//一元运算符的前/后要不要加空格
"spaced-comment": 0,//注释风格要不要有空格什么的
"strict": 2,//使用严格模式
"use-isnan": 2,//禁止比较时使用NaN，只能用isNaN()
"valid-jsdoc": 0,//jsdoc规则
"valid-typeof": 2,//必须使用合法的typeof的值
"vars-on-top": 2,//var必须放在作用域顶部
"wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格
"wrap-regex": 0,//正则表达式字面量用小括号包起来
"yoda": [2, "never"]//禁止尤达条件
```

多抽出1分钟来学习，让你的生命更加精彩！

# 一文摸透从输入`URL`到页面渲染的过程

从输入`URL`到页面渲染需要`Chrome`浏览器的多个进程配合，所以我们先来谈谈现阶段`Chrome`浏览器的多进程架构。

## 一、`Chrome`架构

目前`Chrome`采用的是多进程的架构模式，可分为主要的五类进程，分别是：浏览器（`Browser`）主进程、 `GPU` 进程、网络（`NetWork`）进程、多个渲染进程和多个插件进程；

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/0.1.png)

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**。核心任务是将` HTML`、`CSS` 和 `JavaScript `转换为用户可以与之交互的网页，排版引擎`Blink`和`JavaScript`引擎`V8`都是运行在该进程中，默认情况下，`Chrome`会为每个`Tab`标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **`GPU`进程**。其实，`Chrome`刚开始发布的时候是没有`GPU`进程的。而`GPU`的使用初衷是为了实现`3D CSS`的效果，只是随后网页、`Chrome`的`UI`界面都选择采用`GPU`来绘制，这使得`GPU`成为浏览器普遍的需求。最后，`Chrome`在其多进程架构上也引入了`GPU`进程。
- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

了解了`Chrome`的多进程架构，就能够从宏观上理解从输入`URL`到页面渲染的过程了，这个过程主要分为**导航阶段**和**渲染阶段**。

## 二、导航阶段

### Ⅰ.浏览器主进程

#### 1.用户输入`URL`

- 1、

  浏览器进程检查

  ```
  url
  ```

  ，组装协议，构成完整的

  ```
  url
  ```

  ，这时候有两种情况：

  - 输入的是搜索内容：地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的`URL`。
  - 输入的是请求`URL`：地址栏会根据规则，给这段内容加上协议，合成为完整的`URL`；

- **2、**浏览器进程通过进程间通信（`IPC`）把`url`请求发送给网络进程；

### Ⅱ.网络进程

#### 2.`URL`请求过程

- **3、**网络进程接收到`url`请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程；

> 这里涉及到浏览器与HTTP协议的缓存策略问题，有兴趣的可以看这篇文章：[详解HTTP协议](https://www.cnblogs.com/AhuntSun-blog/p/12529920.html)

- **4、**准备`IP`地址和端口：进行`DNS`解析时先查找缓存，没有再使用`DNS`服务器解析，查找顺序为：

  - 浏览器缓存；
  - 本机缓存；
  - `hosts`文件；
  - 路由器缓存；
  - `ISP DNS`缓存；
  - `DNS`递归查询（本地`DNS`服务器 -> 权限`DNS`服务器 -> 顶级`DNS`服务器 -> `13`台根`DNS`服务器）

- **5、**等待`TCP`队列：浏览器会为每个域名最多维护`6`个`TCP`连接，如果发起一个`HTTP`请求时，这 `6`个 `TCP`连接都处于忙碌状态，那么这个请求就会处于排队状态；解决方案：

  - 采用域名分片技术：将一个站点的资源放在多个（`CDN`）域名下面。
  - 升级为`HTTP2`，就没有`6`个`TCP`连接的限制了；

- **6、**通过三次握手建立`TCP`连接：

  ![123](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/0.2.png)

  - **第一次：**客户端先向服务器端发送一个同步数据包，报文的`TCP`首部中：标志位：**同步`SYN`**为`1`，表示这是一个请求建立连接的数据包；序号`Seq=x`，`x`为所传送数据的第一个字节的序号，随后进入`SYN-SENT`状态；

  > 标志位值为`1`表示该标志位有效。

  - **第二次：**服务器根据收到数据包的`SYN`标志位判断为建立连接的请求，随后返回一个确认数据包，其中标志位`SYN=1`，`ACK=1`，序号`seq=y`，确认号`ack=x + 1`表示收到了客户端传输过来的`x`字节数据，并希望下次从`x+1`个字节开始传，并进入`SYN-RCVD`状态；

  > 这里要区分标志位`ACK`和确认号`ack`；

  - **第三次：**客户端收到后，再给服务器发送一个确认数据包，标志位`ACK=1`，序号`seq=x+1`，确认号`ack=y+1`，随后进入`ESTABLISHED`状态；

  服务器端收到后，也进入`ESTABLISHED`状态，由此成功建立了`TCP`连接，可以开始数据传送；

  - **为什么要第三次挥手？**避免服务器等待造成**资源浪费**，具体原因：

  > 如果没有最后一个数据包确认（第三次握手），`A`先发出一个建立连接的请求数据包，由于网络原因绕远路了。`A`经过设定的超时时间后还未收到`B`的确认数据包。
  >
  > 于是发出第二个建立连接的请求数据包，这次网路通畅，`B`的确认数据包也很快就到达`A`。于是`A`与`B`开始传输数据；
  >
  > 过了一会`A`第一次发出的建立连接的请求数据包到达了`B`，`B`以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以会忽略`B`发来的第二个确认数据包，但是`B`发出确认数据包之后就要一直等待`A`的回复，而`A`永远也不会回复。
  >
  > 由此造成服务器资源浪费，这种情况多了`B`计算机可能就停止响应了。

- **7、**构建并发送`HTTP`请求信息；

- **8、**服务器端处理请求；

- **9、**客户端处理响应，首先检查服务器响应报文的状态码：

  - 如果是`301/302`表示服务器已更换域名需要重定向，这时网络进程会从响应头的`Location`字段里面读取重定向的地址，然后再发起新的`HTTP`或者`HTTPS`请求，跳回第`4`步。
  - 如果是`200`，就检查`Content-Type`字段，值为`text/html`说明是`HTML`文档，是`application/octet-stream`说明是文件下载；

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/1.png)

- **10、**请求结束，当通用首部字段`Conection`不是`Keep-Alive`时，即不为`TCP`长连接时，通过四次挥手断开`TCP`连接：

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/1.5.png)

- **第一次：**客户端（主动断开连接）发送数据包给服务器，其中标志位`FIN=1`，序号位`seq=u`，并停止发送数据；
- **第二次：**服务器收到数据包后，由于还需传输数据，无法立即关闭连接，先返回一个标志位`ACK=1`，序号`seq=v`，确认号`ack=u+1`的数据包；
- **第三次：**服务器准备好断开连接后，返回一个数据包，其中标志位`FIN=1`，标志位`ACK=1`，序号`seq=w`，确认号`ack=u+1`；
- **第四次：**客户端收到数据包后，返回一个标志位`ACK=1`，序号`seq=u+1`，确认号`ack=w+1`的数据包。

由此通过四次挥手断开`TCP`连接。

> 详细过程参见：[详解TCP连接的“三次握手”与“四次挥手”(上)](https://www.cnblogs.com/AhuntSun-blog/p/12028636.html)

- **为什么要四次挥手？**由于服务器不能马上断开连接，导致`FIN`释放连接报文与`ACK`确认接收报文需要分两次传输，即第二次和第三次"挥手"；

#### 3.准备渲染进程

- **11、**准备渲染进程：浏览器进程检查当前`url`是否与之前打开了渲染进程的页面的根域名相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程；

#### 4.提交文档

- 12、

  提交文档：

  - **渲染进程**准备好后，**浏览器**向**渲染进程**发起“**提交文档**”的消息，**渲染进程**接收到消息后与**网络进程**建立传输数据的“**管道**”
  - **渲染进程**接收完数据后，向浏览器发送“**确认提交**”
  - **浏览器进程**接收到确认消息后更新浏览器界面状态：**安全状态**、**地址栏`url`**、**前进后退的历史状态**、**更新`web`页面**

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2.png)

## 三、渲染阶段

在渲染阶段通过**渲染流水线**在渲染进程的主线程和合成线程配合下，完成页面的渲染；

### Ⅲ.渲染进程

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/3.png)

> **渲染进程中的主线程部分**

#### 5.构建`DOM`树

- **13、**先将请求回来的数据解压，随后`HTML`解析器将其中的`HTML`**字节流**通过**分词器**拆分为一个个`Token`，然后生成节点`Node`，最后解析成浏览器识别的`DOM`树结构。

  可以通过`Chrome`调试工具的`Console`选项打开控制台输入`document`查看`DOM`树；

> 渲染引擎还有一个**安全检查模块**叫 `XSSAuditor`，是用来**检测词法安全**的。在分词器解析出来 `Token` 之后，它会检测这些模块是否安全，比如**是否引用了外部脚本**，**是否符合 `CSP` 规范**，**是否存在跨站点请求**等。如果出现不符合规范的内容，`XSSAuditor` 会对该脚本或者下载任务**进行拦截**。

首次解析`HTML`时**渲染进程**会开启一个**预解析线程**，遇到`HTML`文档中内嵌的`JavaScript`和`CSS`外部引用就会同步提前下载这些文件，下载时间以最后下载完的文件为准。

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/4.png)

#### 6.构建`CSSOM`

- **14、**`CSS`解析器将`CSS`转换为浏览器能识别的`styleSheets`也就是`CSSOM`：可以通过控制台输入`document.styleSheets`查看；

  这里要考虑一下阻塞的问题，由于`JavaScript`有修改`CSS`和`HTML`的能力，所以，需要先等到 `CSS` 文件下载完成并生成 `CSSOM`，然后再执行 `JavaScript` 脚本，最后再继续构建 `DOM`。由于这种阻塞，导致了**解析白屏**；

> **优化方案：**
>
> - **移除`js`和`css`的文件下载**：通过内联 `JavaScript`、内联 `CSS`；
> - **尽量减少文件大小**：如通过 `webpack` 等工具**移除**不必要的**注释**，并**压缩 `js` 文件**；
> - 将不进行`DOM`操作或`CSS`样式修改的 `JavaScript` 标记上 `sync` 或者 `defer`异步引入；
> - **使用媒体查询属性**：将大的`CSS`文件拆分成多个不同用途的 `CSS` 文件，只有在特定的场景下才会加载特定的 `CSS` 文件。

可以通过浏览器调试工具的`Network`面板中的`DOMContentLoaded`查看最后生成`DOM`树所需的时间；

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/5.png)

![image-20200405110720560](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/6.png)

#### 7.样式计算

- **15、**转换样式表中的属性值，使其标准化。比如将`em`转换为`px`，`color`转换为`rgb`；
- **16、**计算`DOM`树中每个节点的具体样式，这里遵循`CSS`的继承和层叠规则；可以通过`Chrome`调试工具的`Elements`选项的`Computed`查看某一标签的最终样式；

![image-20200405110849074](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7.png)

#### 8.布局阶段

- **17、**创建布局树，遍历`DOM`树中的所有节点，去掉所有隐藏的节点（比如`head`，添加了`display:none`的节点），只在布局树中保留可见的节点。
- **18、**计算布局树中节点的坐标位置（较复杂，这里不展开）；

#### 9.分层

- **19、**对布局树进行分层，并生成分层树（`Layer Tree`），可以通过`Chrome`调试工具的`Layer`选项查看。分层树中每一个节点都直接或间接的属于一个图层（如果一个节点没有对应的层，那么这个节点就从属于父节点的图层）

![image-20200405111350260](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/8.png)

#### 10.图层绘制

- **20、**为每个图层生成绘制列表（即绘制指令），并将其提交到合成线程。以上操作都是在渲染进程中的主线程中进行的，提交到合成线程后就不阻塞主线程了；

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/9.png)

> **渲染进程中的合成线程部分**

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/10.png)

#### 11.切分图块

**21、**合成线程将图层切分成大小固定的图块（`256x256`或者`512x512`）然后**优先绘制**靠近视口的图块，这样就可以大大加速页面的显示速度；

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/11.png)

### Ⅳ.`GPU`进程

#### 12.栅格化操作

- **22、**在**光栅化线程池**中将**图块**转换成**位图**，通常这个过程都会使用`GPU`来加速生成，使用`GPU`生成位图的过程叫**快速栅格化**，或者`GPU`栅格化，生成的位图被保存在`GPU`内存中。

![img](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/12.png)

### Ⅴ.浏览器主进程

#### 13.合成与显示

- **23、**合成：一旦所有图块都被光栅化，**合成线程**就会将它们合成为一张图片，并生成一个绘制图块的命令——“`DrawQuad`”，然后将该命令提交给浏览器进程。

> **注意了：**合成的过程是在渲染进程的**合成线程**中完成的，不会影响到渲染进程的**主线程**执行；

- **24、**显示：浏览器进程里面有一个叫`viz`的组件，用来接收合成线程发过来的`DrawQuad`命令，然后根据`DrawQuad`命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的`HTML`、`CSS`、`JavaScript`等文件，经过浏览器就会显示出漂亮的页面了。

## 前言

当我们去面试的时候，很大概率会被面试官问这么一个问题：你有尝试过对项目做性能优化吗？或者你了解哪些性能优化的方法？听到这个问题的你可能是这样的：

![img](https://img2020.cnblogs.com/blog/1845293/202004/1845293-20200411143924291-1388823336.png)

似曾相识但又说不清楚，往往只能零散地说出那么几点，难以做到有条理的回答。那么，本文就带你简单了解前端性能优化的几个主要方面，旨在抛砖引玉。

## 一、资源的合并和压缩

`web`前端应用的开发与部署过程：

![image-20200330221214962](http://ahuntsun.gitee.io/blogimagebed/img/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.png)

输入`url`到页面显示出来的过程：

![image-20200330221250064](http://ahuntsun.gitee.io/blogimagebed/img/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.png)

请求过程中一些潜在的性能优化点：

- `dns`是否可以通过缓存减少`dns`查询时间？
- 网络请求的过程如何走最近的网络环境？
- 相同的静态资源是否可以缓存？
- 能否减少`http`请求的大小和次数？
- 能否进行服务端渲染？

**总结：**深入理解`http`请求的过程是前端性能优化的核心。

**优化核心**

- 减少`http`请求数量；
- 减少请求资源的大小；

**`google`首页案例学习**

- `html`压缩；
- `css`压缩；
- `js`的压缩和混乱；
- 文件合并；
- 开启`gzip`；

### 1.`html`压缩

`HTML`代码压缩就是压缩一些在文本文件中有意义，但是在`HTML`中**不显示**的字符，包括**空格**，**制表符**，**换行符**等，还有一些其他意义的字符，如**`HTML`注释**也可以被压缩；

**一个简单的计算：**

`google`的流量，占到整个互联网的`40%`，预计`2016`年全球网络流量将达到`1.3ZB(1ZB = 10^9TB)`，那么`google`在`2016`年的流量就是`1.3ZB * 40%`，如果`google`每`1MB`请求减少一个字节，**每年可以节省流量近`500TB`**流量。

**如何进行`html`压缩**

- 使用在线网站进行压缩；
- `nodejs`提供的`html-minifier`工具；
- 后端模板引擎渲染压缩；

### 2.`css`代码压缩

分为两部分：

- 无效代码的压缩；
- `css`语义合并；

**如何进行`css`压缩**

- 使用在线网站进行压缩；
- 使用`html-minifier`对`html`中的`css`进行压缩；
- 使用`clean-css`对`css`进行压缩；

### 3.`js`压缩与混乱（丑化）

包括：

- 无效字符的删除（空格，回车等）；
- 剔除注释；
- 代码语义的缩减和优化；
- 代码保护（如果代码不经处理，客户端可直接窥探代码漏洞）；

**`JS`压缩与混乱（丑化）**

- 使用在线网站进行压缩：https://tool.oschina.net/jscompress/

![image-20200330230443570](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1c6d13fd18?w=1318&h=514&f=png&s=51886)

- 使用`html-minifier`对`html`中的`js`进行压缩；
- 使用`uglify.js2`对`js`进行压缩；

### 4.文件合并

文件合并的好处：

![image-20200330224139300](http://ahuntsun.gitee.io/blogimagebed/img/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.png)

左边的表示使用`http`长链接`keep-alive`但不合并请求的情况，需要分三次去获取`a.js`、`b.js`、`c.js`；右边是使用长链接并且合并请求的情况，只需要发送一次获取合并文件`a-b-c.js`的请求，就能将三个文件都请求回来。

不合并请求有下列缺点：

- 文件与文件之间有插入的上行请求，会增加`N-1`个网络延迟；
- 受丢包问题的影响更严重：因为每次请求都可能出现丢包的情况，减少请求能有效减少丢包情况；
- `keep-alive`本身也存在问题：经过代理服务器时可能会被断开；

**文件合并存在的问题**

- 首屏渲染问题：当请求`js`文件的时候，如果页面渲染只依赖`a.js`文件，由于文件合并，需要等待合并后的`a-b-c.js`文件请求回来才能继续渲染，这样就会导致页面渲染速度变慢。这种情况大多出现在现代化的前端框架，如`Vue`等的使用过程中；
- 缓存失效问题：合并后的文件`a-b-c.js`中只要其中一个文件（比如`a.js`）发生变化，那么整个合并文件都将失效，而不采用文件合并就不会出现这种情况；

**使用建议**

- 公共库合并：将不经常发生变化的公共组件库文件进行合并；
- 将不同页面的`js`文件单独合并：比如在单页面应用`SPA`中，当路由跳转到具体的页面时才请求该页面需要的`js`文件；

**如何进行文件合并**

- 使用在线网站进行文件合并；
- 使用`nodejs`实现文件合并；
- 使用`webpack`等前端构件化工具也可以很好地实现；

## 二、图片相关的优化

**有损压缩过程：**

![image-20200330232432166](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1c6f5a52c3?w=1102&h=571&f=png&s=215654)

一张`JPG`图片的解析分别要进行：

- 颜色空间的转换：从`RGB`的颜色空间转到其他的颜色空间 ；
- 进行重采样：区分高频和低频的颜色变换；
- 进行`DCT`过程：对高频的颜色采样结果进行压缩，这样压缩的收益会比较大；
- 再对数据进行量化；
- 最后进行编码（`encoding`）；

最终得到`JPEG-Compressed Image Data`，即真正显示出来的`JPG`图片。虽然这是一种有损压缩，但是很多情况下，这些损失的数据并不影响显示；

**`png8/png24/png32`之间的区别**

- `png8`：`256`色 `+` 支持透明；
- `png24`：`2^24`色 `+` 不支持透明；
- `png32`：`2^32`色 `+` 支持透明；

**不同格式图片常用的业务场景**

- `jpg`有损压缩，压缩率高，支持透明；应用：大部分不需要透明图片的业务场景；
- `png`支持透明，浏览器兼容好；应用：大部分需要透明图片的业务场景；
- `webp`（`2010`年由谷歌推出）压缩程度更好，在`ios webview`中有兼容性问题；应用：安卓全部；
- `svg`矢量图，代码内嵌，相对较小，用于图片样式相对简单的场景；应用：比如`logo`和`iconfont`；

### 1.图片压缩

针对真实图片情况，舍弃一些相对无关紧要的色彩信息，对图片进行压缩；比如在线压缩网站：https://tinypng.com/

![image-20200331102612277](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1c777fd86d?w=1312&h=671&f=png&s=610754)

### 2.`css`雪碧图

将网站上用到的一些图片整合到一张单独的图片中，从而减少网站`HTTP`请求数量。原理为：设定整张雪碧图可示区域，将想要显示的图标定位到该处（左上角）；**缺点：**整合图片比较大时，一次加载比较慢。

如天猫的雪碧图：

![image-20200331100812635](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1cabcab8f3?w=955&h=521&f=png&s=71525)

很多情况下，并不是所有的小图标都放在一张雪碧图中，而是会适当进行拆分。现在使用雪碧图的场景比较少了。

自动生成雪碧图样式的网站：http://www.spritecow.com/

![image-20200331111632363](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1cae1c4e75?w=1140&h=785&f=png&s=363553)

选中雪碧图中对应的图标，就会生成对应的样式。

### 3.网页内联图片（`Image inline`）

将图片的内容内嵌到`html`当中，减少网站的`HTTP`请求数量，常用于处理小图标和背景图片。网页内联图片写法为：

```xml
 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA..." alt="">
```

浏览器上的表现形式为：

![image-20200331105927649](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1cbdabaf38?w=1054&h=325&f=png&s=76209)

这里提供一个将：`image` 转 `DataUrI`的网址：http://tool.c7sky.com/datauri/

![image-20200331105719573](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1cb0bdca9b?w=1030&h=586&f=png&s=77587)

**缺点：**

- 浏览器不会缓存内联图片资源；
- 兼容性较差，只支持`ie8`以上浏览器；
- 超过`1000kb`的图片，`base64`编码会使图片大小增大，导致网页整体下载速度减慢；

所以要根据场景使用，不过内联图片**减少`HTTP`请求**的优点还是很显著的。比如，在开发中小于`4KB`或`8KB`的图片都会通过构建工具自动`inline`到`HTML`中，这种情况下`Image inline`带来的图片大小增长其实是比增加`HTTP`请求次数更优的。

### 4.矢量图`SVG`与`iconfont`

**使用`iconfont`解决`icon`问题**

应尽量使用该方式，比如可以采用阿里巴巴矢量图库：

![image-20200331102136261](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1cb4385403?w=1018&h=421&f=png&s=24626)

可以选择格式进行下载：

![image-20200331102259285](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1cbb0d2a3d?w=1018&h=732&f=png&s=42482)

可以看到它们的大小有着明显的差异：

![image-20200331102353635](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1cf1bd08bf?w=768&h=57&f=png&s=8963)

**使用`SVG`进行矢量图的控制**

`SVG `意为可缩放矢量图形（`Scalable Vector Graphics`）。`SVG` 使用 `XML` 格式定义图像。下为示例：

![image-20200331112542540](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1cf24b39af?w=1230&h=406&f=png&s=35645)

在线转换网站：http://www.bejson.com/convert/image_to_svg/

![image-20200331112802316](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1cf23f75ed?w=1418&h=799&f=png&s=114803)

### 5.`webp`

`webp`的优势体现在它具有更优的图像压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、`Alpha`透明以及动画的特性。在`JPEG`和`PNG`上的转化效果都非常优秀、稳定和统一。安卓上不存在兼容性问题，推荐安卓下使用。

以下为淘宝网首页请求的图片：
![image-20200331101234068](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d020b8613?w=965&h=305&f=png&s=121907)

可以看到，图片中大量地添加了`webp`格式的选择。`.jpg_.webp`表示当浏览器支持`webp`时采用`webp`格式，否则采用`jpg`格式。

下面为`B`站首页的图片，可以看到基本都采用了`webp`格式：

![image-20200401110811561](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d0ed2bb59?w=991&h=604&f=png&s=180232)

同一张图片`jpg`格式和`webp`格式压缩率有着明显的差异：

![image-20200331101633934](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d117540e8?w=747&h=56&f=png&s=8490)

可以通过在线网站将图片转换为`webp`：https://zhitu.isux.us/

![image-20200331103230221](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d274f721d?w=1267&h=782&f=png&s=766897)

像图片这样的静态文件可以存放在`CDN`服务器上，让`CDN`服务器批量地将图片转换成`Webp`格式；

## 三、浏览器渲染引擎与阻塞

### 1.渲染的主要模块

版本一：

![image-20200331131925229](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d2e30d383?w=817&h=391&f=png&s=93555)

版本二：

![image-20200331113305758](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d3b852d62?w=1167&h=264&f=png&s=134420)

一个渲染引擎主要包括：`HTML`解析器，`CSS`解析器，`javascript`引擎，布局`layout`模块，绘图模块：

- `HTML`解析器：解释`HTML`文档的解析器，主要作用是将`HTML`文本解释成`DOM`树；
- `CSS`解析器：它的作用是为`DOM`中的各个元素对象计算出样式信息，为布局提供基础设施；
- `Javascript`引擎：使用`Javascript`代码可以修改网页的内容，也能修改`css`的信息，`javascript`引擎能够解释`javascript`代码，并通过`DOM`接口和`CSS`树接口来修改网页内容和样式信息，从而改变渲染的结果；
- 布局（`layout`）：在`DOM`创建之后，`Webkit`需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型；
- 绘图模块（`paint`）：使用图形库将布局计算后的各个网页的节点绘制成图像结果；

### 2.渲染过程

浏览器渲染页面的整个过程：浏览器会从上到下解析文档。

1. 浏览器解析时遇见 `HTML` 标记，就会调用`HTML`解析器解析为对应的 `token` （一个`token`就是一个标签文本的序列化）并构建 `DOM` 树（就是一块内存，保存着`tokens`，建立它们之间的关系）。在生成`DOM`的最开始阶段（应该是`Bytes` → `characters`后），并行发起`css`、图片、`js`的请求，无论他们是否在`HEAD`标签中。

   > 注意：发起`js`文件的下载请求（`request`）并不需要`DOM`处理到那个`script`节点；

2. 遇见 `style/link` 标记 调用解析器 处理 `CSS` 标记并构建 `CSS`样式树；

3. 遇见 `script` 标记 调用 `javascript`解析器处理`script`标记，绑定事件、修改`DOM`树/`CSS`树等；

4. 将 `DOM`树 与 `CSS`树 合并成一棵渲染树（`Render Tree`）。

5. 布局（`Layout`）：根据渲染树中各节点的样式和依赖关系，计算出每个节点在屏幕中的位置；

6. 绘图（`Painting`）：按照计算出来的结果：要显示的节点、节点的`CSS`与位置信息，通过显卡，把内容画到屏幕上；

经过第一次`Painting`之后`DOM`、`CSSOM`、`Render Tree`都可能会被多次更新，比如`JS`修改了`DOM`或者`CSS`属性时，`Layout`和`Painting`就会被重复执行。除了`DOM`、`CSSOM`更新的原因外，图片下载完成后也需要调用`Layout` 和 `Painting`来更新网页。

> **补充：**
>
> - `HTML`中可能会引入很多的`css、js`这样的外部资源，这些外部资源在浏览器端是并发加载的。但是浏览器会对同一域名进行并发数量（度）的限制，即单个域名的并发度是有限的；
> - 所以，经常将大部分的资源托管到`CDN`服务器上，并且设置`3~4`个`CDN`域名。防止只有一个`CDN`域名的情况下，达到了浏览器外部资源并发请求数目的上限，导致很多资源无法做到并发请求。所以，应设置多个`CDN`域名；

### 3.`css`阻塞

只有通过`link`引入的外部`css`才会产生阻塞：

- **`style`标签中的样式：**
  - 由`html`解析器进行解析；
  - 不阻塞浏览器渲染（可能会产生“闪屏现象”）；
  - 不阻塞`DOM`解析；
- **`link`引入的外部`css`样式（推荐使用的方式）：**
  - 由`CSS`解析器进行解析；
  - 阻塞浏览器渲染：由于`css`已经加载完毕，所以整个渲染过程是带样式的，所以这种阻塞可以避免“闪屏现象”；
  - 阻塞其后面的`js`语句的执行：这个不难理解，`js`文件中经常会出现`DOM`操作，操作过程中有可能涉及到`css`样式的修改。实际上，这些修改往往是依赖于之前引入的`css`设定的样式的，所以`css`会阻塞`js`的执行；
  - 不阻塞DOM的解析；
- **优化核心理念：尽可能快的提高外部`css`加载速度：**
  - 使用`CDN`节点进行外部资源加速；
  - 对`css`进行压缩(利用打包工具，比如`webpack`，`gulp`等)；
  - 减少`http`请求数，将多个`css`文件合并；
  - 优化样式表的代码；

### 4.`js`阻塞

- **阻塞DOM解析:**

  原因：浏览器不知道后续脚本的内容，如果先去解析了下面的`DOM`，而随后的`js`删除了后面所有的`DOM`，那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如像`document.write`这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析`DOM`；可以通过给`script`标签添加`defer`和`async`属性，异步引入`js`文件，以此来解决这一问题。

- **阻塞页面渲染:**

  原因：`js`中也可以给`DOM`设置样式，浏览器同样等该脚本执行完毕，再继续干活，避免做无用功；

- **阻塞后续`js`的执行:**

  原因：`js`是按顺序执行的，这样可以维护依赖关系，例如：必须先引入`jQuery`再引入`bootstrap`；

- **不阻塞资源的加载：**

  这并不与上面矛盾，因为不可能由于加载一个`js`文件就把其他资源的加载都阻塞了。针对这种常见的情况，浏览器会通过预加载的方式加载后续的资源；

### 5.总结

- `css`的解析和`js`的执行是互斥的（互相排斥），`css`解析的时候`js`停止执行，`js`执行的时候`css`停止解析；

- 无论`css`阻塞，还是`js`阻塞，都不会阻塞浏览器**加载**外部资源（图片、视频、样式、脚本等）；

  因为览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，由浏览器自己协调。显然这种做法效率很高；

- `WebKit` 和`Firefox` 都进行了【**预解析**】这项优化。在执行`js`脚本时，浏览器的其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 `DOM` 树

## 四、懒加载和预加载

### 1.懒加载

图片进入可视区域之后再请求图片资源的方式称为图片懒加载。适用于图片很多，页面很长的业务场景，比如电商；

**懒加载的作用：**

- **减少无效资源的加载：**

  比如一个网站有十页图片，用户只查看了第一页的图片，这就没必要将十页图片全都加载出来；

- **并发加载的资源过多会阻塞`js`的加载，影响网站正常的使用：**

  由于浏览器对某一个`host name`是有并发度上限的，如果图片资源所在的`CDN`和静态资源所在的`CDN`是同一个的话，过多图片的并发加载就会阻塞后续`js`文件的并发加载。

**懒加载实现的原理：**

监听`onscroll`事件，判断可视区域位置：

图片的加载是依赖于`src`路径的，首先可以为所有懒加载的静态资源添加自定义属性字段，用于存储真实的`url`。比如是图片的话，可以定义`data-src`属性存储真实的图片地址，`src`指向`loading`的图片或占位符。然后当资源进入视口的时候，才将`src`属性值替换成`data-src`中存放的真实`url`。

```html
<img src="" class="image-item" alt="" lazyload = "true" data-src="TB27YQvbm_I8KJjy0FoXXaFnVXa_!!400677031.jpg_180x180xzq90.jpg_.webp">
```

**懒加载实例**

可以使用元素的`getBoundingRect().top`来判断当前位置是否在视口内，也可以使用元素距离文档顶部的距离`offsetTop`和`scrollTop`是否小于视口高度来判断：

![image-20200331153831469](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d3dd88bc2?w=770&h=657&f=png&s=24377)

**举例**

比如手机淘宝首页：

![image-20200331145210486](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d3f33f519?w=1627&h=803&f=png&s=543095)

当快要滚动到需要展示的图片时才进行图片的请求，可以看到图片上有一个`lazyload`的属性：

![image-20200331145756313](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d751162c7?w=481&h=83&f=png&s=11410)

### 2.预加载

预加载与懒加载正好是相反的过程：**懒加载**实际上是延迟加载，将我们所需的静态资源加载时间延后；而**预加载**是将图片等静态资源在使用之前的提前请求，这样资源在使用到时能从缓存中直接加载，从而提升用户体验；

**预加载的作用：**

- **提前请求资源，提升加载速度**：使用时只需要读取浏览器缓存中提前请求到的资源即可；

- **维护页面的依赖关系**：比如`WebGL`页面，会依赖一些`3D`模型，这些都是页面渲染所必须的资源。如果资源都没有加载完毕就进行页面的渲染，就会造成非常不好的体验。

  所以时常使用预加载的方式维护页面渲染的依赖关系，比如将`WebGL`页面依赖的`3D`模型加载完之后才进行页面渲染。这样渲染的过程就不会有任何阻碍，具有较好的用户体验；

**预加载的实例**

例如九宫格抽奖业务，每个奖品都有一个选中态和非选中态，实际上这是由两张图片组合而成的。由于每个奖品的选中过程都是一瞬间，这就对图片的选中态和非选中态切换效率要求很高，如果选中态的图片没有预加载的话显然是来不及的。

![image-20200331150725347](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d4f47acaa?w=631&h=577&f=png&s=219895)

所以，实际上对于九宫格中所有图片选中态的样式和对应的图片都需要进行预加载，从而让我们在抽奖的过程中，能够瞬间从缓存中读取到选中态的图片，从而不影响抽奖效果的展示。

除此之外还有网站登录或活动时需要用到的动画，这是在动画需要的每帧图片都完全预加载完之后才会进行显示的。

## 五、重绘与回流

### 1.`CSS`图层

浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染	`DOM`的时候，浏览器所做的工作实际上是：

​	1、获取`DOM`后分割为多个图层；

​	2、对每个图层的节点计算样式结果（`Recalculate style`--样式重计算）；

​	3、为每个节点生成图形和位置（`Layout`--回流和重布局）；

​	4、将每个节点绘制填充到图层位图中（`Paint Setup`和`Paint`--重绘）；

​	5、图层作为纹理上传至`GUI`；

​	6、复合多个图层到页面上生成最终屏幕图像（`Composive Layers`--图层重组）；

### 2.创建图层的条件

- 拥有`3D`或透视变换的`css`属性（`prespective transform` ）；

- 使用加速视频解码的``节点；

- 拥有`3D(WebGL)`上下文或加速的`2D`上下文的``节点；

- `CSS3`动画的插件（如`Flash`）；

- 拥有加速

  ```
  css
  ```

  过滤器的元素；

  - `transform`：如`translateZ(0)`
  - `opacity`
  - `filter`
  - `will-change`：哪一个属性即将发生变化，进而进行优化。

### 3.重绘（Repaint）

重绘是一个元素外观的改变所触发的浏览器行为，比如`background-color`、`outline`等属性。这些属性不影响**布局**，只影响元素的**外观**，**风格**，会造成`DOM`元素的重新渲染，这个过程称为重绘。

需要注意的是：重绘是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个`gif`图，`gif`图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。

因此，可以通过特殊的方式来强制`gif`图单独为一个图层（`translateZ(0)`或者`translate3d(0,0,0)`；`CSS3`的动画也是一样（好在绝大部分情况浏览器自己会为`CSS3`动画的节点创建图层）；

**所以：**将**频繁重绘回流**的`DOM`元素作为一个**独立图层**，那么这个`DOM`元素的重绘和回流**只会**该图层；原则上是要尽量避免新建图层的，因为这会导致图层重组（`Composive Layers`）时候的计算量增大。所以，只有当某些`DOM`元素频繁重绘回流时，才新建一个独立图层放置它们；

**只会触发重绘的属性**

```scss
//部分属性
color
border-style
border-radius
visibility
text-decoration
background
background-image
background-position
background-repeat
background-size
outline-color
outline
outline-style
outline-width
box-shadow
```

### 4.回流（Reflow）

当`render tree`中的一部分（或全部）因为元素的**规模尺寸**，**布局**，**隐藏**等改变而需要重新构建。这就称为回流（`reflow`）；

- 当页面布局和几何属性改变时就需要回流；
- **回流必将引起重绘，而重绘不一定会引起回流；**

**触发页面重布局（回流）的属性**

| 盒子模型相关属性 | 定位及浮动属性 |  文字结构属性  |
| :--------------: | :------------: | :------------: |
|      width       |      top       |   text-align   |
|      height      |     bottom     |   overflow-y   |
|     padding      |      left      |  font-weight   |
|      margin      |     right      |    overflow    |
|     display      |    position    |  font-family   |
|   border-width   |     float      |  line-height   |
|      border      |     clear      | vertical-align |
|    min-height    |       *        |  white-space   |
|        *         |       *        |   font-size    |

频繁触发**重绘**和**回流**，会导致`UI`频繁渲染。在渲染的过程中由于阻塞了`js`线程的执行，最终导致`js`执行变慢。

### 5.触发回流的常见操作

- 增加、删除、修改 `DOM` 结点；
- 移动 `DOM` 的位置；
- 修改 `CSS` 样式；
- `Resize` 窗口；移动端没有这个问题，因为移动端的缩放没有影响布局视口（`vw/vh`）；
- 修改网页的默认字体；
- 获取某些`DOM`元素的属性(`width`，`height`等)；

> **注**：`display：none` 会触发 `Reflow`，而`visibility：hidden` 只会触发 `Repaint`，因为没有发生位置变化；

### 6.示例

**案例一：淘宝轮播图**

可以使用`Chrome`浏览器调试工具的`Performance`来观察淘宝首页一个轮播图引起的重绘回流过程：

![image-20200331161654830](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d79426552?w=1719&h=606&f=png&s=262207)

`Update Layer Tree`回流和重布局：

![image-20200331163602611](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d79df4b89?w=1071&h=479&f=png&s=43559)

`Paint`重绘：

![image-20200331163618288](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d79fa0cd6?w=1023&h=292&f=png&s=16380)

`Composite Layers`图层重组：

![image-20200331163626477](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d9a5ccc7a?w=1023&h=292&f=png&s=17347)

**案例二：播放器**

通过`Chrome`调试工具的`Layers`选项查看图层，及新增图层的原因：

![image-20200331162710936](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1dc1e3d2c5?w=1914&h=910&f=png&s=596808)

视频播放的过程中，`video`标签的`DOM`元素会一直重绘，所以把它限制在一个图层上是非常好的，这样只会涉及到这个图层的重绘，而不会影响其他图层的元素。

> **图层不能滥用，否则会在图层重组的过程中严重消耗性能！**

比如可以将淘宝首页的所有的`DOM`元素都变为一个图层：在`html`标签中的全局样式（`*`）中添加`transform:translateZ(0)`来触发新建图层：

> 还可以通过添加：`will-change: transform`属性新建图层；

![image-20200331165429542](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1d9a848eb2?w=1040&h=560&f=png&s=119236)

再次查看此时的图层情况，可以看到此时首页的图层非常之多，十分地卡：

![image-20200331165818801](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1dc4d7c72f?w=1043&h=848&f=png&s=163394)

### 7.实战优化点

如果我们需要使得动画或其他节点渲染的性能提高，需要做的就是减少浏览器在运行时所需要做的下列工作：

- 计算需要被加载到节点上的样式结果（`Recalculate style`--样式重计算）；
- 为每个节点生成图形和位置（`Layout`--回流和重布局）；
- 将每个节点填充到图层中（`Paint Setup`和`Paint`--重绘）；
- 组合图层到页面上（`Composite Layers`--图层重组）；

**1、使用`translate`替代`top`等属性来改变位置；**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #box{
  	 /*方法1*/
      position: relative;
      top: 0;
     
     /*方法2*/
     /* transform: translateY(0); */
        
      width: 200px;
      height: 200px;
      background-color: pink;
    }
  </style>
</head>
<body>
  <div id="box"></div>
  <script>
    setTimeout(() => {
      document.getElementById("box").style.top = '100px'
      //document.getElementById("box").style.transform = 'translateY(100px)'
    }, 2000);
  </script>
</body>
</html>
```

使用`top`属性改变正方形位置时，存在重绘和回流`Layout`：

![image-20200331173140790](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1dc800b143?w=1034&h=547&f=png&s=60690)

而使用`translate`属性改变正方形位置时，并不会引起重绘和回流：
![image-20200331173755614](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1dc8be01f4?w=1018&h=365&f=png&s=31571)

比如有的网站会有一些左右飘动的浮窗，由于这些浮窗是采用定时器来实现的，如果每经过`100ms`就改变浮窗的位置。这种时候使用`transform`来替代`top/left`的话`1s`内就减少了十次回流，十分有利于网页速度的提升。

**2、使用`opacity`替代`visibility`：**

- 使用`visibility`不触发重排，但是依然重绘；

- 直接使用`opacity`既触发重绘，又触发重排（`GPU`底层设计如此！）；

- `opacity`配合图层使用，既不触发重绘也不触发重排；

  原因：透明度的改变时，`GPU`在绘画时只是简单的降低之前已经画好的纹理的`alpha`值来达到效果，并不需要整体的重绘。不过这个前提是这个被修改`opacity`本身必须是一个单独的图层。

**3、将多次改变`DOM`元素样式属性的操作合并成一次操作：**

- 预先定义好`class`，然后通过修改`DOM`的`className`来添加样式；

**4、把`DOM`离线后再修改：**

- 由于`display`属性为`none`的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发`2`次回流；

**5、不要把获取某些`DOM`节点的属性值放在一个循环里当成循环的变量**

当向浏览器请求某些 `style`信息的时候，浏览器就会清空（`flush`）队列，比如：

- `ffsetTop`，`offsetLeft`，`offsetWidth`，`offsetHeight`；
- `scrollTop/Left/Width/Height`；
- `clientTop/Left/Width/Height`；
- `width`，`height`；

浏览器为了获取最精确的值，需要刷新内部队列。因为队列中可能存在影响到这些值的操作，即使没有，浏览器也会强行刷新渲染队列。这样就无法利用渲染队列的缓存来避免回流过于频繁了，所以在使用到`DOM`元素这些相关的属性时，可以将获取到的属性值存在一个变量中，而不是每次都去重新获取。

**6、不要使用`table`布局：**

- 因为很小的一个改动都会造成整个`table`的重新布局；所以尽量使用`div`布局；

**7、启用`GPU`硬件加速：**

原理为：浏览器会检测一些特定的`css`属性，当`DOM`元素拥有这些`css`属性的时候，浏览器就会对该`DOM`元素启动`GPU`硬件加速；比如：`transform: translateZ(0)`和`transform: translate3d(0, 0, 0)`这两个属性都可以启动硬件加速；硬件加速同样不能滥用，否则会导致图层过多，导致合并图层时消耗大量性能。

**8、动画实现速度的选择：**

- 因为动画的每次变化都会引起重绘和回流，所以要根据业务场景适当地在动画帧数（顺畅程度）和回流次数中进行平衡；

**9、为动画元素新建图层，提高动画元素的`z-index`；**

**10、利用文档碎片(`documentFragment`)------`vue`使用了该种方式提升性能**

如果我们要在一个`ul`中添加`10000`个`li`，如果不使用文档碎片，那么我们就需要使用`append`进行`10000`次的追加，这会导致页面不停地回流，非常地消耗资源：

```javascript
var oUl = document.createElement("ul"); 
for(var i=0;i<10000;i++)
{ 
    var oLi = document.createElement("li"); 
    oUl.appendChild(oLi); 
} 
document.body.appendChild(oUl); 
```

我们可以引入`createDocumentFragment()`方法，它的作用是创建一个**文档碎片**。先将要插入`10000`个`li`添加到文档碎片里，然后再一次性添加到`document`中。即文档碎片相当于一个**临时仓库**，这样能够大量减少`DOM`操作：

```javascript
//先创建文档碎片
var oFragment = document.createDocumentFragment(); 

//再创建ul标签
var oUl = document.createElement("ul"); 
for(var i=0;i<10000;i++)
{ 
  //创建li标签
  var oLi = document.createElement("li"); 
  //先附加在文档碎片中
  oFragment.appendChild(oLi);  
}
//将文档碎片添加到ul标签中 
oUl.appendChild(oFragment);
//将ul标签添加到body标签中
document.body.appendChild(oUl); 
```

**11、**如果涉及到一些可以使用合成线程来处理 `CSS` 特效或者动画的情况，就尽量使用 `will-change` 来提前告诉渲染引擎，让它为该元素准备独立的层。

**12、采用虚拟`DOM`；**

**13、使用`requestAnimationFrame`制作动画：**详细内容如下。

### 8.请求动画帧（`requestAnimationFrame`）

**`window.requestAnimationFrame()` ：**该方法会告诉浏览器在重绘之前调用指定的函数：

- **参数：**该方法以一个回调函数作为参数，这个回调函数会在浏览器重绘之前被调用；

  回调函数会被自动传入一个参数：`DOMHighResTimeStamp`，标识`requestAnimationFrame()`开始触发回调函数的当前时间；

- **返回值：** 一个非零的整数，也称为请求`ID`，是回调列表中唯一的标识，没有其他意义；

**`window.cancelAnimationFrame(requestID)`：**该方法取消一个先前通过调用`window.requestAnimationFrame()`方法添加到计划中的动画帧请求。`requestID`是先前调用`window.requestAnimationFrame()`方法时返回的`ID`。

**用途**

- 当无法使用`CSS3`制作动画的情况下，使用这种方法替代定时器制作动画；
- 由于重绘就调用的机制，制作的动画频率与浏览器的刷新频率一致，不会出现闪动，保证了动画的流畅；

**示例**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #box{
      height: 200px;
      width: 200px;
      background-color: pink;
    }
  </style>
</head>
<body>
  <div id="box"></div>
  <script>
    let i = 0
    //获取请求ID
    let id = requestAnimationFrame(move)

    function move(){
      i++
      document.getElementById('box').style.transform = `translateX(${i}px)`
      //递归调用requestAnimationFrame,更新请求ID,实现动画效果
      id = requestAnimationFrame(move)
    }

    setTimeout(() => {
      //2s后停止动画
      cancelAnimationFrame(id)
    }, 2000);
  </script>
</body>
</html>
```

## 六、函数防抖与节流

### 1.函数防抖

- **概念：**不断触发一个函数，在规定时间内只让最后一次生效，前面都不生效；
- **实现：**定时器；
- **应用：**搜索时等用户完整输入内容后再发送查询请求；

**代码实现**

```javascript
function debounce(fn,delay){
           var timer = null
        //  清除上一次延时器
          return function(){
               clearTimeout(timer)
              //  重新设置一个新的延时器
              timer = setTimeout(() => {
                  fn.call(this)
              }, delay);
          }
       }
```

使用函数防抖可以减少事件触发的次数和频率，在某些情况下可以起到优化的作用。比如：搜索框，对于核心业务非搜索的网站，一般都是等待用户完整输入内容后才发送查询请求，一次来减少服务器的压力。像百度这样的核心业务为搜索的网站，服务器性能足够强大，所以不进行函数防抖处理；

### 2.函数节流

- **概念：**不断触发一个函数后，执行第一次，只有大于设定的执行周期后才会执行第二次，以此控制函数执行频率；
- **实现：**定时器，标识；
- **应用：**在游戏中，可以设定人物攻击动作的最快频率，无论手速多快也无法超越这一频率；

**代码实现**

```javascript
/* 
	节流函数：fn:要被节流的函数，delay：规定的时间
 */
function throttle(fn, delay){
    // 记录上一次函数出发的时间
    var lastTime = 0
    return function(){
        // 记录当前函数触发的时间
        var nowTime = new Date().getTime()
        // 当当前时间减去上一次执行时间大于这个指定间隔时间才让他触发这个函数
        if(nowTime - lastTime > delay){
            // 绑定this指向
            fn.call(this)
            //同步时间
            lastTime = nowTime
        }
    }
}
```

## 七、浏览器存储

### 1.`Cookie`

- `Cookie`翻译过来是小甜饼的意思，是网景公司的前雇员 `Lou Montulli` 在`1993`年`3`月发明的；
- `Cookie`是纯文本格式，不包含任何可执行的代码信息，伴随着用户请求在 `Web` 服务器和浏览器之间传递；
- `Cookie`本质上属于`http`的范畴，因为`http`协议本身是无状态的，服务端是没有办法区分请求来自于哪个客户端，即便是来自于同一个客户端的多次请求，服务端也无法进行区分。所以引入了`Cookie`去维持客户端的状态（比如每个账号的购物车状态都不一样）。

**`Cookie`的生成方式**

- **客户端生成：**

  在 `JavaScript` 中通过 `document.cookie` 属性，你可以创建、维护和删除 `Cookie`；设置 `document.cookie` 属性的值并不会删除存储在页面中的所有 `Cookie`，它只简单的创建或修改字符串中指定的 `Cookie`。

- **服务端生成：**

  `Web` 服务器通过在`HTTP`响应头中添加 `Set-Cookie`字段来创建一个 `Cookie`，可以在该字段中添加`HttpOnly`属性禁止`JavaScript`脚本访问`Cookie`，以此来避免跨域脚本 (`XSS`) 攻击。

**`Cookie`的缺陷**

- **安全性：**由于`Cookie`在`HTTP`中是明文传递的，其中包含的数据都可以被他人访问，出现篡改、盗用等问题；

- **大小限制：**`Cookie`的大小限制在`4KB`左右，若要做大量存储显然不是理想的选择；

- 增加流量：

  因为

  ```
  Cookie
  ```

  是绑定域名对应的服务器的，所以对同一个域名的每次请求都会在

  ```
  Request Header
  ```

  中带上

  ```
  Cookie
  ```

  。

  - 一方面：增加对服务器的请求时间；
  - 另一方面：导致大部分不需要用到`Cookie`信息的场合下流量的浪费；这样浏览器对同一域名的每一次请求都会多出`4KB`流量，对于大型网站来说这是很大的损耗。

因此要慎用`Cookie`，不要在`Cookie`中存储重要和敏感的数据。

**`Cookie`性能优化的方法**

将存放静态资源的`CDN`服务器域名与主站的域名独立开来。这样每次请求静态文件的时候就不需要携带`Cookie`，从而可以节省很多流量。

**举例**

比如在百度进行登录的时候，请求头里面就会有`Set-Cookie`字段，其中的`BDUSS`就是标识用户登录状态的字符串：

![image-20200331213122597](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1dd7a991b4?w=1287&h=627&f=png&s=943775)

`Set-Cookie`中的`httponly`属性表示的是禁止`js`脚本访问`cookie`，这样能够一定程度防范`XSS`攻击；

在`Chrome`调试工具的`Application`选项中查看`Cookies`信息，可以发现该`Cookie`已经被网站“种”到`Domain：.baidu.com`这个域名下了，并且该`Cookie`也设置了`HttpOnly`属性：

![image-20200331213850374](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1dd45b89fc?w=1470&h=488&f=png&s=99670)

此后浏览器的每次请求都会在请求头`Request Headers`中携带这一`Cookie`信息。刷新页面后可以看到，请求头中携带了`Cookie`信息`BDUSS`：

![image-20200331214126035](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1df8daa1cb?w=1358&h=521&f=png&s=97231)

这样服务器就知道这是已经登录的用户了。

但是不是所有的请求都需要携带`Cookie`信息，比如优酷：

![image-20200331214741967](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e0351834f?w=1514&h=608&f=png&s=441491)

可以看到请求`index.css`文件时也携带了`Cookie`，但是这是不必要的，这就会导致流量的浪费。

> 解决方法就是上面所说的：将**`CDN`域名**和**主域名**独立出来；

百度就是这样解决的：

![image-20200331215055075](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e0afda1b2?w=1450&h=463&f=png&s=414284)

可以看到请求这个静态资源的`url`并不是`.baidu.com`，而是静态资源服务器`CDN`；并且该请求的请求头中不会携带`Cookie`信息：

![image-20200331215256387](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e0cc68add?w=1014&h=455&f=png&s=70115)

**设置和获取`Cookie`**

设置`Cookie`的方式很简单，`key`和`value`值通过等号连接：

```ini
document.cookie = "userName=zhangsan"
```

![image-20200331232648641](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e0d7bccff?w=1015&h=319&f=png&s=38634)

打开`Application`选项查看当前`Cookie`，可以看到`Cookie`已被改变：

![image-20200331232745709](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e2ada2ed3?w=948&h=417&f=png&s=36048)

获取`Cookie`：

```javascript
document.cookie
```

![image-20200331233517456](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e4b4f992d?w=414&h=95&f=png&s=5760)

> **备注：**
>
> - 静态资源是不会携带`Cookie`的；
> - `Cookie`一般都是后台种的，很少让前端来直接写；
> - `Cookie`分:持久级别、`session`级别；
> - `Cookie`一般用于存放`session ID`与服务器端进行通信；

### 2.`Web Storage`

- `Web Storage`分为`SessionStorage`和`LocalStorage`专门用于客户端浏览器的本地存储，同时空间比`Cookie`大很多，一般支持`5-10M`；
- 浏览器端通过 `Window.sessionStorage` 和 `Window.localStorage` 属性来实现本地存储机制；

#### `LocalStorage`

`LocalStorage`是`HTML5`设计出来专门用于存储浏览器信息的：

- 大小为`5~10M`左右；
- 仅在客户端中使用，不和服务端进行通信；
- 接口封装较好，提供了`js`进行读写等操作的`API`；
- 采用浏览器本地缓存方案，可直接使用浏览器本地缓存，提升网页渲染的速度；

**举例**

比如通过`Chrome`调试工具的`Application`选项可以查看淘宝中`LocalStorage`存储的数据：

![image-20200331220258429](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e4b5e9a07?w=1431&h=780&f=png&s=196807)

这些数据只要不手动清除，即使关闭页面也都会存在。当需要使用图片、`js/css`文件等资源时就不用重新向服务器发出请求，而是可以直接使用`LocalStorage`中的缓存，这就是`LocalStorage`缓存的优势；

而`Cookie`就不一样了，里面存储的数据都是要带到服务器端的，例如用户登录状态，统计信息等数据：
![image-20200331220548331](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e4dcc9411?w=1404&h=486&f=png&s=96400)

**设置和获取`LocalStorage`**

`LocalStorage`提供了相对简单的`API`，采用的也是`key`和`value`的形式。

设置时通过：

```javascript
localStorage.setItem("key", "value")
```

![image-20200331233022902](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e4fbe1d9d?w=1030&h=415&f=png&s=47524)

查看`LocalStorage`，同样设置成功了：

![image-20200331233059670](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e5019e348?w=1024&h=280&f=png&s=24593)

获取时通过：

```javascript
localStorage.getItem("key")
```

![image-20200331233226621](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e6a12d983?w=310&h=123&f=png&s=7038)

**其他方法**

```javascript
//该方法接受一个键名作为参数，并把该键名从存储中删除。
localStorage.removeItem('key');
	
//调用该方法会清空存储中的所有键名
localStorage.clear();
```

#### `SessionStorage`

`SessionStorage`用于存储浏览器的会话信息，标签页关闭之后它存储的数据就会被清空，而`LocalStorage`的数据不会被清空，这是二者的区别：

- 大小为`5~10M`左右；
- 仅在客户端使用，不和服务端进行通信；
- 接口封装较好；
- 可对表单信息进行维护；比如添加表单过程中进行了刷新，可以将刷新前填写的信息写入`SessionStorage`中，这样即使刷新后数据也不会丢失；还有一种场景：分页的表单在进行前进或后退时，如果将信息保存在`SessionStorage`中就不会丢失；

**设置和获取`SessionStorage`**

设置`SessionStorage`的方法与设置`LocalStorage`的方法类似：

```cpp
//设置
sessionStorage.setItem("key", "value")

//获取
sessionStorage.getItem("key")
```

![image-20200331233922185](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e86ce252c?w=366&h=163&f=png&s=11588)

通过`Application`选项查看`SessionStorage`，可见已成功修改：

![image-20200331234022971](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e86e299cd?w=833&h=304&f=png&s=25127)

**其他方法**

```scss
//该方法接受一个键名作为参数，并把该键名从存储中删除。
sessionStorage.removeItem('key');
	
//调用该方法会清空存储中的所有键名
sessionStorage.clear();
```

### 3.`IndexedDB`

`IndexedDB`是浏览器提供的一种`API`，用于存储客户端中大量的结构化数据。该`API`使用索引来实现对数据的高性能搜索。虽然`WebStorage`对于存储较少量的数据时很有用（采用`key/value`的方式），但对于存储更大量的结构化数据来说，还是`IndexedDB`表现更加优异。

**`IndexedDB`的应用**

- 为应用创建离线版本；

可以在浏览器中打印`indexedDB`对象：

![image-20200331234812475](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e8c215975?w=416&h=223&f=png&s=20852)

### 4.`PWA`

`PWA`（`Progressive Web Apps`）是一种`Web App`新模型（标准），并不是具体指某一种前沿的技术或者某一个单一的知识点。从英文缩写就能看出，这是一个渐进式的`Web App`，是通过一系列新的`Web`特性，配合优秀的`UI`交互设计，逐步增强用户的体验；

**`PWA`的要求**

- **可靠：**在没有网络的环境中也能提供基本的页面访问，而不会出现"未连接到互联网"的情况；
- **快速：**针对网页渲染及网络数据访问有较好优化；
- **融入（`Engaging`）：**应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性；

### 5.`Service Worker`

`Service Worker`是一个脚本，可以使浏览器独立于当前网页，在后台运行。为实现一些不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性将包括推送信息，背景后台同步，`geofencing`（地理围栏定位）等它将推出的第一个首要特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。

即`Service Worker`可以帮助浏览器执行大规模的运算而不阻碍主线程的执行。

**`Service Worker`的应用**

- 使用拦截和处理网络请求的能力，实现一个离线应用；
- 使用`Service Worker`在后台运行的同时能和页面通信的能力，去实现大规模后台数据的处理；

**`Service Worker`应用过程**

![image-20200331235052759](http://ahuntsun.gitee.io/blogimagebed/img/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/52.png)

**示例**

通过`Chrome`调试工具的`Application`选项可以查看淘宝的`Service Workers`信息：

![image-20200331230014013](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1e91223f16?w=1152&h=492&f=png&s=57374)

当我们刷新淘宝网页的时候，查看`Network`选项，可以从请求文件的`size`栏发现大量的文件都是从`Service Worker`缓存中请求回来的：

![image-20200331230221993](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1ecc5b3222?w=1174&h=775&f=png&s=144370)

这样的话就可以利用`Service Worker`的缓存进行网站的性能优化。

以下列淘宝请求同一`js`文件为例，从`Service Worker`中加载使用了`7ms`：

![image-20200331230805709](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1ebf50d50b?w=1256&h=276&f=png&s=38115)

使用`Ctrl + F5`强制刷新后，向服务器请求同一文件花了`100ms`：

![image-20200331230936902](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1ec3db4b8f?w=1249&h=284&f=png&s=37341)

这就是使用`Service Worker`性能上带来的优势。由于是从本地缓存中读取的资源，所以资源读取的速度和整体的性能都会有一个明显的提升。

## 八、HTTP通用缓存策略

### 1.缓存的简介

- **缓存定义：**

  浏览器在本地磁盘上将用户之前请求的数据存储起来，当访问者再次需要改数据的时候无需再次发送请求，直接从浏览器本地获取数据

- **缓存的好处：**

  - 减少请求的个数；
  - 节省带宽，避免浪费不必要的网络资源；
  - 减轻服务器压力；
  - 提高浏览器网页的加载速度，提高用户体验；

### 2.缓存相关的header字段

可以通过`Chrome`浏览器调试工具中的`Network`选项查看浏览器请求资源的情况：

![image-20200401134006392](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1ec8443d8a?w=1041&h=822&f=png&s=135275)

注意不要勾选图中方框内的选项，否则有些请求会被过滤；

#### `Cache-Control`字段

服务器可通过`httpheader`中的`Cache-Control`字段控制客户端与服务器端之间的缓存策略，它的属性值有：

##### `max-age`

该字段指定了缓存的最大有效时间，以下为淘宝的一张图片：

![image-20200401110102964](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1ed9595788?w=1025&h=564&f=png&s=92479)

在`max-age`属性指定的时间未到期前，客户端不会向服务器发起请求，而是从缓存中直接读取该图片。上图中可以看到浏览器直接从`ServiceWorker`的缓存中读取了该图片资源。

`Expires`字段同样可以指定缓存的有效期，不过这是`HTTP1.0`中的字段，优先级比`HTTP1.1`中的`Cache-Control`字段的`max-age`属性低；

##### `s-maxage`

缓存设备总体来说有两种：浏览器（客户端）和`CDN`服务器；

- 其中浏览器属于`private`类型缓存设备，表示只有浏览器才可以对资源进行缓存；
- `CDN`服务器属于`public`类型缓存设备，这种设备可以对源服务器上的资源进行缓存。并且，这种缓存对于任何用户来说都是可以访问的；

`s-maxage`的优先级在`Expires`和`max-age`三者之中是最高的，用于指定`public`类型缓存设备（比如`CDN`）上资源的有效期。如下图所示，该资源设定了该字段后，**浏览器既不会使用浏览器缓存，也不会向服务器请求资源**，而是向`public`类型的缓存设备（如`CDN`服务器）请求资源：

![image-20200401131748600](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1ee0c69aa2?w=1006&h=603&f=png&s=96639)

##### `private`

服务器端可以通过该属性指定某一资源只能被浏览器（客户端）缓存，而不能被代理缓存服务器（`CDN`）缓存。

##### `public`

服务器端可以通过该属性指定某一资源，既可以被浏览器缓存，也可以被代理缓存服务器缓存；

##### `no-cache`

`no-cache`属性规定了浏览器要先向服务器端发送请求确认缓存资源的新鲜度，才能决定是否使用缓存；如下图所示：

![image-20200401112236538](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1ef8767fc0?w=1020&h=592&f=png&s=103040)

##### `no-store`

该属性指定了浏览器无论缓存资源是否过期直接跳过缓存，重新向服务器请求资源。`no-store`属性用的比较少。

#### `Expires`字段

这是`http1.0`的规范；它的值为一个**绝对时间**的`GMT`(格林威治标准时间)格式时间字符串，如`Mon, 10 Jun 2015 21:31:12 GMT`；

该字段指定了浏览器缓存资源的过期时间，在指定的时间到期前，浏览器可以直接从本地缓存中读取数据，而无需再次向服务器发起请求，属于**强缓存**；相比于`max-age`与`s-maxage`优先级最低，在这两个属性存在的情况下`Expires`字段会失效；

![image-20200401113310983](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1eff4999ba?w=1019&h=558&f=png&s=87915)

#### 标识资源变化的字段

##### `Last-Modified/If-Modified-Since`

二者是基于客户端和服务端协商的缓存机制，标识资源最后更新时间的字段。`last-modified`字段位于`response header`中，`If-Modified-Since`字段位于`request header`中，二者配合着`Cache-Control`字段使用。

当服务器上的资源发生改变时会同步更新`last-modified`的字段值，当`Expires`字段或`max-age`属性指定的时间到期后，客户端会在请求头中携带`If-Modified-Since`字段，与服务器端资源的`last-modified`字段值进行比较：

- **情况一：**如果二者相等说明资源自`last-modified`字段指定的时间以后都没有发生变化，此时服务器返回状态码`304`，属于**协商缓存**；
- **情况二：**如果二者不相等说明资源发生了更新，服务器返回最新的资源和最新的`last-modified`字段值，此时的状态码为`200`；

**举例**

下图表示状态码为`304`的响应：

![213](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f03cbbc0d?w=794&h=140&f=png&s=14958)

- 请求头中`If-Modified-Since`字段的值为`Mon, 23 Mar 2020 18:14:15 GMT`：

![image-20200401135630227](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f0bdda9ac?w=807&h=394&f=png&s=36244)

- 响应头中`Last-Modified`字段的值为`Mon, 23 Mar 2020 18:14:15 GMT`：

![img](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f1fc4d88a?w=796&h=500&f=png&s=47991)

二者相等，说明资源没有发生变化，所以服务器返回状态码`304`，属于**协商缓存**，浏览器继续使用本地缓存；

> **`If-Modified-Since`字段的值就是服务器端上一次响应资源中的`Last-Modified`字段值**；

**`Last-Modified`的缺点**

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新`GET`；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说`1s`内修改了`N`次)，`If-Modified-Since`能检查到的粒度是`s`级的，这种修改无法判断（比如淘宝每`ms`都会更新数据）；
- 某些服务器端不能获取精确的修改时间；

所以有了

##### `Etag/If-None-Match`

`Etag`字段是`HTTP1.1`中的标准，是一个唯一标识服务器端资源的`hash`值，该字段存在于响应头（`reponse header`）中；与请求头（`request header`）中的`If-None-Match`字段及`Cache-Control`字段配合使用。

只要服务器端的资源发生变化`Etag`值就会改变，相比于`Last-Modified`字段优先级更高且更有效；当`Expires`值或者`Cache-Control`字段中的`max-age`值到期时，客户端会在请求头中携带`If-None-Match`字段，该字段值为服务器端上一次响应资源中的`Etag`值，并与服务器端上最新资源的`Etag`值进行比较：

- **情况一：**如果两个字段值相等，说明资源未发生改变，服务器端拒绝响应，返回状态码`304`，属于**协商缓存**；
- **情况二：**如果两个字段值不相等说明服务器端上的资源发生了改变，服务器在响应中返回最新的资源和`Etag`值，此时状态码为`200`；

**举例**

下图表示状态码为`304`的响应：

![img](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f21ca80c7?w=808&h=110&f=png&s=10472)

- 请求头中`If-None-Match`字段值为`2da25d4039...`：

![image-20200401140441351](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f3411f781?w=805&h=385&f=png&s=37724)

- 响应头中`Etag`字段值为`2da25d4039...`：

![img](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f4352c470?w=808&h=448&f=png&s=43615)

二者相等，说明资源没有发生变化，所以服务器返回状态码`304`，属于**协商缓存**，浏览器继续使用本地缓存；

> **总结：**
>
> - 利用`Etag`能够更加准确的控制缓存，因为`Etag`是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符；
> - `Last-Modified`与`ETag`是可以一起使用的，由于`Etag`的优先度更高，所以服务器会优先比较`Etag`和`If-None-Match`。一致的情况下，才会继续比对`Last-Modified`和`If-Modified-Since`，最后才决定是否返回状态码`304`。

### 3.缓存策略

#### 缓存分类

- **强缓存：**
  - 不会向服务器发送请求，直接从本地缓存中获取数；
  - 请求资源的的状态码为: `200 ok(from memory cache)`；
- **协商缓存：**
  - 向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存；
  - 如果命中，则返回状态码`304`通知浏览器从缓存中读取资源；

#### 强缓存与协商缓存的区别

|   缓存   | 获取资源形式 |        状态码         |            发送请求到服务器            |
| :------: | :----------: | :-------------------: | :------------------------------------: |
|  强缓存  | 从缓存中获取 |  `200（from cache）`  |          否，直接从缓存中获取          |
| 协商缓存 | 从缓存中获取 | `304（not modified）` | 是，根据服务器返回信息判断缓存是否可用 |

#### 分级缓存策略

![image-20200401120433734](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f43d6a56a?w=656&h=550&f=png&s=24324)

**最下层的`200`状态**

- 这一层由`Expires/Cache-Control`字段控制：

  - `1.Expires`（`HTTP1.0`版本有效）是绝对时间；
  - `2.Cache-Control`（`HTTP1.1`版本有效）是相对时间；

  当两者都存在时，`Cache-Control`会覆盖`Expires`，只要这些字段没有失效，浏览器都会直接使用本地缓存，属于**强缓存**；

- 缓存的来源大概有两种`memory cache`和`disk cache`：

![image-20200401143316753](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f61fa3350?w=793&h=340&f=png&s=64747)

可以看到，从`memory cache`中读取缓存不需要时间，从`disk cache`中读取缓存则需要一定时间。

> 相对时间与绝对时间与服务器的设置有关，当服务器设置`Atime`（最后访问时间）时，二者相等；当服务器设置`Mtime`（绝对修改时间）时，`Expires`从资源的创建开始计算过期时间，`Max-age`从请求发起的时间开始计算过期时间；

下图便是淘宝中采用强缓存的例子，状态码为`200`，图片资源都是从浏览器缓存`memory cache`中读取，所以请求时间为`0ms`：

![image-20200401132234425](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f65ceb00b?w=1044&h=599&f=png&s=128106)

**中间的`304`状态**

- 这一层由`last-modified/Etag`控制。当下一层失效时或用户点击`refresh/F5`时，浏览器就会向服务器发起请求，如果服务器上的相关资源没有更新，则返回状态码`304`，属于**协商缓存**；

下图便为协商缓存的情况，状态码为`304`。也可以这样理解：只要状态码是`304`都属于协商缓存：

![image-20200401133725298](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f668c6f26?w=1017&h=566&f=png&s=94850)

**最上层的`200`状态**

- 当浏览器本身没有缓存或者下一层失效时，或者用户点击了`Ctrl + F5`强制刷新时，浏览器会直接向服务器请求最新的资源；

如下图所示：

![image-20200401132845422](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f6cc77ffc?w=1037&h=511&f=png&s=90454)

#### 用户行为对缓存的影响

|      用户操作       | `Expires/Cache-Control` | `Last-Modified/Etag` |
| :-----------------: | :---------------------: | :------------------: |
|     地址栏回车      |          有效           |         有效         |
|    页面链接跳转     |          有效           |         有效         |
|      新开窗口       |          有效           |         有效         |
|      前进后退       |          有效           |         有效         |
|      `F5`刷新       |          无效           |         有效         |
| `Ctrl + F5`强制刷新 |          无效           |         无效         |

#### 缓存策略过程分析

如图所示，该流程图表示服务器端在处理资源时采用缓存策略的过程：

![image-20200401141526275](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f78e5f167?w=893&h=810&f=png&s=230408)

- 首先服务器判断资源是否可以复用，不可复用则在`Cache-Control`字段中添加`no-store`属性；
- 可以复用的情况下，判断资源是否要求强一致？若是，则在`Cache-Control`字段中添加`no-cache`属性，这样不管缓存资源是否过期，都要求客户端或缓存代理服务器首先向服务器确认资源的新鲜度，属于**协商缓存**；
- 随后服务器指定是否允许`Web`代理缓存资源（比如`CDN`服务器缓存），如果允许则在`Cache-Control`字段中添加`public`属性，并指定代理缓存服务器上资源的有效期`s-maxage`；不允许则添加`private`属性，表示只能由客户端浏览器缓存资源，并设定缓存的有效期`max-age`；
- 随后，根据情况在客户端浏览器中，选择强缓存或者协商缓存；

## 九、服务端性能优化

### 1.`CDN`服务器

#### 定义

网站通常将其所有的服务器都放在同一个地方，当用户群增加时，公司就必须在多个地理位置不同的服务器上部署内容。为了缩短`http`请求的时间，我们应该把大量的静态资源放置的离用户近一点。

内容发布网络`CDN`（`Content Delivery Networks`）就是其中一种方式。`CDN`是一组分布在多个不同地理位置或网段的`web`服务器，用于更加有效的向用户发布内容。

![image-20200402125920245](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f8094e65b?w=889&h=656&f=png&s=456184)

#### 基本思路

- 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定；
- 通过在网络各处放置节点服务器，在现有的互联网基础之上构成一层智能虚拟网络；
- `CDN`系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息
  将用户的请求重新导向离用户最近的服务节点上。

#### 基础架构

最简单的`CDN`网络由一个`DNS`服务器和几台缓存服务器组成：

![image-20200402133217921](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f9a4fdcfe?w=921&h=572&f=png&s=65712)

- 1、当用户点击网站页面上内容的`URL`时，经过本地`DNS`系统解析，`DNS`系统最终会将域名的解析权交给`CNAME`指向的`CDN`专用的`DNS`服务器；

> 关于`DNS`解析，不一定由`DNS`服务器响应，一般从缓存中读取。比如电脑缓存、浏览器缓存、路由器缓存、运行商缓存等。如果缓存中没有找到，才一级一级地查询：本地`DNS`-> 权限`DNS` -> 顶级`DNS` -> 根`DNS`。全球只有`13`台根`DNS`服务器。

- 2、`CDN`的`DNS`服务器将`CDN`的全局负载均衡设备的`IP`地址返回给用户；

- 3、用户向`CDN`的全局负载均衡设备发起内容`URL`访问请求；

- 4、`CDN`全局负载均衡设备根据用户的`IP`地址，以及用户请求的内容`URL`，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求；

- 5、区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：

  - 根据用户`IP`地址，判断哪一台服务器距用户最近；
  - 根据用户所请求的`URL`中携带的内容名称，判断哪一台服务器上有用户所需内容；
  - 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力；

  基于以上这些条件的综合分析之后，`CDN`区域负载均衡设备会向`CDN`全局负载均衡设备返回一台`CDN`缓存服务器的`IP`地址。

- 6、`CDN`全局负载均衡设备把服务器的`IP`地址返回给用户；

- 7、用户向`CDN`缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端；如果这台`CDN`缓存服务器上并没有用户想要的内容，但是区域均衡设备依然将它分配给了用户，那么这台`CDN`服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地；

#### 应用场景

- **网站站点/应用加速：**

  站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器`ECS`，静态资源如各类型图片、`html`、`css`、`js`文件等，使用`CDN`服务器存储，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。

- **移动应用加速：**

  移动`APP`更新文件（`apk`文件）分发，移动`APP`内图片、页面、短视频、`UGC`等内容的优化加速分发。提供`httpDNS`服务，避免`DNS`劫持并获得实时精确的`DNS`解析结果，有效缩短用户访问时间，提升用户体验。

- **视音频点播/大文件下载分发加速；**

- **视频直播加速；**

#### 总结

简单点说`CDN`服务器相当于顺丰快递分布于全国各地的仓库，主仓库将快递运送到这些分仓库，用户可以就近取货，由此加快了速度。

除此之外`CDN`服务器还有许多高级功能，比如防止`DDOS`攻击等，这里就不展开了；

### 2.`SSR(Server Side Rendering)`

依赖现代框架如`Vue`和`React`构建的网站，往往会存在一定的问题，比如`Vue`框架。

**`Vue`渲染面临的问题**

首屏渲染时，要先下载和解析`app.js`（打包过后的`Vue.js`）之后，才能开始渲染页面。

**优化方案**

- 构建层模板编译：将模板编译的任务放在了构建层中完成，而不是浏览器；
- 数据无关的`Prerender`的方式；
- **服务端渲染**：即将浏览器端进行的运算的一部分转移到服务器端上；

通常采用服务端渲染（`SSR`）的方式进行优化。所谓`SSR`就是利用服务器端优秀的计算能力，将一部分的页面渲染任务交由服务器端进行处理。以下为服务端渲染`SSR`的流程图：

![image-20200401165151509](https://user-gold-cdn.xitu.io/2020/4/2/1713ac1f9e91df08?w=1089&h=434&f=png&s=141242)

服务端渲染可以很好地优化首屏渲染的问题；可以根据业务需求，适当地分配客户端和服务器端的渲染部分，综合利用客户端和服务器端的计算能力，从而达到性能优化的目的。

> 参考资料：

- [CDN是什么？使用CDN有什么优势？](https://www.zhihu.com/question/36514327?rf=37353035)；
- [Web前端性能优化](https://coding.imooc.com/class/130.html)；

## 一、HTTP简介

### 1.HTTP

**HTTP:**超文本传输协议，是一种**通信协议**；允许超文本标记文档从`Web`服务器传送到客户端的浏览器中。

简单：传输`html`文件的协议。

**Web：**是一种基于超文本和`HTML`的、全球性的、动态交互的、跨平台的分布式**图形信息系统**。

`http`是**无状态协议**，这保证了它的高效。`Cookie`和`Section`的出现使`http`在保持高效的情况下，能够记住状态；

### 2.URI与URL

![image-20200318091045352](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/0.png)

- `URI`可分为`URL`，`URN`或同时具备`locators` 和` names`特性的东西；
- `URN`的作用就好像一个人的名字，`URL`就像这个人的地址；
- 换句话说：`URN`确定了东西的身份，`URL`提供了找到它的方式；

**URL是URI的一种，不是所有的URI都是URL；URI唯一地标识了身份，URL给出了访问机制（http/ftp/telnet等）**

## 二、状态码

![image-20200318115514752](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/1.png)

#### 1xx：接收的请求正在处理

#### 2xx：请求正常处理完毕

| 状态码 | 状态码英文名称  |                             描述                             |
| :----: | :-------------: | :----------------------------------------------------------: |
|  200   |       OK        |     请求已成功，请求所希望的响应头或数据体将随此响应返回     |
|  202   |    Accepted     |              已接受，已经接受请求，但未处理完成              |
|  204   |   No Content    |    请求处理成功，但是返回的响应报文中不包含实体的主体部分    |
|  206   | Partial Content | 该状态码表示客户端进行了范围请求， 而服务器成功执行了这部分的 `GET` 请求。 响应报文中包含由 `Content-Range` 指定范围的实体内容。 |

#### 3xx：重定向

| 状态码 |  状态码英文名称   |                             描述                             |
| ------ | :---------------: | :----------------------------------------------------------: |
| 301    | Moved Permanently | 永久重定向，请求的资源已被永久的移动到新的`URI`，返回信息会包括新的`URI`，浏览器会自动定向到新的`URI`。今后任何新的请求都会使用新的`URI`（比如某的网站域名已更改，访问旧网址会自动跳转到网址） |
| 302    |       Found       | 暂时重定向，与`301`类似。但资源只是临时被移动，客户端应继续使用原有的URI |
| 303    |     See Other     | 该状态码表示由于请求对应的资源存在着另一个` URI`， 应使用 `GET` 方法定向获取请求的资源。与`302`区别在于`303`希望用户使用`GET`访问新的`URI`，而`302`可以使用`POST`访问新的`URI` |
| 304    |   Not Modified    | 该状态码表示客户端发送附带条件时（`If-Match`， `If-ModifiedSince`等）， 服务器端允许请求访 问资源， 但未满足附带的条件。 此时返回，`304` 状态码， 不包含任何响应 的主体部分。另一种理解：**所请求的资源没有更改，可以使用缓存** |

#### 4xx：客户端错误

| 状态码 | 状态码英文名称 |                             描述                             |
| :----: | :------------: | :----------------------------------------------------------: |
|  400   |  Bad Request   |            客户端请求报文语法错误，服务器无法理解            |
|  401   |  Unauthorized  | 表示发送的请求需要有通过`HTTP`认证（`BASIC` 认证、 `DIGEST `认证） 的认证信息 |
|  403   |   Forbidden    |          服务器理解客户端的请求，但是拒绝执行此请求          |
|  404   |   Not Found    |          服务器无法根据客户端的请求找到资源（网页）          |

#### 5xx：服务器错误

| 状态码 |    状态码英文名称     |                             描述                             |
| :----: | :-------------------: | :----------------------------------------------------------: |
|  500   | Internal Server Error | 服务器端内错误或` Web` 应用存在`bug`或某些临时的故障，导致无法完成请求 |
|  502   |      Bad Gateway      |  充当网关或代理的服务器，从远端服务器接收到了一个无效的请求  |
|  503   |  Service Unavailable  | 表明服务器暂时处于超负载或正在进行停机维护， 现在无法 处理请求 |

## 三、HTTP首部

### 1.HTTP请求和响应报文

#### 1.1HTTP请求报文

![image-20200317202609927](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2.png)

![image-20200318103054848](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/3.png)

#### 1.2.HTTP响应报文

![image-20200317202637972](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/4.png)

![image-20200318103225790](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5.png)

可见HTTP报文一共有**四种**首部字段（请求头）：**请求首部字段、响应首部字段、通用首部字段、实体首部字段；**

#### 1.3.示例

在`chrome`的开发者调试工具当中，从请求报文和响应报文分各抽出了一部分，形成了三部分：

**General：**

![image-20200318105143441](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/6.png)

**Request Headers：**

![image-20200318105327277](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/7.png)

**Response Headers：**

![image-20200318105410254](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/8.png)

### 2.请求首部字段

![image-20200317203914289](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/9.png)

#### 2.1.Accept

作用：**浏览器端可以接受的媒体类型；**

![image-20200318095255629](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/10.png)

若想要给显示的媒体类型增加优先级， 则使用 `q`来额外表示权重值，用分号`（;）`进行分隔。权重值` q` 的范围是` 0~1`（可精确到小数点后` 3` 位） ，且`1`为最大值。不指定权重` q` 值时，默认权重为 `q=1.0`。

当服务器提供多种内容时，将会首先返回权重值**最高**的媒体类型。

#### 2.2.Accept-Charset

作用：用来通知服务器用户代理（浏览器）支持的字符集及字符集的相对优先顺序。

![image-20200318095604225](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/11.png)

图Accept-Charset字段中的值：

```vbnet
Accept-Charset： iso-8859-5, unicode-1-1;q=0.8
```

中的`unicode-1-1;q=0.8`是一个整体，表示unicode编码优先级为0.8，小于默认的iso编码优先级（默认q=1）；**不要以为分号（；）为分割符，其实逗号（，）才是分割符**

#### 2.3.Accept-Encoding

作用：用来告知服务器用户代理支持的内容编码及内容编码的**优先级顺序**。 可一次性指定**多种**内容编码。

![image-20200318095930260](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/12.png)

```makefile
Accept-Encoding: gzip, deflate
```

常见的编码方式有：**gzip**、**compress**、**deflate**、**identity**。

#### 2.4.Accept-Language

作用：用来告知服务器浏览器能够接收的语言 ，以及相对优先级。

![image-20200318100341589](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/13.png)

```avrasm
Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3
```

上述值表示：优先请求中文版，其次是英文版；

#### 2.5.Host

![image-20200317210815624](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/14.png)

```makefile
Host: www.hackr.jp
```

若服务器未设定主机名，`Host`为空值即可。

#### 2.6.If-Match

![image-20200317211022050](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/15.png)

形如`If--xxx`这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。

![image-20200317211036278](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/16.png)

上图表示：只有当`If-Match`的字段值跟`Etag`值匹配一致时，服务器才会接收请求。

#### 2.7.If-Modified-Since

![image-20200317211327966](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/17.png)

上图表示：如果在`If-Modified-Since`字段指定的日期时间后，资源发生了更新，服务器会接收请求，此时返回状态码`200`；否则会拒绝接收请求返回`304`（因为资源都没更新过，不需要重新请求），与响应头`Last-Modified`是一对；

#### 2.8.If-None-Match

只有在 `If-None-Match` 的字段值与 `ETag `值不一致时， 可处理该请求。 与 `If-Match` 首部字段的作用相反；

![image-20200317211800953](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/18.png)

#### 2.9.If-Range

首部字段 `If-Range` 属于附带条件之一。 它告知服务器若指定的 `If-Range` 字段值（`ETag` 值或者时间） 和请求资源的 `ETag` 值或时间相一致时， 则作为范围请求处理。 反之， 则返回全体资源。

![image-20200317212055861](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/19.png)

下面我们思考一下不使用首部字段` If-Range` 发送请求的情况。 服务器端的资源如果更新， 那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 `412:Precondition Failed `作为响应返回， 其目的是催促客户端再次发送请求。这样一来，与使用首部字段 `If-Range `比起来，就需要花费两倍的功夫。

![image-20200317212159337](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/20.png)

#### 2.10.Referrer

作用：告诉服务器我是从哪个页面的链接过来的，服务器籍此可以获得一些信息用于处理；

![image-20200318101839032](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/21.png)

```bash
Referer: http://www.hackr.jp/index.htm
```

#### 2.11.User-Agent

作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本；

![image-20200318102046185](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/22.png)

```css
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/2010010
```

很多时候我们会通过该字段来判断浏览器类型，从而进行不同的兼容性设计。

### 3.响应首部字段

![image-20200317203931940](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/23.png)

![image-20200317212421283](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/24.png)

#### 3.1.Age

首部字段 `Age` 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。

![image-20200317212504499](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/25.png)

#### 3.2.ETag

首部字段` ETag` 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 `ETag`值。
另外， 当资源更新时，`ETag` 值也需要更新。生成 `ETag` 值时，并没有统一的算法规则，而仅仅是由服务器来分配。

![image-20200317212602438](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/26.png)

与响应头`If-None-Match`是一对；

#### 3.3.Location

使用首部字段` Location` 可以将响应接收方引导至某个与请求 `URI` 位置不同的资源。 基本上，该字段会配合 `3xx ： Redirection` 的响应， 提供重定向的`URI`。

### 4.通用首部字段

![image-20200317203943920](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/27.png)

#### 4.1.Cache-Control

**a.请求首部中Cache-Control的指令：**

![image-20200317204206171](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/28.png)

**b.响应首部中Cache-Control的指令：**

![image-20200317204635351](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/29.png)

**Cache-Control各指令详解：**

- **public指令：**客户端和代理服务器（`CDN`）可以缓存；
- **Private指令：**只有客户端可以缓存；

![image-20200317204824663](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/30.png)

- **no-store指令：**真正意义上的所有内容都不缓存；
- **no-cache指令：**正确来说该指令还是会使用缓存，只不过使用前要确认其新鲜程度（**协商缓存**）；

![image-20200317204854401](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/31.png)

- **s-maxage = x指令 **:代理服务器请求源站缓存后的X秒内不再发出请求，只对`CDN`缓存（`CDN`指的是拥有源服务器资源的多个分布式服务器）有效；

```cpp
Cache-Control: s-maxage=604800 //（单位 ： 秒）
```

此外，当使用 `s-maxage` 指令后，则直接忽略对 `Expires` 首部字段及`max-age` 指令的处理。 即优先级为：**`S-maxage` > `Max-age` > `Expires`**

- **Max-age = x指令：**请求缓存后的X秒内不再发起请求。

```cpp
Cache-Control: max-age=604800 //（单位： 秒）
```

![image-20200317204940262](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/32.png)

当**客户端**发送的请求中包含`max-age`指令时： 如果判定指定的时间比缓存资源的缓存时间数值**更大**，那么客户端就接收缓存的资源。另外，当指定 `max-age` 值为 `0`（指定时间**更小**），那么缓存服务器通常需要将请求转发给源服务器。

当**服务器**返回的响应中包含 `max-age` 指令时，缓存服务器将不对资源的有效性再作确认，而直接把 `max-age` 数值作为保存为缓存的资源的最长时效。

应用 `HTTP/1.1` 版本的缓存服务器遇到同时存在 `Expires` 首部字段的情况时，会优先处理 `max-age` 指令，而**忽略**掉 `Expires` 首部字段。

#### 4.2.Connection

有两个作用：

- **控制不再转发给代理的首部字段：**

![image-20200317210000299](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/33.png)

如图中，`Connection`的值为`Upgrade`表示不将`Upgrade`这个首部发给代理；

- **管理持久连接：**

a.当`Connection ： close` 时：

![image-20200317210148420](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/34.png)

代表一个`Request`完成后，客户端和服务器之间用于传输`HTTP`数据的`TCP`连接会关闭（四次挥手）。当客户端再次发送`Request`，需要重新建立`TCP`连接（三次握手）。

b.当`Connection：Keep-Alive` 时：

![image-20200317210232981](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/35.png)

此时，当一个网页打开完成后（已经建立TCP连接），客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器，会继续使用这条已经建立的连接；

#### 4.3.Via

使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径：

![image-20200317210436541](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/36.png)

### 5.实体首部字段

![image-20200317203957114](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/37.png)

实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。

![image-20200317213108376](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/38.png)

#### 5.1.Content-Type

作用：说明报文内对象的媒体类型；

```vhdl
Content-Type: text/html; charset=UTF-8
```

#### 5.2.Expires

![image-20200317213143041](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/39.png)

首部字段 `Expires` 会将资源失效的日期告知客户端。**缓存服务器**（代理服务器）在接收到含有首部字段 `Expires `的响应后，会以缓存来应答请求，在`Expires` 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。

源服务器不希望缓存服务器对资源缓存时， 最好在 `Expires` 字段内写入与首部字段 `Date` 相同的时间值。

但是，当首部字段` Cache-Control` 有指定 `max-age` 指令时，比起首部字段 `Expires`，会优先处理 `max-age `指令。

#### 5.3.Last-Modified

![image-20200317213437706](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/40.png)

首部字段 `Last-Modified` 指明资源最终修改的时间。 与请求头`If-Modified-Since`是一对；

```yaml
Last-Modeified: Wed, 23 May 2012 09:59:55 GMT
```

### 6.为 Cookie 服务的首部字段

`Cookie`的工作机制是用户识别及状态管理。`Web` 网站为了管理用户的状态会通过 `Web` 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该`Web`网站时，可通过通信方式取回之前发放的`Cookie`;

调用 `Cookie` 时，由于可校验 `Cookie` 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 `Cookie` 内的数据不会因来自其他`Web` 站点和攻击者的攻击而泄露。

**为 Cookie 服务的首部字段：**

![image-20200317213803615](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/41.png)

#### 6.1.Set-Cookie字段

当服务器准备开始管理客户端的状态时，会事先告知各种信息。

```lua
Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path
```

**`Set-Cookie` 字段的属性 **

![image-20200317213949707](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/42.png)

- **expires 属性：**

`Cookie` 的 `expires` 属性指定浏览器可发送 `Cookie` 的有效期。当省略 `expires` 属性时，其有效期仅限于维持浏览器会话`（Session）`时间段内。 这通常限于浏览器应用程序被关闭之前。

另外，一旦 `Cookie` 从服务器端发送至客户端，服务器端就不存在可以显式删除 `Cookie` 的方法。但可通过覆盖已过期的 `Cookie`，实现对客户端 `Cookie` 的实质性删除操作。

- **domain 属性：**

通过 `Cookie` 的` domain` 属性指定的域名可做到与结尾匹配一致。 比如，当指定 `example.com` 后，除 `example.com` 以外， `www.example.com`或 `www2.example.com `等都可以发送 `Cookie`。

因此， 除了针对具体指定的多个域名发送 `Cookie `之 外，不指定`domain` 属性显得更安全。

- **secure 属性：**

`Cookie` 的` secure` 属性用于限制 `Web` 页面仅在 `HTTPS` 安全连接时，才可以发送 `Cookie`。

发送 `Cookie `时，指定`secure`属性的方法如下所示：

```delphi
Set-Cookie: name=value; secure
```

以上例子仅当在`https://www.example.com/（HTTPS）`安全连接的情况下才会进行` Cookie` 的回收。也就是说， 即使域名相同，`http://www.example.com/（HTTP） `也不会发生 `Cookie` 回收行为。

当省略 `secure` 属性时，不论 `HTTP `还是 `HTTPS`，都会对 `Cookie` 进行回收。

- **HttpOnly 属性：**

`Cookie` 的 `HttpOnly `属性是 `Cookie` 的扩展功能，它使 `JavaScript `脚本无法获得 `Cookie`。 其主要目的为防止跨站脚本攻击`（Cross-sitescripting， XSS）` 对` Cookie` 的信息窃取。

发送指定 `HttpOnly` 属性的` Cookie` 的方法如下所示。

```delphi
Set-Cookie: name=value; HttpOnly
```

通过上述设置，通常从`Web`页面内还可以对 `Cookie `进行读取操作。但使用 `JavaScript` 的 `document.cookie` 就无法读取附加` HttpOnly` 属性后的`Cookie`的内容了。 因此，也就无法在 `XSS` 中利用 JavaScript 劫`Cookie` 了。

#### 6.2.Cookie字段

首部字段 `Cookie` 会告知服务器，当客户端想获得 `HTTP `状态管理支持时， 就会在请求中包含从服务器接收到的 `Cookie`。 接收到多个`Cookie` 时，同样可以以多个 `Cookie `形式发送。

```bash
Cookie: status=enable
```

## 四、HTTP请求方法

**HTTP/1.1 的常用方法 ：**

![image-20200318104329280](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/43.png)

### 1.GET

`GET `方法用来请求访问已被` URI` 识别的资源。指定的资源经服务器端解析后返回响应内容。

举例：

![image-20200318104711164](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/44.png)

![image-20200318105633396](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/45.png)

**GET方法也可以用来提交表单和其他数据：**

```bash
http://localhost/login.php?username=aa&password=1234
```

从上面的请求`URL`中，很容易就能辨认出表单提交的内容。`HTTP0.9`的时候只有`GET`方法，所以`GET`方法既能获取数据，也能提交数据，只不过提交的数据是拼接在`URL`后的不能提交太多且不安全；提交大量数据时使用`POST`方法。

### 2.POST

- `POST`方法功能与`GET`方法类似，是`GET`方法的延伸，主要用于向服务器提交数据量较大的**用户表单**数据；
- 提交的数据放在请求报文的主体中，保证了提交数据的安全；这样就克服了`GET`方法提交的数据量太小和不能保密的缺点。
- `POST`方法的主要目的并不是获取响应主体的内容；

![image-20200318110800869](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/46.png)

### 3.PUT

- `PUT`方法用来传输文件。 就像` FTP` 协议的文件上传一样， 要求在请求报文的主体中包含文件内容， 然后保存到请求`URI`指定的位置。
- `PUT`方法和`POST`很相似，最大的不同是：`PUT`是幂等的，`POST`是不幂等的。 即创建文件使用`POST`更新文件使用`PUT`；

> 幂等：幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同；

- 但是， 鉴于·`HTTP/1.1` 的 `PUT `方法自身不带验证机制， 任何人都可以上传文件 , 存在安全性问题， 因此一般的 `Web `网站**不使用该方法**。

### 4.HEAD

`HEAD` 方法只获取响应报文首部，不返回报文主体部分。 用于确认`URI` （超链接）的有效性及资源更新的日期时间等。 例如：

![image-20200318112642135](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/47.png)

### 5.DELETE

- `DELETE` 方法用来删除文件，是与 `PUT` 相反的方法。`DELETE` 方法按请求 `URI` 删除指定的资源。
- 但是，`HTTP/1.1 `的 `DELETE` 方法本身和 `PUT `方法一样不带验证机制，所以一般的 `Web `网站也不使用 `DELETE` 方法。(怎么可能让人随便`rm -rf`) 举例：

![image-20200318113012177](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/48.png)

### 6.OPTIONS

`OPTIONS `方法用来查询针对请求` URI` 指定的资源支持的方法。

![image-20200318113110813](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/49.png)

示例：

![image-20200318113127546](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/49.5.png)

### 7.TRACE

- 客户端通过 `TRACE` 方法可以查询发送出去的请求是怎样被加工修改/ 篡改的。 这是因为， 请求想要连接到源目标服务器可能会通过代理中转， `TRACE` 方法就是用来确认连接过程中发生的一系列操作。
- 但是，` TRACE` 方法本来就不怎么常用， 再加上它容易引发`XST`（`Cross-Site Tracing`， 跨站追踪） 攻击， 通常就更不会用到了。
- 发送请求时， 在 `Max-Forwards` 首部字段中填入数值， 每经过一个服务器端就将该数字减 `1`， 当数值刚好减到 `0 `时， 就停止继续传输， 最后接收到请求的服务器端则返回状态码`200 OK`的响应。

![image-20200318114809722](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/50.png)

示例：

```yaml
//请求
TRACE / HTTP/1.1
Host: hackr.jp
Max-Forwards: 2

响应：
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 1024

TRACE / HTTP/1.1
Host: hackr.jp
Max-Forwards: 2（返回响应包含请求内容）
```

### 8.CONNECT

`CONNECT `方法要求在与代理服务器通信时建立隧道， 实现用隧道协议进行` TCP` 通信。 主要使用 `SSL`（`Secure Sockets Layer`， 安全套接层） 和` TLS`（`Transport Layer Security`， 传输层安全） 协议把通信内容加 密后经网络隧道传输。

```http
//格式
CONNECT 代理服务器名:端口号 HTTP版本

//例子
//请求
CONNECT proxy.hackr.jp:8080 HTTP/1.1
Host: proxy.hackr.jp

//响应
HTTP/1.1 200 OK（之后进入网络隧道）
```

## 五、HTTP状态管理

Cookie和Session，实现了HTTP的状态管理，Cookie是在客户端的，Session是在服务器的。

### 1.Cookie

`HTTP` 是**无状态协议**（高效率，不记仇），它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。

假设要求登录认证的` Web` 页面本身无法进行状态的管理（不记录已登录的状态） ，那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。

![image-20200318090108406](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/51.png)

保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了`Cookie`技术。`Cookie `技术通过在请求和响应报文中写入`Cookie`信息来控制客户端的状态。

- `Cookie`实际上是一小段文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个`Cookie`；
- 客户端浏览器会把`Cookie`保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该`Cookie`一同提交给服务器。服务器检查该`Cookie`，以此来辨认用户状态。

在一个网站地址栏输入：

```css
javascript:alert(document.cookie)
```

可以弹出该网站的`Cookie`信息：

![image-20200318125635655](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/52.png)

`Cookie` 会根据从服务器端发送的响应报文内的一个叫做 `Set-Cookie` 的首部字段信息， 通知客户端保存`Cookie`。当下次客户端再往该服务器发送请求时， 客户端会自动在请求报文中加入 `Cookie` 值后发送出去。

服务器端发现客户端发送过来的`Cookie`后， 会去检查究竟是从哪一个客户端发来的连接请求， 然后对比服务器上的记录， 最后得到之前的状态信息。

#### 第一次：没有 Cookie 信息状态下的请求

![image-20200318090429111](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/53.png)

- **请求报文（没有 Cookie 信息的状态）**

![image-20200318090524295](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/54.png)

- **响应报文（服务器端生成 Cookie 信息） **

![image-20200318090543542](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/55.png)

#### 第二次：存有 Cookie 信息状态的请求

![image-20200318090456328](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/56.png)

- **请求报文（自动发送保存着的 Cookie 信息） **

![image-20200318090609670](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/57.png)

### 2.Session

- `Session`是另一种记录客户状态的机制，保存在**服务器**上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上；
- 客户端浏览器再次访问时只需要从该`Session`中查找该客户的状态就可以了；

![image-20200318140020730](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/58.png)

`Cookie`和`Session`非常相似，`Cookie`相当于客户端持有的**通行证**，Session相当于服务器上的**通行名册**。

**保存Session ID的方式**

- `Cookie`
- `URL`重写
- 隐藏表单

**Session的有效期**

- `Session`超时失效：被动失效，如果超过规定时间没有再次访问服务器，`Session`将失效；
- 程序调用`HttpSession.invalidate()`：主动失效；
- 服务器进程被停止；

### 3.**Token**

**Token的引入**

`Token`是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，`Token`便应运而生。

**Token的定义**

`Token`是服务端生成的一串字符串，以作客户端进行请求的一个**令牌**，当第一次登录后，服务器生成一个`Token`便将此`Token`返回给客户端，以后客户端只需带上这个`Token`前来请求数据即可，**无需再次带上用户名和密码**。最简单的`token`组成`:uid`(用户唯一的身份标识)、`time`(当前时间的时间戳)、`sign`(签名，由`token`的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接`token`请求服务器)。

**使用Token的目的**

`Token`的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

**Session管理及Cookie应用**

![image-20200318154807240](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/59.png)

- **步骤 1**：客户端把用户 `ID` 和密码等登录信息放入报文的实体部分，通常是以 `POST `方法把请求发送给服务器。而这时，会使用 `HTTPS`通信来进行` HTML`表单画面的显示和用户输入数据的发送。

- **步骤 2**：服务器会发放用以识别用户的 `Session ID`。通过验证从客户端发送过来的登录信息进行身份认证， 然后把用户的认证状态与`Session ID `绑定后记录在服务器端。

  向客户端返回响应时，会在首部字段`Set-Cookie `内写入 `SessionID`（如 `PHPSESSID=028a8c…`） 。

  为防止`Session ID` 被第三方盗走，服务器端需要对其进行有效性管理；并且为减轻跨站脚本攻击`（XSS）` 造成的损失，建议事先在 `Cookie`内加上 `httponly` 属性。

- **步骤 3**： 客户端接收到从服务器端发来的 `Session ID `后，会将其作为`Cookie` 保存在本地。下次向服务器发送请求时，浏览器会自动发送`Cookie`，所以 `Session ID` 也随之发送到服务器。服务器端可通过验证接收到的 `Session ID` 识别用户和其认证状态。

### 4.Cookie与Session的区别

- **存放位置不同**：`Cookie`存放在客户端，`Session`保存在服务器端；
- **安全性（隐私策略）不同**：`Cookie`存储在浏览器中，对客户端是可见的，客户端的一些程序可能会窥探或修改`Cookie`的内容；而`Session`存储在服务器端，对客户端来说是透明的；如果想要使用`Cookie`需要对其进行加密；
- **有效期上的不同**：设置`Cookie`很大的过期时间，`Cookie`就能被浏览器保存很长时间；而服务器会定期清理超时的`Session ID`避免出现过大压力；但是`Session`依赖于类似`Session ID`这样的`Cookie`，而`Cookie`对`Session ID`过期时间默许为`-1`。所以只要关闭了浏览器，即一次会话结束后，该`Session`就失效了；
- **对服务器造成的压力不同**：`Session`是保存在服务器端的，每个用户都产生一个`Session`，假如并发访问的用户十分多，会产生十分多的`Sssion`，耗费大量的内存；而`Cookie`保存在客户端，不太占用服务器的资源；

## 六、HTTP协议的身份认证

- `BASIC`认证（基本认证）
- `DIGEST`（摘要认证）
- `SSL`客户端认证
- `FormBase`认证（基于表单认证）

### 1.BASIC认证

**BASIC 认证的认证步骤** ：

- **步骤 1**：当请求的资源需要`BASIC`认证时，服务器会随状态码 `401 Authorization Required`，返回带 `WWW-Authenticate` 首部字段的响应。该字段内包含认证的方式`（BASIC）`及`Request-URI`安全域字符`（realm）`。

- **步骤 2**： 接收到状态码` 401` 的客户端为了通过 `BASIC` 认证， 需要将用户` ID` 及密码发送给服务器。 发送的字符串内容是由用户 `ID` 和密码构成， 两者中间以冒号`（:） `连接后，再经过` Base64` 编码处理。

  假设用户` ID` 为 `guest`，密码是` guest`，连接起来就会形成 `guest:guest` 这样的字符串。 然后经过 `Base64` 编码，最后的结果即是`Z3Vlc3Q6Z3Vlc3Q=`。 把这串字符串写入首部字段 `Authorization` 后，
  发送请求。

- **步骤 3**： 接收到包含首部字段`Authorization`请求的服务器，会对认证信息的正确性进行验证。 如验证通过， 则返回一条包含 `Request-URI`资源的响应。

![image-20200318145152607](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/60.png)

`BASIC` 认证虽然采用`Base64`编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户 `ID`和密码，在` HTTP` 等非加密通信的线路上进行 `BASIC` 认证的过程中，如果被人窃听，被盗的可能性极高。 因此并不常用。

### 2.DIGEST 认证

为弥补·`BASIC`认证存在的弱点， 从 `HTTP/1.1` 起就有了 `DIGEST` 认证。` DIGEST` 认证同样使用质询 / 响应的方式
`（challenge/response）`，但不会像 `BASIC` 认证那样直接发送明文密码。

所谓质询响应方式是指， 一开始一方会先发送认证要求给另一方， 接着使用从另一方那接收到的**质询码**计算生成**响应码**。 最后将响应码返回给对方进行认证的方式。

![image-20200318150407496](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/61.png)

因为发送给对方的只是响应摘要及由质询码产生的计算结果，所以比起 `BASIC` 认证，密码泄露的可能性就降低了。

**DIGEST 认证的认证步骤: **

- **步骤 1**：请求需认证的资源时，服务器会随着状态码 `401:Authorization Required`，返 回带 `WWW-Authenticate `首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，`nonce`） 。
  首部字段` WWW-Authenticate` 内必须包含 `realm` 和 `nonce` 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。

  `nonce `是一种每次随返回的 `401` 响应生成的任意随机字符串。该字符串通常推荐由 `Base64 `编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。

- **步骤 2**： 接收到 `401 `状态码的客户端，返回的响应中包含 `DIGEST `认证必须的首部字段` Authorization` 信息。

  首部字段` Authorization` 内必须包含` username`、 `realm`、` nonce`、 `uri` 和r`esponse `的字段信息。其中，`realm `和 `nonce `就是之前从服务器接收到的响应中的字段。

- **步骤 3**： 接收到包含首部字段 `Authorization` 请求的服务器，会确认认证信息的正确性。 认证通过后则返回包含 `Request-URI `资源的响应。并且这时会在首部字段`Authentication-Info`写入一些认证成功的相关信息。

![image-20200318151408496](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/62.png)

`DIGEST `认证提供了高于`BASIC`认证的安全等级，但是和 `HTTPS `的客户端认证相比仍旧很弱。 `DIGEST `认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制 。因此使用范围不大。

### 3.SSL 客户端认证

从使用用户`ID`和密码的认证方式方面来讲，只要二者的内容正确即可认证是本人的行为。但如果用户 `ID `和密码被盗，就很有可能第三者冒充。利用` SSL`客户端认证则可以避免该情况的发生。

`SSL`客户端认证是借由 `HTTPS` 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。

**SSL 客户端认证的认证步骤 :**

为达到` SSL`客户端认证的目的 需要事先将客户端证书分发给客户端，且客户端必须安装此证书。

- **步骤 1**：接收到需要认证资源的请求，服务器会发送 `Certificate Request` 报文，要求客户端提供客户端证书。
- **步骤 2**：用户选择将发送的客户端证书后，客户端会把客户端证书信息以 `Client Certificate `报文方式发送给服务器。

![image-20200318153348145](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/63.png)

**SSL 客户端认证采用双因素认证 :**

- 在多数情况下，`SSL`客户端认证不会仅依靠证书完成认证，一般会和**基于表单认证**组合形成一种双因素认证`（Two-factorauthentication） `来使用。
- 换言之，第一个认证因素的` SSL`客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。
- 使用 `SSL`客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。

### 4.基于表单认证

- 基于表单的认证方法并不是在`HTTP`协议中定义的；
- 使用由`Web`应用程序各自实现基于表单的认证方式；
- 通过`Cookie`和`Session`的方式来保持用户的状态（具体见上）；

也就是常见的登录：

![image-20200318154207699](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/64.png)

输入已事先登录的用户` ID`（通常是任意字符串或邮件地址） 和密码等登录信息后，发送给`Web`应用程序，基于认证结果来决定认证是否成功。

## 七、HTTP的长连接与短连接

`HTTP`协议是基于请求/响应模式的，因此只要服务端给了响应，本次`HTTP`请求就结束了；`HTTP`的长连接和短连接本质上是`TCP`的**长连接**和**短连接**；

### 1.短连接

完成一次通信之后，客户端主动断开TCP连接；

`HTTP/1.0`中，默认使用的是**短连接**。也就是说，浏览器和服务器每进行一次`HTTP`操作，就建立一次连接（三次握手），结束就中断（四次挥手）；

### 2.长连接

完成一次通信之后，客户端不主动断开	`TCP`连接，而是复用该`TCP`连接；

`HTTP/1.1`起，默认使用**长连接**，用以保持连接特性。此时通用首部字段中的`Connection`字段值为：`Keep-Alive`；

长连接适用于频繁地传输数据的客户端和服务器，为了防止过多的TCP连接影响服务器性能，需要对长时间不用的连接进行释放；

## 八、代理、网关与隧道

`HTTP `通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。

这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。

### 1.代理

**代理服务器：**

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“**中间人**”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

![image-20200318162610556](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/65.png)

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求` URI`，会直接发送给前方持有资源的目标服务器。

持有资源实体的服务器被称为源服务器，从源服务器返回的响应经过代理服务器后再传给客户端。

![image-20200318162711944](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/66.png)

> 每次通过代理服务器转发请求或响应时，会追加写入 `Via` 首部信息。

**使用代理服务器的理由：**

利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制（墙），以获取访问日志为主要目的，等等。

![image-20200318163146824](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/67.png)

**代理使用方法：**

代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。

- **缓存代理 **

代理转发响应时，缓存代理（`Caching Proxy`）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

- **透明代理 **

转发请求或响应时，不对报文做任何加工的代理类型被称为**透明代理**（`Transparent Proxy`）。反之，对报文内容进行加工的代理被称为**非透明代理**。

### 2.网关

网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个**网关**。

![image-20200318163648918](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/68.png)

网关的工作机制和代理十分相似。但是`Web`网关在一侧使用`HTTP`协议，在另一侧使用另一种协议（比如`FTP`、`SMTP`）。

- （`HTTP/`）服务器端网关：通过`HTTP`协议与客户端对话，通过其他协议与服务器通信；
- （`/HTTP`）客户端网关：通过其他协议与客户端对话，通过`HTTP`协议与服务器通信；

**常见的网关类型：**

- （`HTTP/`*）服务器端`Web`网关；

- （`HTTP/HTTPS`）服务器端安全网关：即客户端用`HTTP`与网关通信，网关用`HTTPS`与服务器通信；

- （`HTTPs/HTTP`）客户端安全加速器网关：即客户端用`HTTPs`与网关通信，网关用`HTTP`与服务器通信；

  也就是**安全网关**，将通过网关的不安全的`HTTP`转换为安全的`HTTPS`;

- 资源网关：客户端通过HTTP连接到应用程序的服务器，服务器并不回送文件，而是将请求通过网关API发送给运行在服务器上的应用程序，应用程序将请求资源会送给客户端。这样的客户端可能是一些网络摄像头，电子识别系统等；

利用网关能提高通信的**安全性**，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用`SQL`语句查询数据。另外，在` Web` 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。

### 3.隧道

隧道可按要求建立起一条与其他服务器的通信线路，届时使用` SSL`等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

隧道本身不会去解析` HTTP` 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。

![image-20200318165852154](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/69.png)

> 通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在。

## 九、HTTP缓存

缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。

缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。

![image-20200318170530364](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/70.png)

![image-20200318170549956](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/71.png)

缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源， 而源服务器也不必多次处理相同的请求了。

### 1.缓存的有效期限

即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。
当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了。

即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效， 缓存服务器将会再次从源服务器上获取“新”资源。

![image-20200318170746847](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/72.png)

### 2.客户端的缓存

缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以`Internet Explorer` 程序为例，把客户端缓存称为临时网络文件（`Temporary Internet File`）；

浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取；

![image-20200318170932065](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/73.png)

另外，和缓存服务器相同的一点是， 当判定缓存过期后， 会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。

## 十、HTTP缓存的工作方式（强制缓存与协商缓存）

### 1.场景一

让服务器与浏览器约定一个文件过期时间——`Expires`

![image-20200318180301511](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/74.png)

在`Expires`没有过期的情况下，客户端（浏览器）发出请求时，直接使用`HTTP`本地缓存并返回状态码`200`，这种`HTTP`工作方式称为**强制缓存**；

### 2.场景二

让服务器与浏览器在约定文件过期时间`Expires`的基础上，再加一个文件最新修改时间的对比——`Last-Modified`与`if-Modified-Since`

![image-20200318180227578](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/75.png)

- **情况1**：如果`Expires`没有过期，浏览器直接使用`HTTP`本地缓存，即采用**强制缓存**；

- 情况2

  ：如果

  ```
  Expires
  ```

  过期了，那么浏览器在请求服务器的时候，就带上了文件最新修改时间，这个字段是在请求头里面加上了

  ```
  If-Modified-Since
  ```

  字段，其实该字段的值就是上次请求时服务器返回的

  ```
  Last-Modified
  ```

  字段的值；服务器会把请求头里文件的最新修改时间

  ```
  If-Modified-Since
  ```

  的值与服务器上的文件最新修改时间

  ```
  Last-Modified
  ```

  的值进行比较：

  - 如果`If-Modified-Since` **不等于**`Last-Modified`，说明浏览器缓存的资源（`f.js`）发生改变，服务器就会去查找最新的`f.js`，同时再次返回`Expires`、`f.js`、`Last-Modified`，返回的状态码为`200`;
  - 如果`If-Modified-Since` **等于**`Last-Modified`，说明浏览器缓存的资源（`f.js`）没有发生改变，浏览器可以继续使用`HTTP`本地缓存，此时服务器返回状态码`304`；这种方式称为**协商缓存**

### 3.场景三

让服务器在过期时间`Expires`+`Last-Modified`的基础上，增加一个文件唯一标识`Etag`与`If-None-Match`配成一对使用；除此之外，`Expires`不稳定，再加入一个`Max-age`来加以替代（`Max-age`优先级更高）；

![image-20200318185030563](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/76.png)

- 在60s内，浏览器不再向服务器发起请求，直接使用本地缓存这与`Expires`相似。

- 60s后：浏览器带上

  ```
  If-Modified-Since
  ```

  和

  ```
  If-None-Match
  ```

  （也就是上次服务器返回的

  ```
  Etag
  ```

  值）发起请求，服务器会对比

  ```
  If-None-Match
  ```

  与服务器端的

  ```
  Etag
  ```

  值，这时即使浏览器也提供了

  ```
  If-Modified-Since
  ```

  也不会再与

  ```
  Last-Modified
  ```

  进行对比，因为

  ```
  Etag
  ```

  的优先级比

  ```
  Last-Modified
  ```

  高（更精准）；

  - 如果`If-None-Match`**不等于**`Etag`，说明`f.js`文件已被修改，服务器就会返回最新的`f.js`和全新的`Etag`与`Max-age`（比如`60`），当然也会顺便把`Expires`与`Last-Modified`返回（尽管没用）；返回的状态码为`200`；
  - 如果`If-None-Match`**等于**`Etag`，说明`f.js`文件没有被修改，这时服务器返回的状态码为`304`，告诉浏览器继续使用原来的本地缓存。这种方式属于**协商缓存**；

**有了`Last-Modified`为什么还要用`Etag`呢？**

你可能会觉得使用`Last-Modified`已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要`Etag`呢？`HTTP1.1`中`Etag`的出现主要是为了解决几个`Last-Modified`比较难解决的问题：

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新`GET`；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说`1s`内修改了`N`次)，`If-Modified-Since`能检查到的粒度是`s`级的，这种修改无法判断（比如淘宝每`ms`都会更新数据）；
- 某些服务器不能精确的得到文件的最后修改时间；

这时，利用`Etag`能够更加准确的控制缓存，因为`Etag`是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。 `Last-Modified`与`ETag`是可以一起使用的，服务器会优先验证`ETag`，一致的情况下，才会继续比对`Last-Modified`，最后才决定是否返回`304`。

### 4.强制缓存与协商缓存

**强制缓存：**直接使用`HTTP`本地缓存，此时服务器返回状态码`200`；

**协商缓存：**向服务器确认`HTTP`本地缓存的资源是否发生变化，没变化后再使用`HTTP`本地缓存，此时服务器返回状态码`304`；资源发生变化直接返回最新资源，状态码为`200`；可以这样理解凡是返回`304`状态码，都属于**协商缓存**；

**强缓存和协商缓存的区别：**

|   缓存   | 获取资源形式 |       状态码        |           发送请求到服务器           |
| :------: | :----------: | :-----------------: | :----------------------------------: |
|  强缓存  |  从缓存读取  |  200（From Cache）  |          否，直接从缓存读取          |
| 协商缓存 |  从缓存读取  | 304（Not Modified） | 是，通过服务器告知浏览器缓存是否可用 |

请求头`Cache-Control`的值为**no - cache**时表示浏览器会先向服务器确认缓存的新鲜度，再决定是否使用缓存，属于**协商缓存**。

### 5.缓存改进方案

上述的缓存方案存在一个问题：当`Expires`或`Max-age`没有过期时，浏览器无法**主动**确认本地缓存是否发生变化；

#### 5.1.md5/hash缓存

通过不缓存`html`，为静态文件添加`MD5`或者`hash`标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题；具体过程为：第一次加载静态文件时，某位置指定加载`f-hash1.js`，第二次加载静态文件时同一个位置指定加载`f-hash2.js`，此时浏览器就会重新向服务器请求数据了；

#### 5.2.CDN缓存（最常用）

`CDN`是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率；

比如可以把`CDN`理解为各个城市的快递分发站点，源服务器看作快递总仓库；

**CDN缓存工作方式**：

- **第一次缓存：**

![image-20200318194542397](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/77.png)

- **后续请求：**

![image-20200318194515210](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/78.png)

`CDN`节点会代替服务器处理浏览器的请求，会有几种情况：

- 情况一：`CDN`节点缓存的文件还没过期，于是返回`304`给浏览器，浏览器此次请求被拦截（**协商缓存**）；
- 情况二：`CDN`节点发现自己缓存的文件过期了，为了保险起见自己发送请求给服务器成功拿回了最新的数据，然后再交还给浏览器；

可以发现，`CDN`缓存问题与`HTTP`缓存是一样的。只不过`CDN`缓存不过期浏览器始终被拦截，无法拿到最新的文件；另外的不同点在于`CDN`相当于一个平台可以手动登录更新缓存，这也就变相解决了不能控制`HTTP`本地缓存的问题。

### 6.浏览器操作对HTTP缓存的影响

|   用户操作    | Expires/Cache-Control | Last-Modified/Etag |
| :-----------: | :-------------------: | :----------------: |
|  地址栏回车   |         有效          |        有效        |
| 页面链接跳转  |         有效          |        有效        |
|   新开窗口    |         有效          |        有效        |
|  前进、后退   |         有效          |        有效        |
|    F5刷新     |       **无效**        |        有效        |
| Ctrl + F5刷新 |       **无效**        |      **无效**      |

由上表可知：对于`Last-Modified`和`Etag`字段来说，只有在进行`Ctrl + F5`强制刷新时，这两个字段对缓存是否有效的控制才会失效。即强制刷新后，浏览器不会使用本地缓存，而是直接向服务器发起请求。

## 十一、内容协商机制

指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为**合适**的资源。内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准。

有三种方式：

- **客户端驱动**

由客户端发起请求，服务器发送可选项列表，客户端作出选择后在发送第二次请求；

- **服务器驱动**

服务器检查客户端的请求头部集并决定提供哪个版本的页面；

- **透明协商**

某个中间设备（通常是缓存代理）代表客户端进行协商；

### 1.服务器驱动

服务器驱动内容协商：**请求首部集**；

- **Accept**：告知服务器发送何种媒体类型；
- **Accept-Language**：告知服务器发送何种语言；
- **Accept-Charset**：告知服务器发送何种字符集；
- **Accept-Encoding**：告知服务器采用何种编码；

服务器驱动内容协商：**实体首部集**；

- **Content-Type**
- **Content-Language**
- **Content-Type**
- **Content-Encoding**

与请求首部集一一对应；

## 十二、断点续传和多线程下载

`HTTP`是通过在`Header`里两个参数实现的，客户端发出请求时对应的是`Range`，服务器端响应时对应的是`Content-Range`，如果续存成功返回`206`，如果文件有变动返回`200`和新文件的内容；

#### 1.Range

用于请求头中，指定第一个字节的位置和最后一个字节的位置，格式为：

```csharp
//格式（左开右闭）
Range:(unit = first byte pos) - [last byte pos]

//示例
Range: bytes=5001-10000
```

接收到附带 `Range` 首部字段请求的服务器，会在处理请求之后返回状态码为 `206 Partial Content` 的响应。 无法处理该范围请求时，则会返回状态码 `200 OK` 的响应及全部资源。

**断点续传过程**

- `1`.客户端下载一个`1024K`的文件，已经下载了其中的`512K`。

- `2`.网络中断，客户端请求续传，因此需要在`HTTP`头中申明本次需要续传的片段： `Range:bytes`=`512000~`这个头通知服务器端从文件的`512K`位置开始传输文件；

- `3`.服务器收到断点续传请求，从文件的`512K`开始传输，并且在`HTTP`头中增加：

  ```css
  Content-Range:bytes 512000-/1024000
  ```

  并且此时服务端返回的`HTTP`状态码应该是`206 Partial Content`，而不是`200`；

## 十三、HTTPS

`HTTPS`使用的是`TSL`协议（`SSL`是`TSL`协议的一种）；

#### 1.HTTPS的功能

- 内容加密
  - 非对称密钥加密：传输公钥时可能被截获并掉包，解决方案：使用第三方机构颁发的证书加密公钥（根据服务器地址等多个信息生成，无法被第三方伪造），浏览器收到后使用证书机构颁发的公钥进行解密（前提是浏览器要信任同一个证书颁发机构）解密结果与用证书生成的规则再生成一个签名对比一致就是真证书；
  - 对称密钥加密：中间人随意截获
- 身份认证
  - 数字证书
- **数据完整性**

#### 2.HTTPS的使用成本

`HTTPS`是一个大趋势

- **证书费用以及更新维护**
  - 证书现在不贵，也有免费的；
- **HTTPS降低用户访问速度**
  - 经过合理的优化（比如`SPDY`）和部署甚至可以比`HTTP1.0`快，不过这也是成本之一就是了；
- **消耗CPU资源，需要增加大量机器**
  - 需要多次计算

#### 3.HTTPS对性能的影响

- **协议交互所增加的网络RTP（往返时延）**
- **加解密相关计算的耗时**

**网络耗时：**
`HTTP`只需要通过`TCP`的三次握手就能建立`HTTP`连接：

![image-20200319092450746](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/79.png)

而`HTTPS`除了`TCP`的三次握手外，甚至还需要耗费额外的`7`个`RTP`进行验证

![image-20200319092433164](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/80.png)

关于`302`自动跳转，这是因为，比如访问百度，我们输入网址全称而是输入`baidu.com`，所以会自动跳转至`HTTPS`，这本身也需要耗时；

并且跳转后，`URI`不一样了，浏览器要与服务器重新通过三次握手建立`TCP`连接；

之后还要进行`TLS`协商，比如密钥交换算法，对称加密算法，内容一致性校验算法，证书签名算法等等；浏览器获取到证书后，也需要校验证书的有效性，比如证书是否过期，是否撤销等等；

接着，浏览器首先获取证书里的`CA`域名如果该`CA`域名没有命中缓存，浏览器需要解析域名的`DNS`，这个`DNS`解析至少耗费一个`RTP`；

`DNS`解析到`IP`之后就要完成三次握手，建立`CA`站点的`TCP`连接，这又耗费一个`RTP`；

再接着浏览器发送`OCSP`请求，获取响应耗费一个`RTP`；

> 关于`OCSP`：在线证书状态协议，它是维护服务器和其他网络资源安全性的两种普遍模式之一，另外一个叫做`CRL`证书注销列表；当用户试图访问一个服务器的时候，在线证书状态协议发送一个对于证书状态信息的请求，服务器会回复一个有效、过期、未知的响应；协议规定了服务器和客户端应用程序通信的语法；在线证书协议给了用户到期证书一个宽限期，这样用户就可以在更新证书前的一段时间继续访问服务器，所以这里就需要发起一个对于证书状态的请求，也需要消耗一个`RTP`

最后就是`TLS`完全握手阶段`2`，这个阶段主要进行密钥协商，耗时一个`RTP`；随后进行应用层的`TCP`数据通信。

**计算耗时**

- 浏览器计算耗时；
- 服务器计算耗时；

#### 4.HTTPS常见问题

- `HTTPS`需要安装证书
- 大型网站比如百度，从`HTTP`升级为`HTTPS`比较困难（不能因为升级而降低用户体验这样就本末倒置了）
- `HTTPS`并不能解决所有安全问题（比如`XSS`攻击，木马等），只是能更加安全的传输数据

#### 5.影响HTTP网络请求的因素

- **带宽**
- 延迟
  - 一条连接上只可发送**一个**请求；
  - 请求只能从**客户端开始**，客户端不可以接收除响应以外的指令；
  - 请求/响应头部**不经压缩**就发送，每次互相发送**相同**的头部造成的浪费很多；
  - 非强制压缩发送；

## 十四、WebSocket

可以理解为`WebSocket`是为了让`HTTP`支持长连接而打的一个大补丁；

![image-20200319105842250](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/81.png)

`WebSocket`是一个持久化的`HTTP`，而`HTTP`本身是非持久化的如下图所示：（虽然有`Keep-Alive`）

![image-20200319105852095](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/82.png)

#### 1.WebSocket的握手

**请求：**

![image-20200319110017779](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/83.png)

**响应：**

![image-20200319110157916](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/84.png)

```
Upgrade`：表示升级为`WebSocket
```

#### 2.WebSocket的作用

**HTTP的瓶颈**

**请求**只能从客户端发起，客户端不可以接收除了**响应**之外的指令；当客户端需要监听服务器上的内容时，在HTTP中有一些优化处理方式，常用的用：**Ajax轮询**，**Long Poll**

- **Ajax轮询**

原理为，客户端每隔几秒就发送一次请求，询问服务器到底有没有新消息；若有服务器返回新消息，没有就返回提示信息，如此循环：

![image-20200319111653521](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/85.png)

- **Long Poll长轮询**

与**Ajax轮询**原理相似，客户端先发出请求，直到服务器上有新数据返回之前，都不再发送请求，如此循环：

![image-20200319111724771](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/86.png)

**缺陷：**两种方式都非常消耗资源，**Ajax轮询**需要服务器有很快地处理**速度**；**Long Poll**需要服务器有很大**容量**；

- **异常情况**

![image-20200319111742047](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/87.png)

**WebSocket解决上上述问题**

首先使用`HTTP`协议通知服务器升级到`WebSocket`协议，随后在`WebSocket`协议中，服务器端是可以主动推送数据给客户端的，详细过程：

![image-20200319111934039](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/88.png)

**WebSocket的特点**

相比于`HTTP`的长连接，`WebSocket`具有以下特点

- 真正的**全双工方式**：服务器可以主动推送，`HTTP`的长连接仍然是客户端主动发起请求的；
- 减少**通信量**：不需要重复传输`HTTP Header`等信息；
- 持久性连接：只要进行一次`HTTP`连接，两者就能创建持久的`WebSocket`连接；

## 十五、SPDY

**SPDY**是`HTTP`的增强，在向下兼容的情况下，在`TLS`层上新增一层会话层`SPDY`，使用这个会话层来实现`SPDY`协议，也就是说现有的服务格式均不用改变吗；**SPDY**是对`HTTP`的一个更好的实现和支持；

![image-20200319120419163](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/89.png)

#### 1.HTTP的缺陷

- **单路连接，请求低效：**最大的弊端所在：每个`TCP`连接只能对应一个`HTTP`请求；也就是每个`HTTP`请求只能请求一个资源；浏览器只能通过建立多个连接来解决低效问题。
- **对请求严格的先进先出：**如果中间的某个请求处理时间比较长的话，就会阻塞后面的请求；
- **只允许由客户端主动发起请求：**客户端只能接收服务器发出的响应，服务器无法主动推送信息；
- **HTTP的头部冗余：**`HTTP`的头在一个会话里是反复传送的，中间的冗余信息比如：`User-Agent`、`Host`的等不需要重复发送的信息也在不断地重复发送，浪费带宽和资源；

#### 2.SPDY的改进

所以基于`HTTP`的上述缺陷，**SPDY**进行了以下改进：

- **多路复用请求优化**：`SPDY`规定在一个`SPDY`连接内可以有无限个并行的请求，即多个并发的请求共用一个`TCP`会话；只需要建立一个`TCP`连接就可以传送网页上的所有资源；减少了时延，节省了资源，把`TCP`连接的效率发挥到了最高；
- **可以设置请求的优先级**：不必遵守`HTTP`那样的先进先出，而是可以优先传输`CSS`这些更重要的资源，然后再传输网站图标这样不太重要的资源。
- **支持服务器推送功能**：可以实现预加载，比如浏览器请求了`style.css`，服务器就会主动把`style.js`推送给浏览器。这样浏览器请求`style.js`是就可以直接使用本地缓存了；这 与`WebSocket`不同在于，这是**资源**的主动推送；
- **SPDY压缩了HTTP头**：舍弃了不必要的`Header`头，可以节省多余数据造成的等待时间，占据的带宽等；
- **强制使用SSL传输协议**：客户端全部的请求都要经过`SSL`加密后才能传输；

**直观的影响**

对于前端工程师而言，页面优化永远是一个课题。有了`SPDY`的请求优化，可以将请求顺序重新编排，这样很大程度上缓解了页面加载时图片请求带来的影响；减少了`HTTP`的请求；

## 十六、HTTP2.0

上面所讲的`SPDY`后来被谷歌放弃了，转而成为了`HTTP2.0`的前身，基于`SPDY`的核心改造升级开发出了`HTTP2.0`。所以两者有比较多相似的地方：

![image-20200319120435914](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/90.png)

#### 1.HTTP2.0性能增强的核心：二进制分帧

在`HTTPS`的基础上新增了二进制分帧层：`Binary Framing`，在该层上`HTTP2.0`会将所有的传输信息分割成更小的消息和帧，并对其采用二进制格式的编码；

如下图所示：

![image-20200319120435914](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/90.5.png)

- 请求头信息被封装进了`HEADERS frame`中，请求报文主体被封装进了`DATA frame`中；
- `HTTP2.0`的通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息由一个或多个帧组成。这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。

#### 2.HTTP2.0首部压缩

`HTTP2.0`在服务器端和客户端使用**首部表**来跟踪和存储之前发送的键值对，对于相同的数据不再通过每次请求和响应发送，通讯期间几乎不会改变通用的键值对，比如：`Host`、`User-agent`等只需要发送一次；如果这个请求不包含首部，那么首部的开销就变为`0`字节了，此时首部都自动使用之前发送请求的首部；

如下图所示，`Request # 2`中只需要在`HEADERS frame`里发送`:path`这个变化的头部即可，其他头部信息直接沿用`Request #1`的请求头；或者说新增或变化的头部信息会被追加到新的首部表中，如图中的`Request #2`。它在`HTTP2.0`的连接存续期内是始终存在的，由客户端和服务器端共同地渐进地更新；

![image-20200319121457874](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/91.png)

#### 3.HTTP2.0多路复用

多路复用这也是继承于`SPDY`协议的，`HTTP2.0`所有的通信都在一个`TCP`连接上完成。`HTTP2.0`把`HTTP`通信的基本单位缩小为一个一个的帧，这些帧对应于逻辑流里面的信息，并行的在同一个`TCP`连接上双向交换；

![image-20200319122435057](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/92.png)

`TCP`连接性能的关键在于低延迟。大多数`HTTP`连接的时间都很短，而且是突发性的，而`TCP`只在长时间传输连接，传输大块数据的时候效率是最高的；`HTTP2.0`通过让所有的数据流公用一个`TCP`连接可以更有效地使用`TCP`连接，让高带宽也能真正地服务于`HTTP`的性能提升上。

**但链接多资源的优势**

- 可以减少**服务器建立大量链接的压力**，内存占用更少，连接吞吐量变大了。
- 由于`TCP`连接减少而使**网络拥塞状况**得以改观；
- 慢启动时间减少，**拥塞**和**丢包**恢复速度更快；

也就是说，资源合并减少请求的方式，对于`HTTP2.0`来说是没有效果，只会开发者无用的工作量而已。所以当`HTTP2.0`普及之后，像雪碧图呀，文件合并等就没有多大意义了。

#### 4.并行双向字节流的请求和响应

![image-20200319130500653](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/93.png)

简单点说就是可以**乱序发送**，在`HTTP2.0`上客户端和服务器可以把`HTTP`数据的消息分解为互不依赖的数据帧，然后乱序发送，最后在接收端把这些乱序帧重新组合起来。如图所示，同一个连接有多个不同方向的数据流在传输，所以客户端可以一边乱序地发送数据帧，也可以接收服务器的响应；服务器端也是如此都是双向的。

所以：把`HTTP`消息分解为独立的帧交错发送，然后在另一端重新组装是`HTTP2.0`一项很重要的增强；

这一特性会发生连锁反应带来巨大的性能提升：

- 并行交错地发送**请求**，请求之间**互不影响**；
- 并行交错地发送**响应**，响应之间**互不干扰**；
- 只是用一个连接即可**并行发送**多个请求和响应；
- 消除不必要的延迟，减少页面加载的时间；

#### 5.请求优先级

`HTTP2.0`的这一特性也是继承于`SPDY`，服务器处理不同的流采取不同的优先策略；

- 高优先级的流都应该优先发送；
- 优先级不是绝对的；
- 不同优先级混合也是必须的；

#### 6.服务器推送

毕竟`HTTP2.0`的核心是从`SPDY`的基础上衍生而来的；服务器可以对客户端的一个请求发送多个响应，即除了对最初请求的响应之外服务器还可以额外向服务器推送其他资源，而无需客户端明确请求；如图所示：客户端请求了`html`文件，服务器就会把`js`与`css`文件推送给客户端：

![image-20200319132715028](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/94.png)

## 十七、WebDAV协议

`WebDAV`（`Web-based Distributed Authoring and Versioning`，基于万维网的分布式创作和版本控制）是一个可对 `Web` 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统（可在线修改文件的**网盘**）。

除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能， 以及对文件内容修改的版本控制功能。

![image-20200319140154332](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/95.png)

使用 `HTTP/1.1` 的 `PUT` 方法和 `DELETE` 方法， 就可以对 `Web `服务器上的文件进行创建和删除操作。 可是出于安全性及便捷性等考虑，一般不使用。

#### 1.WebDAV 内新增的方法及状态码

`WebDAV` 为实现远程文件管理，向 `HTTP/1.1` 中追加了以下这些方法。

|   方法    |      用途      |
| :-------: | :------------: |
| PROPFIND  |    获取属性    |
| PROPPATCH |    修改属性    |
|   MKCOL   |    创建集合    |
|   COPY    | 复制资源及属性 |
|   MOVE    |    移动资源    |
|   LOCK    |    资源加锁    |
|  UNLOCK   |    资源解锁    |

新增状态码：

|         状态码          |                       含义                       |
| :---------------------: | :----------------------------------------------: |
|     102 Processing      |        可正常处理请求，但目前是处理中状态        |
|    207 Multi-Status     |                   存在多种状态                   |
| 422 UnprocessibleEntity |                格式正确，内容有误                |
|       423 Locked        |                   资源已被加锁                   |
|  424 FailedDependency   | 处理与某请求关联的请求失败，因此不再维持依赖关系 |
| 507 InsufficientStorage |                   保存空间不足                   |

**WebDAV 的请求实例 **

下面是使用 `PROPFIND` 方法对` http://www.example.com/file` 发起获取属性的请求 :

```bash
PROPFIND /file HTTP/1.1
Host: www.example.com
Content-Type: application/xml; charset="utf-8"
Content-Length: 219

//...请求主体
```

**WebDAV 的响应实例 **

下面是针对之前的 `PROPFIND` 方法， 返回`http://www.example.com/file `的属性的响应。

```bash
HTTP/1.1 207 Multi-Status
Content-Type: application/xml; charset="utf-8"
Content-Length: 831

//...响应主体
```

不过可以使用`FTP`替代它；

## 十八、HTTP3.0

![image-20200319142842312](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/96.png)

#### 1.HTTP2.0的问题

- **队头阻塞**：由于只建立一个`TCP`连接，一旦出现某次传输出现丢包，就要等待重传，严重阻碍了其他数据的传输；
- **建立连接的握手延迟大**：`HTTPS`和`HTTP2.0`除了建立`TCP`握手之外，还要建立`TSL`安全传输，这就出现了两次握手延迟；对于短连接来说，影响无法被移除，这些都是`TCP`的历史遗留问题；

#### 2.QUIC的特性

- **0 RTP**：两层意思，建立`UDP`连接和建立`TSL`安全连接大多数情况只需要`0 RTP`；

![image-20200319143544308](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/97.png)

- **没有队头阻塞的多路复用**

当`TCP`连接中传输的数据流`stream2`中出现丢包时，在发送端没有重传丢失的包之前跟在`stream2`后面的`stream3/4`就被阻塞住了；

![image-20200319143715846](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/98.png)

然而`UDP`连接中，数据流彼此间没有依赖关系，即使`stream2`出现丢包，也不影响其他`stream`数据的传输；

![image-20200319144040196](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/99.png)

- **前向纠错**（`Front Error Collection`）

每个数据包除了它本身的数据之外，还包括了部分其他包的内容，因此少量的丢包可以通过其他包的冗余数据直接组装，而无需重传；这种方法虽然牺牲了每个数据包可发送数据的上限，但是减少了因为丢包导致的数据重传（更浪费时间）；如果丢失的包过多，就只能通过重传来解决。

**QUIC**融合了`UDP`协议的速度性能和`TCP`的安全和可靠，大大优化了互联网传输数据的体验。

#### 3.HTTP协议总结

- `HTTP1.0/1.1`：有**连接无法复用**、**队头阻塞**、**协议开销大**和**安全因素**等多个缺点；
- `HTTP2.0`：通过**多路复用**、**二进制流**、**头部压缩**等技术极大地提升了性能，但是还是存在问题；
- `HTTP3.0`：`QUIC`是基于`UDP`实现的，是`HTTP3.0`的底层支持协议。该协议基于`UDP`又吸收了`TCP`的精华，实现了既快又可靠的连接；

## 十九、Web安全

### 1.概述

**日常生活中的”安全“**

- 为什么登录的时候经常要求我们输入一个验证码？
- 在一个网站上长时间没有操作，为什么`Session`会失效？

#### 1.1.WASC的定义

全程`Web Application Security Consortium`：是一个由安全专家、行业顾问和诸多组织的代表组成的国际团体，负责为`WWW`（万维网）制定广为人知的**应用安全标准**。

#### 1.2.六类Web应用安全威胁

|          名称          |   中文名   |                             作用                             |
| :--------------------: | :--------: | :----------------------------------------------------------: |
|     Authentication     |    验证    |          用来确认某用户、服务或是应用身份的攻击手段          |
|     Authorization      |    授权    | 用来决定是否某用户、服务或是应用具有执行请求动作必要权限的攻击手段 |
|  Client-Side-Attacks   | 客户侧攻击 |           用来扰乱或是探测`Web`站点用户的攻击手段            |
|   Command Execution    |  命令执行  |     在`Web`站点上执行远程命令的攻击手段（比如`SQL`注入）     |
| Information Disclosure |  信息泄露  |           用来获取`Web`站点具体系统信息的攻击手段            |
|    Logical Attacks     | 逻辑性攻击 |         用来扰乱或是探测`Web`应用逻辑流程的攻击手段          |

#### 1.3.OWASP的定义

全称`Open Web Application Security Project`，该组织致力于发现和解决不安全`Web`应用的根本原因；它们最重要的项目之一是**Web应用的十大安全隐患**

总结了目前`Web`应用最常受到的十种攻击手段，并且按照攻击发生的概率进行了排序（以下为`2017`年的数据）：

| 排名 |        漏洞种类        |                             详情                             |
| :--: | :--------------------: | :----------------------------------------------------------: |
|  A1  |          注入          | 将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生注入：`SQL`注入、`NoSQL`注入、`OS`注入和`LDAP`注入缺陷。 |
|  A2  |     失效的身份认证     | 通过错误的使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话令牌 |
|  A3  |      敏感数据泄露      | 许多`Web`程序和`API`都无法正确保护敏感数据，攻击者可通过窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃等犯罪行为 |
|  A4  |   XML外部实体（XXE）   | 许多较早的或配置错误的`XML`处理器评估的`XML`文件中的外部实体引用。攻击者可利用外部实体窃取内部文件、执行远程代码 |
|  A5  |     失效的访问控制     |           未对通过身份验证的用户实施恰当的访问控制           |
|  A6  |      安全配置错误      | 安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云错误等造成 |
|  A7  |    跨站脚本（XSS）     | `XSS`让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用于重定向到恶意站点 |
|  A8  |    不完全的反序列化    |              不安全的反序列化会导致远程代码执行              |
|  A9  | 使用含有已知漏洞的组件 |     组件如库、框架和其他软件模块拥有和应用程序相同的权限     |
| A10  |  不足的日志记录和监控  | 不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性、篡改、提取或销毁数据 |

### 2.验证机制

验证机制是`Web`应用程序中最简单的一种**安全机制**，也是防御恶意攻击的**核心机制**；

#### 2.1.典型的身份验证模式

![image-20200319153857741](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/100.png)

**验证技术**

- 基于**HTML表单**的验证
- 多元机制，如组合密码；
- 客户端`SSL`证书

**弱密码**

许多`Web`应用程序没有或很少对用户密码强度进行控制；

**暴力破解**

登录功能的公开性会诱使**攻击者**试图**猜测**用户名和密码，从而获得访问应用程序的权力；

**暴力破解-安全措施**

- **验证码技术**：最常见和有效的应对方式，需要注意几个问题：
  - **验证码**是否真实有用
  - 验证码的**复杂度**：从最开始的数字，到数字字母组合，再到谷歌奇形怪状的字母；
  - 应对当前的”**打码**“事业盛行：使用专门平台的”**打码**“服务器进行破解；对此出现了点击型的验证码、滑动型的验证码、问答型的验证码等更高级的验证码；
- **Cookie和会话检测**：有些应用程序会设置一个**Cookie**，如`failedlogin = 0`；尝试登录失败，递增该值，达到某个上限，检测到这个值并拒绝再次处理登录；
  - 这样也不安全，只要客户端的`Cookie`在到达服务器端前被截获，就能被篡改；
- **双因子认证**：双因子认证的核心是综合`What you know`（**个人密码**）和`What you have`（手机）来达到双重认证效果；（**较安全常用**）

### 3.会话管理机制

- 绝大多数`Web`应用程序中，会话管理机制是一个基本的**安全组件**。会话管理机制在应用程序执行登录功能时尤为重要，因为：它可以在用户通过请求提交它们的证书后，**持续向应用程序保证任何特定用户身份的真实性**；
- 由于会话管理机制所发挥的关键作用，它们就成为了针对应用程序的**恶意攻击**的主要目标；
- 若攻击者能够**破坏**应用程序的会话管理，他就能轻易避开其实施的验证机制，不需要用户证书即可伪装成其他应用程序用户。

#### 3.1.会话管理存在的漏洞

- **会话令牌生成漏洞**：比如采用常见的算法生成，容易被人猜出算法名称进行反编译破解；
- **令牌可预测**：比如隐含序列，事件依赖；
- **会话终止攻击**：会话结束后，**Cookie**没有真正意义上被删除，下次验证还有效；
- **会话劫持攻击**：比如网络嗅探、`XSS`攻击等方式获取用户的会话令牌；

#### 3.2.会话管理漏洞的防御

**令牌传输安全**

- 令牌只能通过**HTTPS**传送；
- 如果使用`HTTP cookie`传送令牌（大多数情况下）应该将`Cookie`字段标记为`Secure`，以防止用户浏览器通过`HTTP`传送它们；

**增加软硬会话过期**

- **软会话过期**：它指的是用户在一定的时间内与应用系统没有交互，则**会话过期**也就是我们常说的**Session失效**；
- **硬会话过期**：它指的是用户登录到系统中经过一定的时间后，不管用户做什么，该会话都会过期（**网吧上网时间到了，强制下机**）；

## 二十、常见的网络攻击

### 1.SQL注入攻击

#### **1.1.SQL注入原理**

- 几乎每个`Web`应用都需要使用**数据库**来保存操作所需要的各种信息；
- 所以`Web`程序是经常会建立用户提交数据的`SQL`语句；
- 最严重的情况下，攻击者可利用`SQL`注入，读取甚至修改数据库中保存的所有数据；
- 用户可以提交一段**数据库查询代码**，根据程序返回结果，获得某些他想得知的数据；

这就是所谓的**SQL Injection**，即`SQL`注入；比如：

![c](https://gitee.com/ahuntsun/BlogImgs/raw/master/HTTP/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/101.png)

帐户名中输入的`‘or’1 = 1`会被识别为`SQL`操作指令；

#### **1.2.SQL注入危害**

- **探知数据库**的具体结构，为进一步攻击准备；
- **泄露数据**，尤其是机密信息、账户信息等；
- **取得更高权限**，用来修改数据甚至是内部结构；

#### 1.3.SQL注入防御

**参数化查询**

- **参数化查询**是对`SQL`注入根本性的**防御策略**，也叫做预处理语句，在建立一个包含用户输入的`SQL`语句时分为两步：

  - **指定查询结构，用户输入预留占位符；**
  - **指定占位符内容；**

  比如使用问号`?`当作占位符，这样即使输入了`SQL`语句这样也不会被认为是数据`SQL`的一部分，而是用户输入内容。

**字符串过滤**

**使用正则表达式过滤传入的参数**

### 2.跨域脚本攻击（XSS）

跨站脚本攻击（`Cross Site Scripting`），`XSS`（`CSS`已被占用所以叫`XSS`）是一种经常出现在`Web`应用中的计算机安全漏洞；

它允许`Web`用户恶意地将代码植入到提供给其他用户使用的页面中，其他用户在观看网页时，恶意脚本就会执行；

#### 2.1.XSS攻击原理

- 这类攻击通常通过注入`HTML`或`JS`等脚本发动攻击；
- 攻击成功后，攻击者可以得到私密网页内容和`Cookie`等；
- 最近几年`XSS`攻击已成为最流行的攻击方式；

#### 2.2.XSS攻击危害

- **盗取各类用户账号**：如机器登录账号、用户网银账号、各类管理员账号；
- **控制数据**：包括读取、篡改、添加、删除企业敏感数据的能力；
- 盗窃企业重要的具有**商业价值**的资料；
- 非法转账；
- 强制发送网站挂木马；
- 控制受害者机器，让该用户成为"肉机"，向其他网站发起攻击；

#### 2.3.XSS攻击真实案例

> **Myspace XSS攻击事件**

- 2005年，一名叫做`samy`的用户发现了`Myspace`（社交网站）的`XSS`漏洞，他在用户资料页面插入了一些`javascript`脚本；
- 如果一个用户查看了他的用户资料，这段脚本就会被执行；
- 脚本包括两方面：一是把`Samy`加为好友，二是将上面说的脚本复制到受害者自己的用户资料页面中；
- 于是，所有查看受害者用户资料的用户也会成为受害者；
- 一个基于存储式`XSS`攻击的蠕虫迅速扩散，几个小时内，`Samy`收到了近百万个好友的申请；
- 为此，`Myspace`被迫关站，修复反`XSS`过滤机制并且从所有用户的资料中删除含有恶意脚本的内容；

#### 2.4.XSS分类

针对`XSS`的攻击方式不同，可以把`XSS`分为如下三大类：

- **反射式XSS**
- **存储式XSS**
- **基于DOM的XSS**

##### 反射式XSS

也称为**非永久性XSS**，目前最流行的`XSS`攻击；它出现在服务器直接服务器直接使用客户端提交的数据，如`URL`的数据、`HTML`表单中提交的数据，并且没有对数据进行无害化处理；如果提交的数据中含有`HTML`控制字符而没有被正确处理，那么一个简单的`XSS`攻击就会发生。

典型的反射式攻击方式可通过一个邮件或中间网站，诱饵是一个**看起来可信任**的站点的链接，其中包含`XSS`攻击脚本，比如社交群中常发的游戏活动、赌博、美女链接等。如果信任的网站没有正确处理这个脚本，用户点击后就会导致浏览器执行含有恶意攻击的脚本。

##### 存储式XSS

也称为**永久性XSS**，危害更大。攻击将攻击脚本上传到`Web`服务器上，使得所有访问该页面的用户都面临信息泄露的可能，其中也包括了`Web`服务器的管理员；

存储式`XSS`多发生在最终显示给其他用户的位置包含：

- 个人信息字段，如姓名、地址、电子邮件、电话等；
- 文档、上传文件及其他数据的名称；
- 提交给应用程序管理员的反馈或问题；
- 向其他应用程序用户传送的消息、注释、问题等；
- 在用户之间共享的上传文件内容；

**典型的存储式XSS攻击过程**

- 我拥有一个`Web`站点，该站点允许用户发布信息/浏览已发布信息；
- 你注意到我的站点具有存储式的`XSS`漏洞；
- 于是你发布一个热点信息，利用该漏洞获取用户信息，吸引其他用户纷纷阅读；
- 任何其他人浏览该信息，其绘画`Cookies`或其他信息都会被你盗走；

##### 基于DOM的XSS攻击

反射式`XSS`攻击和存储式`XSS`攻击都是通过服务器提取用户提交的数据，并且以不安全的方式将其返回给用户；基于`DOM`的攻击仅仅通过`JavaScript`的方式执行；

也就是说这种攻击常发生在应用程序每次返回相同的静态页面（`HTML`文件），并通过客户端的`js`文件动态生成信息，并不会与服务器交互获取该`js`文件的时候；

#### 2.5.XSS攻击载荷

**会话令牌**

- `XSS`攻击对普遍的方式；
- 截取一名受害者的会话令牌（`Token`）,劫持他的会话，进而作为受害者的身份来使用应用程序，执行任意操作并占有该用户的账号；

**虚拟置换**

- 这种攻击需要在一个`Web`应用程序页面注入恶意数据，从而向应用程序的用户传送误导性信息；

- 包括简单的向站点注入`HTML`，或者使用脚本注入精心设计的内容；

  比如在淘宝的搜索结果页面中注入一个链接，受害者点击后跳转到一个和淘宝很像的钓鱼网页，登录时帐户信息就被泄露了；

- 攻击者实际上没有修改保存在服务器上的内容，而是利用程序处理并显示用户提交的输入方面的缺陷实现置换；

**注入木马**

- 在一个明显的攻击中，攻击者注入的功能向用户显示一个木马登录表单，要求他们像攻击者控制的服务器提交他们自己的证书。

#### 2.6.XSS防御措施

##### 输入验证

- 在输入的过程中，如果应用程序有向后端提交处理的数据，应**对这些数据进行严格的确认**；
- 比如：数据不能太长；
- 数据仅包含某组合法字符；
- **数据与一个特殊的正则表达式匹配**（比如手机号）；
- 根据应用程序希望在每个字段中收到的数据类型，尽可能限制性地对姓名、电子邮件地址、账号等应用不同的确认规则；

##### 输出编码

- 如果应用程序将某位用户或第三方提交的数据复制到它的响应中，那么应用程序应对这些数据进行`HTML`编码，以净化可能的恶意字符；

- `HTML`编码指用对应的`HTML`实体替代字面量字符。这样做可确保浏览器安全处理可能为恶意的字符，把它们当作`HTML`文档的内容而非结构处理；

- 经常造成问题的字符的

  ```
  HTML
  ```

  编码：

  - `”` -> `&quot`
  - `'` -> `&#x27`
  - `<` -> `&lt`
  - `>` -> `&gt`
  - `/` -> `x2F`

应用程序之所以结合使用**输入确认**（次要）与**输出净化**（首要），原因在于这种方法能够提供两层防御：如果其中一层被攻破，另一层还能提供一些保护；

### 3.CSRF攻击

`CSRF`（`Cross-site Request Forgery`）**跨站请求伪造**，也被称为`One Click Attack`或者`Session riding`通常缩写为`CSRF`或者`XSRF`，是一种对**网站的恶意利用**；

尽管听起来像跨站脚本（`XSS`），但它与`XSS`非常不同，并且攻击方式几乎相左；

#### 3.1.CSRF攻击原理

- `XSS`利用站点内的**信任用户**（受害者），而`CSRF`通过伪装来自受信任用户的请求来利用**受信用的网站**；
- 通过社会学的手段（如通过电子邮件发送一个链接）来蛊惑受害者进行一些敏感性的操作，如修改密码、修改`E-mail`、转账等，而受害者还不知道他已经中招；

#### 3.2.CSRF攻击危害

- `CSRF`的**破坏力**依赖于**受害者**的**权限**；
- 如果受害者只是个**普通用户**，则一个成功的`CSRF`攻击会危害用户的数据以及一些功能；
- 如果受害者具有**管理员权限**，则一个成功的`CSRF`攻击甚至会威胁到整个网站的安全；
- 与`XSS`攻击相比，`CSRF`攻击往往不太流行，因此对其进行防范的资源也相当稀少，和难以防范；
- 故被认为比`XSS`更具危险性，所以`CSRF`在业内有个响当当的名字——**沉睡的巨人**

#### 3.3.CSRF攻击的特点

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
- 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
- 整个过程攻击者**并不能**获取到受害者的登录凭证，仅仅是“冒用”。
- 跨站请求可以用各种方式：图片`URL`、超链接、`CORS`、`Form`提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

`CSRF`通常是**跨域**的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。（比如博客留言）

#### 3.4.CSRF攻击的过程

- 受害者登录`a.com`，并保留了登录凭证（`Cookie`）；
- 攻击者引诱受害者访问了`b.com`；
- `b.com` 向` a.com` （服务器）发送了一个请求：`a.com/act=xx`。浏览器会默认携带`a.com`发放的`Cookie`；
- `a.com`接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者（`a.com`的用户）自己发送的请求；
- `a.com`以受害者的名义执行了`act=xx`；
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让`a.com`执行了自己定义的操；

#### 3.5.CSRF攻击预防

`CSRF`通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对`CSRF`的防护能力来提升安全性。

上文中讲了`CSRF`的**两个特点**：

- `CSRF`（通常）发生在第三方域名。
- `CSRF`攻击者不能获取到`Cookie`等信息，只是使用。

针对这两点，我们可以专门制定防护策略，如下：

- 阻止不明外域的访问
  - 同源检测
  - `Samesite Cookie`
- 提交时要求附加本域才能获取的信息
  - `CSRF Token`
  - 双重`Cookie`验证
  - 增加确认操作
  - 重新认证

##### 增加确认操作

- 比如转账功能，当用户调用`API`进行转装的时候，弹出一个对话框，例如：你确认转帐`200`元吗？即在浏览器上进行敏感操作时增加**确认操作**，**确保是用户所为**；

##### 重新认证

- 在做一些重要敏感的操作时，要求用户**重新输入密码**进入二次验证，只有正确了才进行操作；这种做法显然更安全，但对于用户来说不是特别友好——毕竟是增加了异一步操作；
- 所以**安全和易用性**，有时候不得不做出取舍；

##### 使用Token*

`CSRF`的一个特征是，攻击者无法直接窃取到用户的信息（`Cookie`，`Header`，网站内容等），仅仅是冒用`Cookie`中的信息。

而`CSRF`攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个`CSRF`攻击者无法获取到的`Token`。服务器通过校验请求是否携带正确的`Token`，来把正常的请求和攻击的请求区分开，也可以防范`CSRF`的攻击。

**验证过程**

- 服务器端：在用户刚登陆的时候，产生一个新的不可预知的`CSRF Token`，并且把此`Token`存放在用户的`session`中。
- 在任何一个需要保护的表单中（转账，该密码），增加一个隐藏的字段来从服务器端获取和存放这个`Token`；
- 提交请求的时候，在服务器端检查提交的`Token`与用户`Session`中的`Token`是否一致，如果一致，继续处理请求，不一致或者没有的话，就返回一个错误的信息给用户。
- 在用户退出或者`Session`过期的时候，用户信息（包括`CSRF Token`）从`Session`中移除并且销毁`Session`。

## 数字签名

### 一、数字签名简介

> **数字签名是基于公钥密码体制（非对称密钥密码体制）的。**

#### 1.1.基本特征

数字签名必须保证以下三点：

- **报文鉴别**——接收者能够核实发送者对报文的签名；
- **报文的完整性**——接收者不能伪造对报文的签名或更改报文内容。
- **不可否认**——发送者事后不能抵赖对报文的签名；

#### 1.2.数字签名的验证过程

![image-20200203210110403](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/1.png)

上图位用户A使用数字签名向用户B传输一份文件的过程：

- 首先，文件经过单向散列函数的处理得到一份占128位的摘要（无论文件多大，经过单向散列函数的处理，生成的摘要都是128位），这份摘要相当于该文件的"指纹"，能够唯一地识别文件。**注意：**只要文件发生改动，经过单向散列函数处理后得到地摘要都会不一样。所以，文件和文件的摘要具有很强的对应关系。
- 随后，用户A使用自己地私钥对这份128位地摘要进行加密，得到一份加密地摘要。
- 然后，用户A把文件、加密的摘要和公钥打包一起发给用户B。传输的过程中并没有对文件进行加密处理。
- 用户B将收到的文件经过单向散列函数处理得出一份128位摘要，这份摘要是通过收到的文件得到的，存在被更改的可能；使用A提供的公钥对收到的"加密的摘要"进行解密得到另一份128位摘要，这份摘要是通过原始文件得到的，一般认为代表真正的文件；然后将两份摘要进行比较。
- 如果两份摘要相等，说明文件经过用户A签名之后，在传输的过程中没有被更改；若不相等，说明文件在传输过程中被更改了，或者说已经不是原来的文件了，此时用户A的签名失效。

> **数字签名三个特征的验证**

- **不可否认**——只有用户A拥有私钥A，并能使用私钥A产生"加密的摘要"，这样用户A就不能否认给用户B发送了经过签名的密文。
- **报文的完整性**——用户B通过比较得出的两份摘要是否相等，可以判断签名或文件内容是否发生改变。
- **报文鉴别**——用户B可以使用收到的公钥对"加密的摘要"进行解密，从而核实用户A对文件的签名。

> **需要强调**

- 用户A使用私钥对由文件生成的128位摘要进行加密的过程称为**数字签名的过程**，得到的**"加密的摘要"**，称为该文件的**数据签名**。
- 用户A使用私钥加密的是摘要而不是文件。
- 用户B验证签名实际上是比较得出的两份摘要是否相等。

#### 1.3.数字签名使用的场合

什么时候使用这种不对文件加密，而对文件的摘要加密（对文件进行签名）的技术呢？

- 数字签名解决的核心问题是：**确保收到的文件没有被更改**。
- 比如：公司的领导给员工下发放假通知，这时候就需要对邮件进行数字签名来证明这个通知是领导发的。员工收到通知，看到上面有领导的签名，于是就可以放心休假了。如果有人冒充领导发通知，上面没有领导的签名，员工休假回来就要扣工资。同样的，通知有了领导的签名，领导想抵赖也不行。

------

### 二、证书颁发机构CA

#### 2.1CA简介

- 证书颁发机构，即认证中心**CA** (Certification Authority)，来将公钥与其对应的实体（人或机器）进行**绑定**(binding)；即给公司或个人颁发证书。
- 认证中心一般由政府出资建立。每个实体都有CA 发来的**证书**(certificate)，里面有公钥及其拥有者的标识信息。此证书被 CA 进行了数字签名。任何用户都可从可信的地方获得认证中心 CA 的公钥，此公钥用来验证某个公钥是否为某个实体所拥有。有的大公司也提供认证中心服务。

![image-20200203230237525](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/2.png)

如图所示，用户A使用数字签名时给用户B发送了一个数据包，数据包中包含了A的公钥、文件和加密的摘要。那么问题来了：**用户B如何确定收到的公钥是用户A发送的，而不是他人冒充用户A发送的呢？**

- 举个例子：把用户A的公钥和私钥假设为身份证。如果是用户A自己造的身份证别人会信吗？反之，用户A拿着真正的身份证去住宾馆，老板一开始也不相信身份证是用户A的，但是老板相信给用户A发身份证的公安局，老板通过比对公安网上对应身份证号码的信息就可以判断这个身份证是不是用户A的，由此可以确认用户A的身份。
- 同理，B一开始并不确认收到的公钥是来自用户A的，用户A也可抵赖B收到的公钥不是自己发送的。这时就需要有一个双方都信任的第三方证书颁发机构来协调。

#### 2.2.证书颁发和使用过程

![image-20200206155804062](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/3.png)

- 首先，用户A向证书颁发机构提交个人信息，申请证书。通过CA审核后，CA生成用户A的证书，证书中包括了A的公钥和私钥还有CA的数字签名。证书颁发机构CA本身拥有一对密钥，这是对CA所颁发的证书进行数字签名和保密的基础，绝不能泄露。

- 用户A收到的证书中包括了带有CA数字签名的，专属A公钥和私钥，CA的数字签名确保了别人不能伪造用户A的公钥和私钥。

- 同时，用户B也必须信任给用户A颁发证书的第三方认证机构CA，即用户B拥有CA颁发的"CA公钥"。

- 通信时，用户A向用户B发送的数据包中的"加密的摘要"上有用户A的数字签名，“A公钥” 上有认证机构CA的数字签名。用户B收到数据包之后，先要验证收到的 “A公钥” 是否来源合法：是认证机构颁发的带有CA签名的公钥吗？用户B并不信任用户A，但是用户B信任第三方认证机构CA。所以，用户B先使用证书颁发机构颁发的 "CA公钥" 验证收到的 "A公钥" 是否由同一认证机构颁发，是否在颁发之后更改过。

  验证通过后，用户B便相信收到的 "A公钥" 确实来自真实的用户A。随后再使用 "A公钥" 对 "加密的摘要" 进行解密，进行上文提到的对比操作，以判断文件是否更改。

#### 2.3.查看计算机信任的认证机构

信任一个第三方认证机构就意味着拥有该机构颁发的包含该机构公钥的证书。

- 在Windows系统开始菜单中输入"MMC"命令，打开 "Microsoft 管理工具" 。

![image-20200206161418997](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/4.png)

- 打开 "文件" 菜单栏，选择 "添加或删除管理单元" 选项，找到 "证书" 。

![image-20200206161615998](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/5.png)

- 点击 "添加" ，选择需要查看帐户的证书。可重复操作，添加多个账户。

![image-20200206161729657](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/6.png)

- 添加完成之后，点击 "确认" ，即可查看相关帐户的证书。

![image-20200206161906853](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/7.png)

![image-20200206162019459](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/8.png)

- 双击列表中的一个 "证书" ，在 "详细信息" 中可以找到证书对应的 "公钥" 。

![image-20200203235946196](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/9.png)

![image-20200204000011441](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/10.png)

#### 2.4.证书的吊销

当用户A遗失或泄露了CA颁发的证书后，为了避免他人使用该证书冒充用户A，用户A向认证机构CA "挂失" 该证书。于是认证机构CA把该证书放入该认证机构的证书吊销列表（CRL）中，并在网上公示。

用户B在收到用户A的公钥时，除了要验证该公钥是否位认证机构颁发的，还要登录认证机构的网站查看该公钥是否已被认证机构吊销变为无效证书。

#### 2.5.总结

认证机构CA的作用：

- 为企业和用户颁发数字证书，确保这些企业和个人的身份是真实的；
- 发布证书吊销列表，供用户查询收到的证书是否已被机构吊销而无效；

认证机构发挥作用的前提：

- 企业和个人都要信任认证机构。

## Internet上使用的安全协议

> 网络安全是分层实现的，从应用层安全到数据链路层安全。

### 一、运输层安全协议：安全套接字SSL

#### 1.1.简介

- **SSL** 是安全套接层 (Secure Socket Layer)，可对万维网客户与服务器之间传送的数据进行加密和鉴别。
- SSL 在双方的联络阶段协商将使用的加密算法和密钥，以及客户与服务器之间的鉴别。
- 在联络阶段完成之后，所有传送的数据都使用在联络阶段商定的会话密钥。
- SSL 不仅被所有常用的浏览器和万维网服务器所支持，而且也是**运输层安全协议 TLS** (Transport Layer Security)的基础。

#### 1.2.SSL 的位置

![image-20200206165343194](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/1.png)

- 在发送方，SSL 接收应用层的数据（如 HTTP 或 IMAP 报文），对数据进行加密，然后把加了密的数据送往运输层 TCP 套接字。
- 在接收方，SSL 从 TCP 套接字读取数据，解密后把数据交给应用层。（发送方和接收方都有SSL层）

#### 1.3.使用SSL技术的例子

![image-20200206172009093](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/2.png)

当我们访问网站时，一般不涉及输入账号密码等操作的网页使用的都是 "HTTP" 协议（使用80端口），即网站域名开头为：http://；当涉及账号密码等敏感信息的操作时，网站一般都会使用 "HTTPS"协议（使用443端口），"S"表示的即是SSL (Secure Socket Layer)，即网站域名开头为：https://。

例如，我们访问中国工商银行的官网：

![image-20200206170948893](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/3.png)

在主页处的域名栏中可以发现浏览器提醒的 "不安全" 字样，实际上该主页使用的就是HTTP协议，即不加密信息，明文传输。由于这是谷歌浏览器，没有显示 "http://" 的域名前缀。

当点击登录时，跳转到另外一个网页：

![image-20200206171337136](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/4.png)

从网站域名开头的 "https://" 可以看出，涉及到账号密码等敏感信息的登录页面使用的是HTTPS协议，说明网页使用了SSL技术。

> **补充**

HTTP协议使用了安全套接字（SSL）变成了HTTPS协议，使用的端口由80变为443，其他应用层的协议也可以使用安全套接字：

- IMAPS：TCP-993；
- POP3S：TCP-995；
- SMTPS：TCP-465；

#### 1.4.安全套接字实现的过程：https

![image-20200206223547589](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/5.png)

https既采用了对称加密的效率，也采用了非对称加密的安全。

通信前Web服务器先把证书中的公钥交给IE浏览器（客户），IE浏览器根据收到的公钥生成一个对称密钥，然后使用公钥加密对称密钥并发送给Web服务器。

Web服务器使用私钥解密收到的加密后的对称密钥，随后使用对称密钥加密需要传输的数据。在之后的通信中都采用该对称密钥对数据加密和解密。

在传输对称密钥的过程中使用非对称加密，在传输数据过程中使用对称加密。这样既保证了数据传输的安全，也提高了效率。

所以，在使用https通信的时候一开始都不会太快，因为要协商对称密钥，协商好之后才会快起来。

> **查看使用https网站的证书**

例如：百度。

![image-20200206224006290](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/6.png)

点击 "锁" 图标。

![image-20200206224100256](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/7.png)

点击 "证书" 即可查看到该网站使用的证书。

![image-20200206224149426](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/8.png)

![image-20200206224207086](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/9.png)

#### 1.5.SSL 实现的三个功能

- **SSL 服务器鉴别** ：允许用户证实服务器的身份。具有 SSL 功能的浏览器维持一个表，上面有一些可信赖的**认证中心** CA (Certificate Authority)和它们的公钥。
- **加密的 SSL 会话** ：客户和服务器交互的所有数据都在发送方加密，在接收方解密。
- **SSL 客户鉴别** ：允许服务器证实客户的身份。

![image-20200206224325686](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/10.png)

上图为颁发给百度首页的证书，可以看到SSL除了可以加密会话信息之外，还可以鉴别服务器和客户身份。

------

### 二、网络层安全协议：IPSec

网络安全是分层实现的。

![image-20200206225737400](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/11.png)

- 应用层安全：比如微软的 "Outlook" 邮箱，可以通过在应用程序中的某些设置实现数据传输的安全。应用层安全的特点为需要应用程序的支持。

- 传输层安全：传输安全是通过夹在应用层和传输层中间的SSL层实现的，发送方的SSL可以将应用层的数据加密后给传输层，接收方的SSL传输层收到的数据解密后给应用层。SSL安全的特点为需要配置相应证书。

- 网络层安全：属于底层安全，不需要应用程序支持，也不需要配置证书，对用户来说是透明的，即用户并不知道数据在该层进行了加密。

  比如，未加密的数据经过发送方的网卡实现了加密，接收方的网卡实现数据解密，整个过程用户是不知道的，是透明的，即使数据在传输过程中被截获了，第三方也不能破解其中内容；或者数据被篡改了，接收方也能发现，这便是网络层安全。

#### 2.1.IPsec与安全关联 SA

网络层保密是指所有在 IP 数据报中的数据都是加密的。

> **IPsec 中最主要的两个部分 **

- **鉴别首部 AH** (Authentication Header)： AH鉴别源点和检查数据完整性，但不能保密。类似于数字签名，用于确保数据的来源并判断数据是否被更改。
- **封装安全有效载荷 ESP** (Encapsulation Security Payload)：ESP 比 AH 复杂得多，它鉴别源点、检查数据完整性和提供保密。 类似于既使用数字签名，又使用共享密钥对数据进行加密。

> **安全关联 SA(Security Association) **

- 在使用 AH 或 ESP 之前，先要从源主机到目的主机建立一条网络层的逻辑连接。此逻辑连接叫做安全关联 SA
- IPsec 就把传统的因特网无连接的网络层转换为具有逻辑连接的层。
- SA（安全关联）是构成IPSec的基础，是两个通信实体经协商（利用IKE协议）建立起来的一种协定，它决定了用来保护数据分组安全的安全协议（AH协议或者ESP协议）、转码方式、密钥及密钥的有效存在时间等。

#### 2.2.安全关联的特点

- 安全关联是一个单向连接。它由一个三元组唯一地确定，包括：

  (1) 安全协议（使用 AH 或 ESP）的标识符；

  (2) 此单向连接的源 IP 地址；

  (3) 一个 32 位的连接标识符，称为**安全参数索引** SPI (Security Parameter Index)；

- 对于一个给定的安全关联 SA，每一个 IPsec 数据报都有一个存放 SPI 的字段。通过此 SA 的所有数据报都使用同样的 SPI 值。

#### 2.3.查看安全关联

- 在Windows系统开始页面输入命令mmc打开 "Microsoft 管理控制台"，打开 "文件" 选择 "添加/删除管理单元"。

![image-20200207211626876](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/12.png)

- 找到并添加 "IP安全监视器"。

![image-20200207211821913](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/13.png)

- 回到控制台界面，可在IP安全监视器中找到 "安全关联" 选项，选中后可查看已建立的安全关联。

![image-20200207212859987](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/14.png)

#### 2.4.鉴别首部协议 AH

- 在使用鉴别首部协议 AH 时，把 AH 首部插在原数据报数据部分的前面，同时把 IP 首部中的协议字段置为 51。
- 在传输过程中，中间的路由器都不查看 AH 首部。当数据报到达终点时，目的主机才处理 AH 字段，以鉴别源点和检查数据报的完整性。

![image-20200207231300350](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/15.png)

> **AH首部**

(1) 下一个首部(8 位)。标志紧接着本首部的下一个首部的类型（如 TCP 或 UDP）。

(2) 有效载荷长度(8 位)，即鉴别数据字段的长度，以 32 位字为单位。

(3) 安全参数索引 **SPI** (32 位)。标志安全关联，两个计算机进行通讯时的SPI值是固定的。

(4) 序号(32 位)。鉴别数据字段的长度，以32 位字为单位。

(5) 保留(16 位)。为今后用。

(6) 鉴别数据(可变)。为 32 位字的整数倍，它包含了**经数字签名的报文摘要**。因此可用来鉴别源主机和检查 IP 数据报的完整性。

#### 2.5.封装安全有效载荷 ESP

使用 ESP 时，IP 数据报首部的协议字段置为 **50**。当 IP 首部检查到协议字段是 50 时，就知道在 IP 首部后面紧接着的是 ESP 首部，同时在原 IP 数据报后面增加了两个字段，即 ESP 尾部和 ESP 数据。

- **ESP 首部：**里面有标识一个安全关联的安全参数索引 SPI (32 位)，和序号(32 位)。
- **ESP 尾部：**里面有下一个首部（8 位，作用和 AH 首部的一样）。ESP 尾部和原来数据报的数据部分一起进行加密，因此攻击者无法得知所使用的运输层协议。
- **ESP 鉴别：**和 AH 中的鉴别数据是一样的。因此，用 ESP 封装的数据报既有鉴别源站和检查数据报完整性的功能，又能提供保密。

![image-20200207232719822](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/16.png)

#### 2.6.设置本地计算机的IP安全策略

- 在计算机的 "开始" 界面搜索 "本地安全策略"。

![image-20200207115239305](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/17.png)

- 右键 "IP安全策略" 打开菜单，选择 "创建 IP 安全策略"。

![image-20200207115445503](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/18.png)

- 进入 "IP安全策略向导" ，创建一个自定义的 IP安全策略，随后一直 "下一步" 结束向导。

![image-20200207120033791](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/19.png)

![image-20200207120152009](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/20.png)

![image-20200207120247539](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/21.png)

这里的 "激活默认规则" 指的是，当没有指定规则时，使用默认的规则。

![image-20200207120323944](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/22.png)

- 进入自定义IP安全策略的属性界面，去掉默认勾选的 "使用添加向导" 这样可以看到更多的细节，然后点击 "添加"，添加新的IP安全规则。

![image-20200207120926871](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/23.png)

> 进入 "新规则 属性" 界面，在 "IP筛选器列表" 选项中可选择和添加 IP筛选器列表，它的作用是：指定受此新规则影响的网络流量。比如所有的 IP 通讯、所有的 ICMP 通讯等，即设置允许接收从哪里来或到哪里去的数据。

![image-20200207121257916](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/24.png)

- 点击 "添加" 进入 "IP 筛选器列表"界面，自定义IP 筛选器列表。

![image-20200207124730121](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/25.png)

- 去掉默认勾选的 "使用添加向导" 选项，继续点击 "添加" ，进入 "IP 筛选器 属性" 界面。该界面可以设置 IP筛选器 的地址、协议和描述信息。

![image-20200207122229921](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/26.png)

- 在 "地址" 选项卡的 "源地址" 选项中可以设置 与本计算机通信的流量数据中的源地址。

![image-20200207122623280](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/27.png)

- 同样也可以设置目标地址。

![image-20200207122659055](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/28.png)

- 在 "协议" 选项卡中，可以设置通信的协议类型和相应的端口。

![image-20200207122830457](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/29.png)

![image-20200207122843818](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/30.png)

- 在 "描述" 选项卡可给自定义的IP筛选器添加描述。

![image-20200207122959980](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/31.png)

- 编辑完 IP 筛选器属性后，回到 "IP筛选器列表" 可看到刚才添加的IP筛选器。

![image-20200207124912045](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/32.png)

- 点击 "确认" ，回到 "新规则 属性" 界面，可在 "IP 筛选器列表" 中看到刚才自定义的IP筛选器列表。

![image-20200207124948681](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/33.png)

> 在 "筛选器操作" 选项卡中，可以指定如何保障新建的IP筛选器列表的网络流量的安全，即指定在 "IP 筛选器列表" 中设置的允许通行的流量使用的安全方法（AH或ESP等）。同样不使用向导，点击 "添加"，添加筛选器的操作。

![image-20200207145554515](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/34.png)

- 在进入的 "新筛选器操作 属性" 界面中，可以设置对应的安全方法，比如可以无条件阻止或许可之前选定的 IP 筛选列表中的通信流量，也可以在协商安全的情况下进行通信。我们选中 "协商安全" 选项，然后点击 "添加" ，添加对应的安全方法。

![image-20200207150110642](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/35.png)

- 进入 "新增安全方法" 界面，可以看到有两种安全方法，一种为 "完整性和加密"，相当于既使用数字签名也使用共享密钥加密；另一种为 "仅保持完整性"，相当于数字签名。这便是IPSec中的AH协议和ESP协议这两种协议。

![image-20200207150150691](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/36.png)

- 选择 "自定义" 选项，再点击 "设置" ，进入 "自定义安全方法设置" 界面。在该界面中可以选择使用的安全协议AH或者ESP及相应的算法，也可以设置会话密钥生成的间隔（密钥生成时间）：每传输多少数据或每经过多长时间生成新密钥。

![image-20200207150854020](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/37.png)

- 设置完相应的安全方法后回到 "新筛选器操作 属性" 界面， 可以看到刚才自定义的安全方法及相应设置。在界面下方的三个选项中，前两项设置如字面意思，第三项设置意思为新密钥生成之后，以后加密数据都不会再使用旧密钥。随后点击 "应用" 和 "确认" 回到 "新规则 属性" 界面。

![image-20200207152326688](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/38.png)

![image-20200207152720031](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/39.png)

> 在 "身份验证方法" 选项卡中，可以指定通信双方建立信任关系的方法，即验证通信双方的身份。点击 "添加" 进入 "新身份验证方法 属性" 界面。

![image-20200207153533208](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/40.png)

- 在该界面中，可以指定身份验证方法。例如通过设置共享密钥，来实现身份验证。

![image-20200207153647894](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/41.png)

- 设置完成后点击 "确认" 可回到 "新规则 属性" 界面，可看到新增的身份验证方法。

![image-20200207153856786](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/42.png)

> "新规则 属性" 界面的 "隧道设置" 选项卡可设置IPSec隧道相关属性。

![image-20200207154209520](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/43.png)

> "新规则 属性" 界面的 "连接类型" 选项卡可指定使用新规则的连接类型。

![image-20200207154307189](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/44.png)

- 这样便完成了新规则的属性设置，回到自定义IP安全策略的属性界面，可以看到添加的自定义列表。

![image-20200207154549163](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/45.png)

- 点击 "确定"，回到 "本地安全策略" 界面，可看到新增的 "toServer" 安全策略，此时该安全策略还未生效。右键选择 "分配" 可指派该策略，使计算机使用该安全策略进行通信。

![image-20200207155041995](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/46.png)

#### 2.7.仿真练习

![image-20200207160024218](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/47.png)

把本地计算机当作Web服务器，按图中要求设置Web服务器到三台计算机的安全策略，其中计算机XP1的IP地址为192.168.80.101，XP2为192.168.80.102，XP3为192.168.80.103 。

- 设置Web服务器到计算机XP1的安全策略：

  在 "新规则 属性" 界面的 "IP筛选器列表" 中添加新列表，指定通信的目标地址为XP1的IP地址：192.168.80.101 。

  ![image-20200207160540417](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/48.png)

  ![image-20200207160815453](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/49.png)

  在 "IP筛选器列表" 中选中 "toXP1" 的情况下，在 "筛选器操作" 中添加安全方法名称为改为AH。

  ![image-20200207161252422](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/50.png)

  ![image-20200207161513023](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/51.png)

  ![image-20200207161316685](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/52.png)

  在 "IP筛选器列表" 中选中 "toXP1" 和 "筛选器操作" 中选中 "AH"的情况下，在 "身份验证方法" 中添加Web服务器到XP1的身份验证方法：使用共享密钥aaa。

  ![image-20200207161631766](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/53.png)

  ![image-20200207161652255](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/54.png)

  "隧道设置" 和 "连接类型" 两项该例中不用设置，由此完成从Web服务器到XP1安全策略的设置。

- 设置Web服务器到计算机XP2和XP3的安全策略与到XP1的设置同理。最后，Web服务器把到XP1~XP3的安全策略都按要求添加了。

![image-20200207162607923](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/55.png)

- 回到 "本地安全策略" 界面，选中新增的 "toXPS" 安全策略，右键 "分配" ，该安全策略生效，即按要求完成了Web服务器的安全策略设置。

![image-20200207162855522](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/56.png)

设置完之后，当Web服务器与XP1和XP2通信时，使用装包工具抓到的数据包只能看到加密后的数据；当Web服务器与XP3通信时，由于没有加密，所以抓包工具抓到的数据包能看到传输的明文。可在虚拟机中模拟四台计算机进行验证，这里就不展开了。

#### 2.8.关于IP安全规则冲突问题

如下图所示，在IP安全规则中勾选的 "所有 IP 通讯量" 是否与其他勾选的安全规则冲突呢？是不冲突的，选择IP安全规则时采用的是最佳匹配原则。比如：老师说中午12点下课，班干部11：30开完会后可以离开，张三11点就能走，虽然时间不同，但是每个学生都清楚自己几点可以走，这就是最佳匹配。通信时，如果是与XP2通信，那么计算机就采用 "toXP2" 安全规则；与XP3通信，则采用 "toXP3" 安全规则；如果都不是，才采用 "所有 IP 通讯量" 安全规则。

![image-20200207210220402](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.4.Internet%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/57.png)

多抽出1分钟来学习，让你的生命更加精彩！

## 带你简单了解域名系统DNS

### 一、域名简介

#### 1.1.DNS服务的作用

负责解析域名，将域名解析成IP地址。

#### 1.2.域名系统概述

- 由于32位的IP地址并不容易记忆，人们往往喜欢记忆网站的域名。所以当我们访问网站时，是通过输入的域名解析为对应IP地址，对该IP地址进行访问的。
- 名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为**域名服务器**。

#### 1.3.因特网的域名结构

- 因特网采用了**层次树状结构**的命名方法。
- 任何一个连接在因特网上的主机或路由器，都有一个**唯一**的层次结构的名字，即**域名**。
- 域名的结构由标号序列组成，各标号之间用**点**隔开：

![image-20200130223946093](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.2.%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/1.png)

- 上图的各标号：三级域名、二级域名等分别代表不同级别的域名。

#### 1.4.域名只是个逻辑概念

- 域名只是个逻辑概念，并不代表计算机所在的物理地点。
- 变长的域名和使用有助记忆的字符串，是为了便于人来使用。而 IP 地址是定长的 32 位二进制数字则非常便于机器进行处理。

#### 1.5.顶级域名 TLD (Top Level Domain)

- 国家顶级域名 **nTLD**：如: **.cn** 表示中国，**.us** 表示美国，**.uk** 表示英国，等等。

- 通用顶级域名 **gTLD**：最早的顶级域名是：

  **.com** （公司和企业）；

  **.net** （网络服务机构）；

  **.org** （非赢利性组织）；

  **.edu** （美国专用的教育机构）；

  **.gov** （美国专用的政府部门）；

  **.mil** （美国专用的军事部门）；

  **.int** （国际组织）；

  新增的有：

  **.aero** （航空运输企业）；

  **.biz** （公司和企业）；

  **.cat** （加泰隆人的语言和文化团体）；

  **.coop** （合作团体）；

  **.info** （各种情况）；

  **.jobs** （人力资源管理者）；

  **.mobi** （移动产品与服务的用户和提供者）；

  **.museum** （博物馆）；

  **.name** （个人）；

  **.pro** （有证书的专业人员）；

  **.travel** （旅游业）；

- 基础结构域名(infrastructure domain)：这种顶级域名只有一个，即 **arpa**，用于反向域名解析，因此又称为反向域名。

#### 1.6.因特网的域名空间

![image-20200130230206784](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.2.%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/2.png)

比如域名：www.cnblogs.com 。该域名由三部分组成：三级域名www；二级域名cnblogs；顶级域名com；每部分之间用**点**隔开。

需要注意的是：

- 域名也可以由两部分组成、四部分组成，域名组成部分数量是不定的；
- 并非所有的域名都以www开头，也可以使用其他的三级域名比如：mail.cnblogs.com 。只不过按照习惯通常把www作为域名的开头。

#### 1.7.关于域名注册

为了保证域名的唯一性，需要相关机构管理，我们想要申请域名则必须花钱购买。在购买域名时只需要选择相应的顶级域名和二级域名，若这两部分组成的域名全球唯一，那么在此基础上加上三级域名、四级域名组成的域名也都是全球唯一。

比如购买了域名：cnblogs.com，在此域名基础上派生出www.cnblogs.com 、mail.cnblogs.com等都是免费的，只要你有服务器派生出多少个域名都只用缴纳cnblogs.com一个域名的费用。并且由于cnblogs.com的全球唯一性，所以其派生出的域名都是全球唯一的。

![image-20200131145513870](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.2.%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/3.png)

------

### 二、域名服务器

- 域名服务器的作用为，把网站域名解析成对应的IP地址。
- 一个服务器所负责管辖的（或有权限的）范围叫做**区**(zone)。
- 每一个区设置相应的**权限域名服务器**，用来保存该区中的所有主机的域名到IP地址的映射。

#### 2.1.树状结构的 DNS 域名服务器

域名服务器有以下四种类型 :

- 根域名服务器
- 顶级域名服务器
- 权限域名服务器
- 本地域名服务器

关系为：

![image-20200131160847037](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.2.%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/4.png)

> **根域名服务器：**

- 根域名服务器是最重要的域名服务器。根域名服务器并不直接把域名直接转换成 IP 地址，而是存储着所有的顶级域名服务器的域名及其 IP 地址。在使用迭代查询时，根域名服务器把下一步应当查找的顶级域名服务器的 IP 地址告诉本地域名服务器。

- 当本地域名服务器无法解析特定的域名时，首先求助于根域名服务器。

  比如某本地域名服务器负责abc.com区域的域名解析，当本地用户输入abc.cn时，该本地域名服务器无法对其进行解析，于是第一时间求助于根域名服务器，询问负责.cn的顶级域名服务器的IP地址。

- 在因特网上共有13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从a 一直到 m（前13 个字母）。

- 根域名服务器共有 13 套装置，它由分布在世界各地的许多台作为根域名服务器的机器组成。目的是为了方便用户，使世界上大部分 DNS 域名服务器都能**就近**找到一个根域名服务器。

  这些根域名服务器相应的域名分别是：

  a.rootservers.net；

  b.rootservers.net；

  …

  m.rootservers.net；

> **顶级域名服务器（即 TLD 服务器）**

- 这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。

  比如顶级域名服务器.CN负责所有以.CN结尾的域名的解析。

- 当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。

> **权限域名服务器 **

- 负责一个区的域名服务器。

  比如：在顶级域名服务器.com负责下的权限域名服务器abc.com，负责的是所有以abc.com结尾的域名的解析。

- 当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。

  比如：在权限域名服务器abc.com负责下的用户查询域名xyz.com，该权限域名服务器无法告诉客户最终结果，而是告诉客户权限域名服务器xyz.com的IP地址。

> **本地域名服务器（默认域名服务器） **

- 本地域名服务器即在权限域名服务器下的负责更小区域的域名服务器。比如某个大学里面的域名服务器，某公司的域名服务器。
- 当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。
- 可以安装字节的DNS服务器（本地域名服务器）。

#### 2.2.提高域名服务器的可靠性

- DNS 域名服务器都把数据复制到几个域名服务器来保存，其中的一个是**主域名服务器**，其他的是**辅助域名服务器**。
- 当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。
- 主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性。

#### 2.3.域名解析过程举例

![image-20200131171858751](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.2.%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/5.png)

如图：根DNS的IP地址为100，里面存储着顶级域名服务器：com、net、edu、cn等的IP地址；顶级域名服务器com中存储着域名www.baidu.com对应的IP地址；顶级域名服务器net中存储着www.inhe.net对应的IP地址。

当指定DNS服务器IP地址为192的用户输入www.baidu.com域名时，IP地址为192的本地域名服务器没有查询到域名的信息，于是求助于IP地址为101的顶级域名服务器com。经查询，该顶级域名服务器（com）正好存储有该网址对应的IP地址，于是把域名解析出的IP地址告诉本地域名服务器，本地域名服务器再告诉用户。于是用户得以通过IP地址该网站。

当该用户输入www.inhe.net域名时，先在用户指定的本地域名服务器中查询，发现没有该域名的信息。于是本地域名服务器求助于顶级域名服务器com，com也没找到域名信息。于是顶级域名服务器com求助于根DNS服务器，根DNS服务器找到顶级域名服务器net的IP地址并把它告诉com，于是com通过IP地址102找到顶级域名服务器net，net找到www.inhe.net对应的IP地址后再告诉顶级域名服务器com，com再告诉本地域名服务器，本地域名服务器再告诉用户。最后用户得以通过该网站的IP地址访问该网站。

可见，顶级域名服务器com不知道的域名可以求助于根DNS服务器，根DNS服务器会告诉它去哪找相应域名，最后总能得到域名解析结果。所以，只要用户指定了一处DNS服务器，无论是88.88.88.88还是22.22.22.22，能把全球的域名解析出来。

> **总结**

- 主机向本地域名服务器的查询一般都是采用**递归查询**。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。

  递归查询（较少用）：

  ![image-20200131172925759](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.2.%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/6.png)

- 本地域名服务器向根域名服务器的查询通常是采用**迭代查询**。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。

  迭代查询：

  ![image-20200131173003442](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.2.%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/7.png)

> **域名服务器的高速缓存**

- 每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。
- 可大大减轻根域名服务器的负荷，使因特网上的 DNS 查询请求和回答报文的数量大为减少。
- 为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项（例如，每个项目只存放两天）。

#### 2.4.安装自己的DNS服务器

自己的DNS服务器相当于负责区域更小的本地DNS服务器。

> **适用场景**

- 提供内网网站的域名解析服务。

  比如学校内网中可能存在许多的网站，这些网站仅供内部使用，并不在互联网上开放，域名可能与互联网中的部分网站冲突。这时可以再内网中安装一个DNS服务器，提供内网网站的域名解析服务。

  并且内网的DNS服务器也知道互联网中的根域名服务器地址，只要内网DNS服务器能够访问互联网，当内网用户访问外网时也能提供相应的域名解析服务。

- 降低到Internet的域名解析流量。

  即使无内部网站，假如校园内网2000人使用，每人访问百度时都要发送一个数据包给外网的DNS服务器进行域名解析，造成的网络流量是不可忽视的，若安装了内网DNS服务器只要有一个人访问百度，发送了一个数据包给外网的DNS服务器解析出来的IP地址会在内网DNS服务器上缓存一段时间，该段时间内内网的其余用户访问百度时，内网DNS服务器都能直接告诉它们缓存的IP地址，由此节省了重复域名解析造成的大量网络流量。

- 存在域环境。

**查看域名地址**

可通过以下命令在命令行窗口查看域名地址：以搜狐网为例

```undefined
nslookup www.sohu.com
```

![image-20200131222443410](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.2.%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/8.png)

“非权威应答”表示，该域名的解析是借助外网的其他DNS服务器的。

多抽出1分钟来学习，让你的生命更加精彩！