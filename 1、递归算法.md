# 1、[递归算法](https://so.csdn.net/so/search?q=递归算法&spm=1001.2101.3001.7020)

### 1.1 算法策略

递归算法是一种直接或者间接调用自身函数或者方法的算法。

递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后[递归调用](https://so.csdn.net/so/search?q=递归调用&spm=1001.2101.3001.7020)方法来表示问题的解。递归算法对解决一大类问题很有效，它可以使算法简洁和易于理解。

**优缺点：**

- 优点：实现简单易上手
- 缺点：递归算法对常用的算法如普通循环等，运行效率较低；并且在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归太深，容易发生栈溢出。

### 1.2 适用场景

递归算法一般用于解决三类问题：

- 数据的定义是按递归定义的。（斐波那契数列）
- 问题解法按递归算法实现。（回溯）
- 数据的结构形式是按递归定义的。（树的遍历，图的搜索）

**递归的解题策略：**

- 第一步：明确你这个函数的输入输出，先不管函数里面的代码什么，而是要先明白，你这个函数的输入是什么，输出为何什么，功能是什么，要完成什么样的一件事。
- 第二步：寻找递归结束条件，我们需要找出什么时候递归结束，之后直接把结果返回
- 第三步：明确递归关系式，怎么通过各种递归调用来组合解决当前问题

### 1.3 使用递归算法求解的一些经典问题

- 斐波那契数列
- 汉诺塔问题
- 树的遍历及相关操作

[DOM树](https://so.csdn.net/so/search?q=DOM树&spm=1001.2101.3001.7020)为例

下面以以 DOM 🌲为例，实现一个 `document.getElementById` 功能

由于DOM是一棵树，而树的定义本身就是用的递归定义，所以用递归的方法处理树，会非常地简单自然。

**第一步：明确你这个函数的输入输出**

从 DOM 🌲根节点一层层往下递归，判断当前节点的 id 是否是我们要寻找的 `id='d-cal'`

输入：DOM 🌲根节点 `document` ，我们要寻找的 `id='d-cal'`

输出：返回满足 `id='sisteran'` 的子结点

```php
function getElementById(node, id){}复制代码
```

**第二步：寻找递归结束条件**

从document开始往下找，对所有子结点递归查找他们的子结点，一层一层地往下查找：

- 如果当前结点的 id 符合查找条件，则返回当前结点
- 如果已经到了叶子结点了还没有找到，则返回 null

```cobol
function getElementById(node, id){    // 当前结点不存在，已经到了叶子结点了还没有找到，返回 null    if(!node) return null    // 当前结点的 id 符合查找条件，返回当前结点    if(node.id === id) return node}复制代码
```

**第三步：明确递归关系式**

当前结点的 id 不符合查找条件，递归查找它的每一个子结点

```cobol
function getElementById(node, id){    // 当前结点不存在，已经到了叶子结点了还没有找到，返回 null    if(!node) return null    // 当前结点的 id 符合查找条件，返回当前结点    if(node.id === id) return node    // 前结点的 id 不符合查找条件，继续查找它的每一个子结点    for(var i = 0; i < node.childNodes.length; i++){        // 递归查找它的每一个子结点        var found = getElementById(node.childNodes[i], id);        if(found) return found;    }    return null;}复制代码
```

就这样，我们的一个 `document.getElementById` 功能已经实现了：

```cobol
function getElementById(node, id){    if(!node) return null;    if(node.id === id) return node;    for(var i = 0; i < node.childNodes.length; i++){        var found = getElementById(node.childNodes[i], id);        if(found) return found;    }    return null;}getElementById(document, "d-cal");复制代码
```

使用递归的优点是代码简单易懂，缺点是效率比不上非递归的实现。Chrome浏览器的查DOM是使用非递归实现。非递归要怎么实现呢？如下代码：

```cobol
function getByElementId(node, id){    //遍历所有的Node    while(node){        if(node.id === id) return node;        node = nextElement(node);    }    return null;}复制代码
```

还是依次遍历所有的 `DOM` 结点，只是这一次改成一个 `while` 循环，函数 `nextElement` 负责找到下一个结点。所以关键在于这个 `nextElement` 如何实现非递归查找结点功能：

```cobol
// 深度遍历function nextElement(node){    // 先判断是否有子结点    if(node.children.length) {        // 有则返回第一个子结点        return node.children[0];    }    // 再判断是否有相邻结点    if(node.nextElementSibling){        // 有则返回它的下一个相邻结点        return node.nextElementSibling;    }    // 否则，往上返回它的父结点的下一个相邻元素，相当于上面递归实现里面的for循环的i加1    while(node.parentNode){        if(node.parentNode.nextElementSibling) {            return node.parentNode.nextElementSibling;        }        node = node.parentNode;    }    return null;}复制代码
```

在控制台里面运行这段代码，同样也可以正确地输出结果。不管是非递归还是递归，它们都是深度优先遍历。 实际上 getElementById 浏览器是用的一个哈希 map 存储的，根据 id 直接映射到 DOM 结点，而 getElementsByClassName 就是用的这样的非递归查找。

## 2 分治算法

### 2.1 算法策略

在计算机科学中，分治算法是一个很重要的算法，快速排序、归并排序等都是基于分治策略进行实现的，所以，建议理解掌握它。

分治，顾名思义，就是 **分而治之** ，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为阿子问题解的合并。

### 2.2 适用场景

当出现满足以下条件的问题，可以尝试只用分治策略进行求解：

- 原始问题可以分成多个相似的子问题
- 子问题可以很简单的求解
- 原始问题的解是子问题解的合并
- 各个子问题是相互独立的，不包含相同的子问题

**分治的解题策略：**

- 第一步：分解，将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
- 第二步：解决，解决各个子问题
- 第三步：合并，将各个子问题的解合并为原问题的解

### 2.3 **使用分治法求解的一些经典问题**

- 二分查找
- 归并排序
- 快速排序
- 汉诺塔问题
- React 时间分片

二分查找

也称折半查找算法，它是一种简单易懂的快速查找算法。例如我随机写0-100之间的一个数字，让你猜我写的是什么？你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止。

**第一步：分解**

每次猜拳都把上一次的结果分出大的一组和小的一组，两组相互独立

- 选择数组中的中间数

```cobol
function binarySearch(items, item) {    // low、mid、high将数组分成两组    var low = 0,        high = items.length - 1,        mid = Math.floor((low+high)/2),        elem = items[mid]    // ...}复制代码
```

**第二步：解决子问题**

查找数与中间数对比

- 比中间数低，则去中间数左边的子数组中寻找；
- 比中间数高，则去中间数右边的子数组中寻找；
- 相等则返回查找成功

```cobol
while(low <= high) { if(elem < item) { // 比中间数高  low = mid + 1 } else if(elem > item) { // 比中间数低  high = mid - 1 } else { // 相等     return mid }}复制代码
```

**第三步：合并**

```cobol
function binarySearch(items, item) {    var low = 0,        high = items.length - 1,        mid, elem    while(low <= high) {        mid = Math.floor((low+high)/2)        elem = items[mid]        if(elem < item) {            low = mid + 1        } else if(elem > item) {            high = mid - 1        } else {            return mid        }    }    return -1}复制代码
```

最后，二分法只能应用于数组有序的情况，如果数组无序，二分查找就不能起作用了

```cobol
function binarySearch(items, item) {    // 快排    quickSort(items)    var low = 0,        high = items.length - 1,        mid, elem    while(low <= high) {        mid = Math.floor((low+high)/2)        elem = items[mid]        if(elem < item) {            low = mid + 1        } else if(elem > item) {            high = mid - 1        } else {            return mid        }    }    return -1} // 测试var arr = [2,3,1,4]binarySearch(arr, 3)// 2 binarySearch(arr, 5)// -1复制代码
```

## 3 贪心算法

### 3.1 算法策略

贪心算法，故名思义，总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择。

某种意义上说，贪心算法是很贪婪、很目光短浅的，它不从整体考虑，仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。

### 3.2 适用场景

在日常生活中，我们使用到贪心算法的时候还是挺多的，例如：

从100章面值不等的钞票中，抽出 10 张，怎样才能获得最多的价值？

我们只需要每次都选择剩下的钞票中最大的面值，最后一定拿到的就是最优解，这就是使用的贪心算法，并且最后得到了整体最优解。

但是，我们任然需要明确的是，期望通过局部的最优选择获得整体的最优选择，仅仅是期望而已，也可能最终得到的结果并不一定不能是整体最优解。

那么一般在什么时候可以尝试选择使用贪心算法喃？

当满足一下条件时，可以使用：

- 原问题复杂度过高
- 求全局最优解的数学模型难以建立或计算量过大
- 没有太大必要一定要求出全局最优解，“比较优”就可以

如果使用贪心算法求最优解，可以按照以下 **步骤求解** ：

- 首先，我们需要明确什么是最优解（期望）
- 然后，把问题分成多个步骤，每一步都需要满足：
- 可行性：每一步都满足问题的约束
- 局部最优：每一步都做出一个局部最优的选择
- 不可取消：选择一旦做出，在后面遇到任何情况都不可取消
- 最后，叠加所有步骤的最优解，就是全局最优解

### 3.3 经典案例：活动选择问题

使用贪心算法求解的经典问题有：

- 最小生成树算法
- 单源最短路径的 Dijkstra 算法
- Huffman 压缩编码
- 背包问题
- 活动选择问题等

## 4 回溯算法

### 4.1 算法策略

回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。

### 4.2 适用场景

回溯算法很简单，它就是不断的尝试，直到拿到解。它的这种算法思想，使它通常用于解决广度的搜索问题，即从一组可能的解中，选择一个满足要求的解。

### 4.3 使用回溯算法的经典案例

- 深度优先搜索
- 0-1背包问题
- 正则表达式匹配
- 八皇后
- 数独
- 全排列

等等，深度优先搜索我们在图那一章已经介绍过，这里以正则表达式匹配为例，介绍一下

正则表达式匹配

> var string = "abbc"
>
> var regex = /ab{1,3}c/
>
> console.log( string.match(regex) )
>
> // ["abbc", index: 0, input: "abbc", groups: undefined]

它的匹配过程：

![img](https://img-blog.csdnimg.cn/img_convert/15543bf081c4b5fcebf3a1a4fdea4e09.webp?x-oss-process=image/format,png)

在第 5 步匹配失败，此时 `b{1,3}` 已经匹配到了两个 `b` 正在尝试第三个 `b` ，结果发现接下来是 `c` 。此时就需要回溯到上一步， `b{1,3}` 匹配完毕（匹配到了 `bb` ），然后再匹配 `c` ，匹配到了 `c` 匹配结束。

## 5 动态规划

### 5.1 算法策略

动态规划也是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。

所以，动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，在这种情况下，分治策略会做出很多不必要的工作，它会反复求解那些公共子子问题，而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到一致的问题，从表格中获取既可，所以它无需求解每一个子子问题，避免了大量的不必要操作。

### 5.2 适用场景

动态规划适用于求解最优解问题，比如，从面额不定的100个硬币中任意选取多个凑成10元，求怎样选取硬币才可以使最后选取的硬币数最少又刚好凑够了10元。这就是一个典型的动态规划问题。它可以分成一个个子问题（每次选取硬币），每个子问题又有公共的子子问题（选取硬币），子问题之间相互关联（已选取的硬币总金额不能超过10元），边界条件就是最终选取的硬币总金额为 10 元。

针对上例，也许你也可以说，我们可以使用回溯算法，不断的去试探，但回溯算法是使用与求解广度的解（满足要求的解），如果是用回溯算法，我们需要尝试去找所有满足条件的解，然后找到最优解，时间复杂度为 O(2^n^) ，这性能是相当差的。大多数适用于动态规划的问题，都可以使用回溯算法，只是使用回溯算法的时间复杂度比较高而已。

最后，总结一下，我们使用动态规划求解问题时，需要遵循以下几个重要步骤：

- 定义子问题
- 实现需要反复执行解决的子子问题部分
- 识别并求解出边界条件

### 5.3 使用动态规划求解的一些经典问题

- 爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
- 背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值
- 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案
- 图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径
- 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）

这里以最长公共子序列为例。

爬楼梯问题

这里以动态规划经典问题爬楼梯问题为例，介绍求解动态规划问题的步骤。

**第一步：定义子问题**

如果用 `dp[n]` 表示第 `n` 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 `n` 级台阶的方案数等于第 `n-1` 级台阶的方案数加上第 `n-2` 级台阶的方案数

**第二步：实现需要反复执行解决的子子问题部分**

```cobol
dp[n] = dp[n−1] + dp[n−2]复制代码
```

**第三步：识别并求解出边界条件**

```cobol
// 第 0 级 1 种方案 dp[0]=1 // 第 1 级也是 1 种方案 dp[1]=1复制代码
```

**最后一步：把尾码翻译成代码，处理一些边界情况**

```cobol
let climbStairs = function(n) {    let dp = [1, 1]    for(let i = 2; i <= n; i++) {        dp[i] = dp[i - 1] + dp[i - 2]    }    return dp[n]}复制代码
```

**复杂度分析：**

- 时间复杂度：O(n)
- 空间复杂度：O(n)

**优化空间复杂度：**

```cobol
let climbStairs = function(n) {    let res = 1, n1 = 1, n2 = 1    for(let i = 2; i <= n; i++) {        res = n1 + n2        n1 = n2        n2 = res    }    return res}复制代码
```

空间复杂度：O(1)

## 6 枚举算法

### 6.1 算法策略

枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的。

### 6.2 解题思路

- 确定枚举对象、枚举范围和判定条件。
- 逐一列举可能的解，验证每个解是否是问题的解。

# 总结

算法是编程的"里子"，不管你是前端还是后端，作为一名计算机工程师，具备一定的算法能力，是一种基本要求。

## 一、回溯思想简介

回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。
 **解决一个回溯问题，实际上就是一个决策树的遍历过程**，一般来说我们需要解决三个问题：
 1、路径：也就是已经做出的选择。
 2、选择列表：也就是你当前可以做的选择。
 3、结束条件：也就是到达决策树底层，无法再做选择的条件。
 回溯算法模板：**在递归之前做选择，在递归之后撤销选择**

```scss
function backtrack (路径，选择列表){
    if(满足结束条件){
        result.add(结果);
    }
    for(选择：选择列表){
        做出选择;
        backtrack(路径，选择列表);
        撤销选择;
    }
}
复制代码
```

## 二、剪枝

上面说到回溯算法就像一颗N叉树，底下有很多的子节点（树枝），比如我们将一个数组从小到大排序后,第二个数已经大于要求的结果，那么它后面的数一定也大于要求结果，所以没必要再往下进行遍历，直接剪掉这个枝（跳出循环），进行下一轮搜索。所以一般回溯算法离不开剪枝，搜索问题一般复杂度较高，能剪枝就尽量需要剪枝。把候选数组排个序。

## 三、例题解释

### [39、组合总和](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fcombination-sum%2F)

**思路：**
 由题意可知：原数组元素不重复，寻找一个符合条件的组合 且原数组的单个元素可以重复使用 只要结果中的子组合互不相同即可
 **题解：**
 且原数组的单个元素可以重复使用：a、意味着下一个for循环中的元素选取，要从前一个元素开始，因为可以重复使用，不然如果跟着for的自增变量i走，会漏掉可能解 b、将自增变量i传递下去
 终止条件：target 一一减去符合组合的元素，最终为 0 ，才是一个符合题意的组合 

![图片](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/14/172b1a8c51e6ce09~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



```ini
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
    let n = candidates.length;
    let res = [];
    let temp = [];
    candidates = candidates.sort((a, b) => a - b); // 先从小到大排序
    let help = (temp, target, start) => {
        if (target === 0) { // 终止条件
            res.push(temp);
            return;
        }
        for (let i = start; i < n; i++) {
            if (target < candidates[i]) break; // 剪枝操作
            temp.push(candidates[i]);
            help(temp.slice(),target - candidates[i],i);
            temp.pop(); // 撤销选择
        }
    }
    help(temp, target, 0);
    return res;
};
复制代码
```

### [40、组合总和II](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fcombination-sum-ii%2F)

对于本题来说，它相对于39. 组合总和的不同之处在于数组 candidates会存在相同的数字，如果存在相同的数字，我们就可能会出一下重复的组合，例如： 

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/14/172b1c0574001d38~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

 以上，情况一与情况二是相同的情况，那我们要如何去避免的，之后就需要一个剪枝操作。一般对于像数组类的问题，在剪枝之前我们都需要对数据进行排序，排好序方便我们对数组按照顺序来进行剪枝。这里上面数组排好序为:[1,2,2,2,5]。



之前选择过的不用再去选择 这说明第一次我们的选择列表是**[1,2,2,2,5],那第二次我们的选择列表就应该是[2,2,2,5]**。

第二个操作为：

如果以当前结点为头结点的所有组合都找完了，那么下一个与他他相同的头结点就不用去找了。

```ini
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
    let n = candidates.length;
    let res = [];
    let temp = [];
    candidates = candidates.sort((a, b) => a - b);
    function help(temp, target, start) {
        if(target === 0){
            res.push(temp);
            return;
        }
        for (let i = start; i < n; i ++) {
            if(target < candidates[i]) break; // 剪枝操作
            if(i > start && candidates[i-1] === candidates[i]) continue; // 当前元素不能重复使用
            temp.push(candidates[i]);
            help(temp.slice(),target - candidates[i],i + 1); // 区别：进行+1
            temp.pop();
        }
    }
    help(temp, target, 0);
    return res;
};
复制代码
```

### [46、全排列](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fpermutations%2F)

```ini
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const res = [];
    const paths = [];

    function backtrack(paths, selections) {
        if (paths.length === nums.length) {
            res.push(paths.slice())；
            return
        }
        for (let selection of selections) {
        // 组合和全排列的区别是遇到当前已有的continue进行下一个循环
            if (paths.includes(selection)) continue;
            paths.push(selection);
            backtrack(paths, selections);
            paths.pop();
        }
    }
    backtrack(paths, nums);
    return res;
};
复制代码
```

### [51、N皇后](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fn-queens%2F)

这是一道比较经典的回溯 + 剪枝操作的题目，已经出现在字节跳动和腾讯的面试中，下面介绍下思路： 循环扫荡每一行，然后遍历每一列，要满足同一列，撇，捺方向上没有皇后，满足条件就给数组第n行push一个列的位置，生成一个[1, 3, 0, 2]这样一个皇后位置的数组，最后用'.'和'Q'填充成一个二维数组。
 这里一个难点是怎么判断列、撇、捺上面有没有放置皇后，通过观察我们可以发现列直接判断纵坐标的点是否相等就可以。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/17/1735c5df8007a31f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

 通过观察我们发现撇上的皇后满足：x1 - y1 = y2 - x2



```ini
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
    // 回溯 + 剪枝
    let res = [];
    dfs();
    function dfs(sub = [], row = 0) {
        if (row === n) {
            // sub: [1, 3, 0 2]
            res.push(sub.map(i => '.'.repeat(i) + 'Q' + '.'.repeat(n - i - 1)));
        }
        // 遍历每一行
        for (let i = 0; i < n; i++) {
            // 坐标点为(row, i)表示这个点是否可以放皇后
            // v: 列，j: 行
            // sub里面是皇后的坐标 sub: [1, 3, 0 2]
            if (!sub.some((v, j) => (
                // 列
                v === i
                // 撇
                || row - v === j - i
                // 捺
                || j - row === v - i))) {
                    sub.push(i);
                    dfs(sub, row + 1);
                    sub.pop();
            }
        }
    }
    return res;
};
复制代码
```

以上就是回溯算法的简单介绍了，大家多进行一些定向练习：[回溯算法](https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Ftag%2Fbacktracking%2F)



作者：Kevin_St
链接：https://juejin.cn/post/6844904190842503176
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 1. 声明和初始化数组

我们可以使用默认值（如""、null或 ）初始化特定大小的数组0。您可能已经将这些用于一维数组，但如何初始化二维数组/矩阵呢？

```scss
const array = Array(5).fill(''); 
// 输出
(5) ["", "", "", "", ""]

const matrix = Array(5).fill(0).map(()=>Array(5).fill(0)); 
// 输出
(5) [Array(5), Array(5), Array(5), Array(5), Array(5)]
0: (5) [0, 0, 0, 0, 0]
1: (5) [0, 0, 0, 0, 0]
2: (5) [0, 0, 0, 0, 0]
3: (5) [0, 0, 0, 0, 0]
4: (5) [0, 0, 0, 0, 0]
length: 5
复制代码
```

## 2. 找出总和、最小值和最大值

我们应该利用`reduce`方法来快速找到基本的数学运算。

```ini
const array  = [5,4,7,8,9,2];
复制代码
```

- 和

```css
array.reduce((a,b) => a+b);
// 输出: 35
复制代码
```

- 最大限度

```css
array.reduce((a,b) => a>b?a:b);
// 输出: 9
复制代码
```

- 最小

```css
array.reduce((a,b) => a<b?a:b);
// 输出: 2
复制代码
```

## 3. 对字符串、数字或对象数组进行排序

我们有内置的方法`sort()`和`reverse()`用于对字符串进行排序，但是数字或对象数组呢？

让我们看看数字和对象的升序和降序排序技巧。

- 排序字符串数组

```scss
const stringArr = ["Joe", "Kapil", "Steve", "Musk"]
stringArr.sort();
// 输出
(4) ["Joe", "Kapil", "Musk", "Steve"]

stringArr.reverse();
// 输出
(4) ["Steve", "Musk", "Kapil", "Joe"]
复制代码
```

- 排序数字数组

```css
const array  = [40, 100, 1, 5, 25, 10];
array.sort((a,b) => a-b);
// 输出
(6) [1, 5, 10, 25, 40, 100]

array.sort((a,b) => b-a);
// 输出
(6) [100, 40, 25, 10, 5, 1]
复制代码
```

- 对象数组排序

```css
const objectArr = [     { first_name: 'Lazslo', last_name: 'Jamf'     },    { first_name: 'Pig',    last_name: 'Bodine'   },    { first_name: 'Pirate', last_name: 'Prentice' }];
objectArr.sort((a, b) => a.last_name.localeCompare(b.last_name));
// 输出
(3) [{…}, {…}, {…}]
0: {first_name: "Pig", last_name: "Bodine"}
1: {first_name: "Lazslo", last_name: "Jamf"}
2: {first_name: "Pirate", last_name: "Prentice"}
length: 3
复制代码
```

## 4. 从数组中过滤出虚假值

Falsy值喜欢`0`，`undefined`，`null`，`false`，`""`，`''`可以很容易地通过以下方法省略

```ini
const array = [3, 0, 6, 7, '', false];
array.filter(Boolean);
// 输出
(3) [3, 6, 7]
复制代码
```

## 5. 对各种条件使用逻辑运算符

如果你想减少嵌套 if…else 或 switch case，你可以简单地使用基本的逻辑运算符`AND/OR`。

```ini
function doSomething(arg1){ 
    arg1 = arg1 || 10; 
// 如果尚未设置，则将 arg1 设置为 10 作为默认值
return arg1;
}

let foo = 10;  
foo === 10 && doSomething(); 
// is the same thing as if (foo == 10) then doSomething();
// 输出: 10

foo === 5 || doSomething();
// is the same thing as if (foo != 5) then doSomething();
// 输出: 10
复制代码
```

## 6. 删除重复值

您可能已经将 `indexOf()` 与 for 循环一起使用，该循环返回第一个找到的索引或较新的 `includes()` 从数组中返回布尔值 true/false 以找出/删除重复项。 这是我们有两种更快的方法。

```ini
const array  = [5,4,7,8,9,2,7,5];
array.filter((item,idx,arr) => arr.indexOf(item) === idx);
// or
const nonUnique = [...new Set(array)];
// 输出: [5, 4, 7, 8, 9, 2]
复制代码
```

## 7. 创建计数器对象或映射

大多数情况下，需要通过创建计数器对象或映射来解决问题，该对象或映射将变量作为键进行跟踪，并将其频率/出现次数作为值进行跟踪。

```csharp
let string = 'kapilalipak';

const table={}; 
for(let char of string) {
  table[char]=table[char]+1 || 1;
}
// 输出
{k: 2, a: 3, p: 2, i: 2, l: 2}
复制代码
```

和

```dart
const countMap = new Map();
  for (let i = 0; i < string.length; i++) {
    if (countMap.has(string[i])) {
      countMap.set(string[i], countMap.get(string[i]) + 1);
    } else {
      countMap.set(string[i], 1);
    }
  }
// 输出
Map(5) {"k" => 2, "a" => 3, "p" => 2, "i" => 2, "l" => 2}
复制代码
```

## 8. 三元运算符很酷

您可以避免使用三元运算符嵌套条件 if…elseif…elseif。

```scss
function Fever(temp) {
    return temp > 97 ? 'Visit Doctor!'
      : temp < 97 ? 'Go Out and Play!!'
      : temp === 97 ? 'Take Some Rest!';
}

// 输出
Fever(97): "Take Some Rest!" 
Fever(100): "Visit Doctor!"
复制代码
```

## 9. 与旧版相比，for 循环更快

- `for`并`for..in`默认为您提供索引，但您可以使用 arr[index]。
- `for..in` 也接受非数字，所以避免它。
- `forEach`,`for...of`直接获取元素。
- `forEach`也可以为您提供索引，但`for...of`不能。
- `for`并`for...of`考虑阵列中的孔，但其他 2 个不考虑。

## 10.合并2个对象

通常我们需要在日常任务中合并多个对象。

```vbnet
const user = { 
 name: 'Kapil Raghuwanshi', 
 gender: 'Male' 
 };
const college = { 
 primary: 'Mani Primary School', 
 secondary: 'Lass Secondary School' 
 };
const skills = { 
 programming: 'Extreme', 
 swimming: 'Average', 
 sleeping: 'Pro' 
 };

const summary = {...user, ...college, ...skills};

// 输出
gender: "Male"
name: "Kapil Raghuwanshi"
primary: "Mani Primary School"
programming: "Extreme"
secondary: "Lass Secondary School"
sleeping: "Pro"
swimming: "Average"
复制代码
```

## 11. 箭头函数

箭头函数表达式是传统函数表达式的紧凑替代品，但有局限性，不能在所有情况下使用。由于它们具有词法范围（父范围）并且没有自己的范围`this`，`arguments`因此它们指的是定义它们的环境。

```javascript
const person = {
name: 'Kapil',
sayName() {
    return this.name;
    }
}
person.sayName();
// 输出
"Kapil"
复制代码
```

但

```kotlin
const person = {
name: 'Kapil',
sayName : () => {
    return this.name;
    }
}
person.sayName();
// 输出
""
复制代码
```

## 12. 可选链

可选的链接 ?.如果值在 ? 之前，则停止评估。为 undefined 或 null 并返回

```javascript
undefined。
const user = {
  employee: {
    name: "Kapil"
  }
};
user.employee?.name;
// 输出: "Kapil"
user.employ?.name;
// 输出: undefined
user.employ.name
// 输出: VM21616:1 Uncaught TypeError: Cannot read property 'name' of undefined
复制代码
```

## 13. 打乱数组

利用内置`Math.random()`方法。

```scss
const list = [1, 2, 3, 4, 5, 6, 7, 8, 9];
list.sort(() => {
    return Math.random() - 0.5;
});
// 输出
(9) [2, 5, 1, 6, 9, 8, 4, 3, 7]
// Call it again
(9) [4, 1, 7, 5, 3, 8, 2, 9, 6]
复制代码
```

## 14. 空合并算子

空合并运算符 (??) 是一个逻辑运算符，当其左侧操作数为空或未定义时返回其右侧操作数，否则返回其左侧操作数。

```ini
const foo = null ?? 'my school';
// 输出: "my school"

const baz = 0 ?? 42;
// 输出: 0
复制代码
```

## 15. Rest & Spread 运算符

那些神秘的3点`...`可以休息或传播！🤓

```javascript
function myFun(a,  b, ...manyMoreArgs) {
   return arguments.length;
}
myFun("one", "two", "three", "four", "five", "six");

// 输出: 6
复制代码
```

和

```scss
const parts = ['shoulders', 'knees']; 
const lyrics = ['head', ...parts, 'and', 'toes']; 

lyrics;
// 输出: 
(5) ["head", "shoulders", "knees", "and", "toes"]
复制代码
```

## 16. 默认参数

```ini
const search = (arr, low=0,high=arr.length-1) => {
    return high;
}
search([1,2,3,4,5]);

// 输出: 4
复制代码
```

## 17. 将十进制转换为二进制或十六进制

在解决问题的同时，我们可以使用一些内置的方法，例如`.toPrecision()`或`.toFixed()`来实现许多帮助功能。

```vbscript
const num = 10;

num.toString(2);
// 输出: "1010"
num.toString(16);
// 输出: "a"
num.toString(8);
// 输出: "12"
复制代码
```

## 18. 使用解构简单交换两值

```ini
let a = 5;
let b = 8;
[a,b] = [b,a]

[a,b]
// 输出
(2) [8, 5]
复制代码
```

## 19. 单行回文检查

嗯，这不是一个整体的速记技巧，但它会让你清楚地了解如何使用弦乐。

```lua
function checkPalindrome(str) {
  return str == str.split('').reverse().join('');
}
checkPalindrome('naman');
// 输出: true
复制代码
```

## 20.将Object属性转成属性数组

```less
使用Object.entries(),Object.keys()和Object.values()
const obj = { a: 1, b: 2, c: 3 };

Object.entries(obj);
// 输出
(3) [Array(2), Array(2), Array(2)]
0: (2) ["a", 1]
1: (2) ["b", 2]
2: (2) ["c", 3]
length: 3

Object.keys(obj);
(3) ["a", "b", "c"]

Object.values(obj);
(3) [1, 2, 3]
复制代码
```

[点击关注，第一时间了解华为云新](https://link.juejin.cn/?target=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%3Futm_source%3Djuejin%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent)



作者：华为云开发者联盟
链接：https://juejin.cn/post/7068853819135754253
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 概念

1. **分治算法**不是简单的递归，而是`将大的问题递归解决较小的问题`，然后从子问题的解构建原问题的解。

比如，快速排序和归并排序算分治算法，及 `MapReduce` 也是利用了分治思想，而图的递归深度搜索和二叉树的递归遍历则不是分治算法的运用。

1. **回溯算法**相当于`穷举搜索`的巧妙实现，对比蛮力的穷举搜索，回溯算法可以对一些不符合要求的或者是重复的情况进行裁剪，不再对其进行搜索，以减少搜索的工作量提高效率。

比如，在图运用回溯算法的深度优先搜索遍历中，会对已搜索遍历过的顶点进行标记，避免下次的回溯搜索中对再次出现的该顶点进行重复遍历。

1. **动态规划**与分治算法的区别是，两种算法同样是`将较大的问题分解成较小问题`，而动态规划对这些较小的问题并不是对原问题明晰的分割，其中一部分是被重复求解的，

因此动态规划`将较小问题的解记录下来`，使得在处理较大问题的时候，可以不用重复去处理较小的问题，而是直接利用所记录的较小问题的答案来求解。

1. **贪心算法**每次的选择都是`局部最优`，当在算法结束的时候，其期望是全局最优才是正确的。

不过有时，在不同条件与要求下时，最优解的答案可能不止有一个或不一样，而贪婪算法也可以得出一个近似的答案。

**几者之间的关系**：

- 递归是`实现手段`，分治策略是`解决问题的思想`，递归只是实现分治思想的其中一种手段。
- 用动态规划能解决的问题分治策略肯定能解决，只是运行时间较长。
- 分治策略一般用来解决`子问题相互对立`的问题，称为标准分治，而动态规划用来解决`子问题重叠`的问题。动态规划则会`保存以前的运算结果`。
- 贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类, 前三个算法可以抽象成多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。
- 基本上能用到动态规划、贪心解决的问题，都可以用回溯算法解决。回溯算法相当于穷举搜索。回溯算法的时间复杂度非常高，是指数级别的。适合解决小规模数据的问题。
- 能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。
- 贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，需要满足三个条件，最优子结构、无后效性和贪心选择性。



![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728f224fc3acaae~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



### 分治

分治算法的递归实现中，每一层递归都会涉及这样三个操作：

- 分解：将原问题分解成一系列子问题；
- 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
- 合并：将子问题的结果合并成原问题。

#### 求一组数据的逆序对个数

**有序度**来表示一组数据的有序程度，**逆序度**表示一组数据的无序程度。

假设有 n 个数据，期望数据从小到大排列，那完全有序的数据的有序度就是 `n(n-1)/2`，逆序度等于 `0`； 相反，倒序排列的数据的有序度就是 `0`，逆序度是`n(n-1)/2` 。除了这两种极端情况外，通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。



![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728f1c31ece266b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。

解法一：

拿每个数字跟它后面的数字比较，看有几个比它小的。把比它小的数字个数记作 k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。

时间复杂度是`O(n^2)`。

解法二：

套用分治的思想来求数组 A 的逆序对个数。可以将数组分成前后两半 `A1` 和 `A2`，分别计算 `A1` 和 `A2` 的逆序对个数 `K1` 和 `K2`， 然后再计算 `A1` 与 `A2` 之间的逆序对个数 `K3`。那数组 A 的逆序对个数就等于 `K1 + K2 + K3`。

时间复杂度`O(nlogn)`，空间复杂度`O(n)`

```scss
function reverseDegree(arr) {
  return mergeSortCounting(arr, 0, arr.length - 1, [])
}

function mergeSortCounting(arr, left, right, tmp) {
  if (left >= right) return 0

  let mid = Math.floor((left + right) / 2)
  let l = mergeSortCounting(arr, left, mid, tmp)
  let r = mergeSortCounting(arr, mid + 1, right, tmp)
  let m = merge(arr, left, mid, right, tmp)
  return l + m + r
}

function merge(arr, l, m, r, tmp) {
  let count = 0
  let i = l, j = m + 1, k = 0

  while (i <= m && j <= r) {
    if (arr[i] <= arr[j]) {
      tmp[k++] = arr[i++]
    } else {
      count += (m - i + 1)   //统计 l到m 之间，比 a[j] 大的元素个数
      tmp[k++] = arr[j++]
    }
  }
  while (i <= m) {  //处理剩下的
    tmp[k++] = arr[i++]
  }
  while (j <= r) {  //处理剩下的
    tmp[k++] = arr[j++]
  }
  for (i = 0; i < r - m; ++i) {  // 从tmp拷回arr
    arr[l + i] = tmp[i]
  }
  return count
}

console.log(reverseDegree([2, 4, 3, 1, 5, 6]))
//4
复制代码
```

### 回溯

从解决问题每一步的所有可能选项里系统选择出一个可行的解决方案。

在某一步选择一个选项后，进入下一步，然后面临新的选项。重复选择，直至达到最终状态。

回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。

回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，并不需要穷举搜索所有的情况，从而提高搜索效率。

#### 0-1背包

0-1 背包是非常经典的算法问题，很多场景都可以抽象成这个问题模型。这个问题的经典解法是动态规划，不过还有一种简单但没有那么高效的解法，那就是回溯算法。

0-1 背包问题有很多变体，这里介绍一种比较基础的。有一个背包，背包总的承载重量是 W。现在有 n 个物品，每个物品的重量不等，并且不可分割。 现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？

可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。

```scss
let maxW = 0
/**
 * @param i 考察到哪个物品了
 * @param curW 当前已经装进去的物品重量和
 * @param weight 物品重量数组
 * @param n  物品个数
 * @param w  背包可承载重量
 */
function knapsack(i, curW, weight, n, w) {
  if (curW === w || i === n) {
    if (curW > maxW) {
      maxW = curW
    }
    return
  }
  knapsack(i + 1, curW, weight, n, w) //选择不装第i个物品
  if (curW + weight[i] <= w) {
    knapsack(i + 1, curW + weight[i], weight, n, w) //选择装第i个物品
  }
}

const a = [2, 2, 4, 6, 3]
knapsack(0, 0, a, 5, 9)
console.log(maxW)
//9
复制代码
```

#### n皇后

n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。八皇后问题就是期望找到所有满足这种要求的放棋子方式。

步骤：

1. 把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。
2. 在放置的过程中，不停地检查当前的方法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种方法，继续尝试。

```sql
let counter = 0

function calcQueens(row, result = []) {
  if (row === 8) {
    counter++
    console.log('第' + counter + '种：')
    printQueens(result)
    console.log('-----------------------')
    return
  }
  for (let col = 0; col < 8; ++col) {
    if (isOk(row, col, result)) {
      result[row] = col
      calcQueens(row + 1, result)
    }
  }
}

function isOk(row, col, result) {
  let leftup = col - 1
  let rightup = col + 1
  for (let i = row - 1; i >= 0; i--) {
    if (result[i] === col) {
      return false
    }
    if (leftup >= 0) {
      if (result[i] === leftup) {
        return false
      }
    }
    if (leftup < 8) {
      if (result[i] === rightup) {
        return false
      }
    }
    leftup--
    rightup++
  }
  return true
}

function printQueens(arr, counter = 0) {
  counter++
  for (let row = 0; row < 8; row++) {
    let line = ''
    for (let col = 0; col < 8; col++) {
      if (arr[row] === col) {
        line += ' Q '
      } else {
        line += ' * '
      }
    }
    console.log(line)
  }
  return counter
}

calcQueens(0)
// 92种摆法
复制代码
```

### 动态规划

**一个模型三个特征**:

- 一个模型: 指的是动态规划适合解决的问题的模型。把这个模型定义为“多阶段决策最优解模型"。
- 三个特征：分别是`最优子结构`、`无后效性`和`重复子问题`。

1. 最优子结构指的是，问题的最优解包含子问题的最优解。
2. 无后效性指的是某阶段状态一旦确定，就不受之后阶段的决策影响。
3. 重复子问题指的是不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态

动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。

#### 0-1 背包问题

对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？

假设物品重量数组为 [2, 2, 4, 6, 3], 背包最大承重为9.

把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。

把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），也就是例子中的 9。于是，就成功避免了每层状态个数的指数级增长。

用一个二维数组 `states[n][w+1]`，来记录每层可以达到的不同状态。

- 第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。用 `states[0][0]=true` 和 `states[0][2]=true` 来表示这两种状态。
- 第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。用 `states[1][0]=true`，`states[1][2]=true`，`states[1][4]=true` 来表示这三种状态。
- 以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。如下图所示。图中 0 表示 false，1 表示 true。只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。



![125e61d2](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728f3631fa92e30~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)





![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/7/1728f224fea5f683~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



```ini
/**
 * @param weight 物品重量数组
 * @param n  物品个数
 * @param w  背包可承载重量
 */
function knapsack(weight, n, w) {
  let states = new Array(n)
  for (let i = 0; i < n; i++) {
    states[i] = new Array(w + 1)
  }
  states[0][0] = true   //第一行的数据要特殊处理，可以利用哨兵优化
  if (weight[0] <= w) {
    states[0][weight[0]] = true
  }

  for (let i = 1; i < n; ++i) {  // 动态规划状态转移
    for (let j = 0; j <= w; ++j) {  // 不把第 i 个物品放入背包
      if (states[i - 1][j] === true) {
        states[i][j] = states[i - 1][j]
      }
    }
    for (let j = 0; j <= w - weight[i]; ++j) { // 把第 i 个物品放入背包
      if (states[i - 1][j] === true) {
        states[i][j + weight[i]] = true
      }
    }
  }

  for (let i = w; i >= 0; --i) { // 输出结果
    if (states[n - 1][i] == true) return i
  }
  return 0
}

const a = [2, 2, 4, 6, 3]
console.log(knapsack(a, 5, 9))
// 9
复制代码
```

#### 最小路径和

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。

> 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。

```ini
function minPathSum(arr) {
  const m = arr.length
  const n = arr[0].length

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (i === 0 && j !== 0) {
        arr[i][j] += arr[i][j - 1]
      } else if (j === 0 && i !== 0) {
        arr[i][j] += arr[i - 1][j]
      } else if (i !== 0 && j !== 0) {
        arr[i][j] += Math.min(arr[i - 1][j], arr[i][j - 1])
      }
    }
  }
  return arr[m - 1][n - 1]
}

const a = new Array(3)
a[0] = [1, 1, 4]
a[1] = [3, 5, 2]
a[2] = [1, 1, 1]
console.log(minPathSum(a))
//7
复制代码
```

#### 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

> 输入：[1,2,3,1] 输出：4 （1 + 3）
>
> 输入：[2,7,9,3,1] 输出：12
>  (2 + 9 + 1)

步骤：

`f(k)` = 从前 k 个房屋中能抢劫到的最大数额，`Ai` = 第 i 个房屋的钱数。

1. 首先看n = 1 的情况，显然 f(1) = A1。
2. 再看 n = 2，f(2) = max(A1, A2)。
3. 对于 n = 3，有两个选项:

- 抢第三个房子，将数额与第一个房子相加。
- 不抢第三个房子，保持现有最大数额。

显然，你想选择数额更大的选项。于是，可以总结出公式：

```
f(k) = max(f(k – 2) + Ak, f(k – 1))
function rob(arr) {
  const len = arr.length
  if (len < 2) {
    return arr[len - 1] ? arr[len - 1] : 0
  }
  let cur = [arr[0], Math.max(arr[0], arr[1])]
  for (let k = 2; k < len; k++) {
    cur[k] = Math.max(cur[k - 2] + arr[k], cur[k - 1])
  }
  return cur[len - 1]
}

const a = [2, 7, 9, 3, 1]
console.log(rob(a))
//12
复制代码
```

### 贪心

贪心算法：对问题求解的时候，总是做出在当前看来是最好的做法。

适用贪心算法的场景：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。

#### 分糖果

有 `m` 个糖果和 `n` 个孩子。现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m<n），所以糖果只能分配给一部分孩子。

每个糖果的大小不等，这 m 个糖果的大小分别是 `s1，s2，s3，……，sm`。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。

假设这 n 个孩子对糖果大小的需求分别是 `g1，g2，g3，……，gn`。

问题是，如何分配糖果，能尽可能满足最多数量的孩子？

可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 m。

例如：

> 输入 [1,1],[1,2,3]  //糖果大小分别为：1,1 ，3个孩子的胃口值分别是：1,2,3 输出 1
>
> 输入 [1,2,3],[1,2,4,4]  //糖果大小分别为：1,2,3 ，4个孩子的胃口值分别是：1,2,4,4 输出 2

```ini
/**
 *
 * @param sArr 糖果大小数组，如果[s1,s2,...sm]
 * @param gArr 对糖果的需求数组，如果[g1,g2,...gn]
 */
function distributeCandy(sArr, gArr) {
  sArr = sArr.sort((a, b) => a - b)
  gArr = gArr.sort((a, b) => a - b)

  let num = 0
  let sIndex = 0
  let gIndex = 0

  while (sIndex < sArr.length && gIndex < gArr.length) {
    if (gArr[gIndex] <= sArr[sIndex]) {
      num++
      gIndex++
    }
    sIndex++
  }
  return num
}

console.log(distributeCandy([1, 1], [1, 2, 3])) //1
console.log(distributeCandy([1, 2, 3], [1, 2, 4, 4])) //2
复制代码
```

#### 钱币找零

假设有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，现在要用这些钱来支付 K 元，最少要用多少张纸币呢？

```javascript
function makeChange(coins, amount, i, min) {
  let coin = coins[i]
  let tempAmount = Math.floor(amount / coin) // coin额度的需要的张数
  if (tempAmount) {
    min[coin] = tempAmount
  }
  if (amount % coin !== 0) {
    makeChange(coins, amount - coin * tempAmount, --i, min)
  }
}

function minCoinChange(coins, amount) {
  coins = coins.sort((a, b) => a - b)

  let result = null
  if (!amount) return result

  const arr = []
  for (let i = coins.length - 1; i >= 0; i--) {
    const cache = {}
    makeChange(coins, amount, i, cache)
    arr.push(cache)
  }

  arr.forEach(item => {
    let total = Object.values(item).reduce((acc, cur) => acc + cur)
    item.counter = total
  })
  arr.sort((a, b) => a.counter - b.counter)
  console.log(arr)
  return arr[0]
}

const result = minCoinChange([1, 20, 10, 5, 50, 2, 100], 136)
console.log(result)
复制代码
```

输出结果为：

```yaml
[
  { '1': 1, '5': 1, '10': 1, '20': 1, '100': 1, counter: 5 },
  { '1': 1, '5': 1, '10': 1, '20': 1, '50': 2, counter: 6 },
  { '1': 1, '5': 1, '10': 1, '20': 6, counter: 9 },
  { '1': 1, '5': 1, '10': 13, counter: 15 },
  { '1': 1, '5': 27, counter: 28 },
  { '2': 68, counter: 68 },
  { '1': 136, counter: 136 }
]
{ '1': 1, '5': 1, '10': 1, '20': 1, '100': 1, counter: 5 }
```



作者：寒城子
链接：https://juejin.cn/post/6844904182680387597
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 1.1什么是回溯？

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。——摘自《百度百科》 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdbc71a154d74fc585a5df8cd2c3ed6d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 1.1 一般步骤：

1. 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。
2. 确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。
3. 以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。

## 1.2 如何理解回溯算法？

1. 为问题建立解空间结构
2. 在解空间结构上进行DFS搜索
3. 设立回溯出口和剪枝点，减少无效搜索，出口处保存有效解.

## 1.3 解决那些问题？

1. 组合问题：N个数⾥⾯按⼀定规则找出k个数的集合
2. 切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式
3. ⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集
4. 排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式
5. 棋盘问题：N皇后，解数独等等。

## 1.4递归与回溯

首先先说明一下对递归 (Recursive)与回溯 (Backtrack)的理解。

### 1.4.1 递归 (Recursive)

程序调用自身的编程技巧称为递归。 递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 ——摘自《百度百科》

通常来说，为了描述问题的某一状态，必须用到该状态的上一个状态；而如果要描述上一个状态，又必须用到上一个状态的上一个状态…… 这样用自己来定义自己的方法就是递归。

### 1.4.2. 回溯 (Backtrack)

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 ——摘自《百度百科》

在这种思想下，我们需要清晰的找出三个要素：选择 (Options)，限制 (Restraints)，结束条件 (Termination)。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/788cd990e86f4279980a14e467c920de~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 1.5.递归与回溯的区别

递归是一种算法结构。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己。典型的例子是阶乘，计算规律为：n!=n×(n−1)!n!=n \times (n-1)!，基本如下所示：

```js
let fac = (n)=> {
    if(n == 1){
       return n;
    }else{
      return (n*fac(n - 1)); 
    }    
}
复制代码
```

回溯是一种算法思想，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。

# 二、Leetcode回溯题目

## 2.1- 22. 括号生成

### 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例 1：

```js
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
复制代码
```

示例 2：

```js
输入：n = 1
输出：["()"]
复制代码
```

提示： 1 <= n <= 8

## 思路分析

1. 判断左右括号所剩的数量，最初始都是n;当左括号（(）有剩余，继续做选择；
2. 判断当右括号比左括号剩的多，才能选右括号；继续递归做选择
3. 出口:构建的字符串是 2n的时候，此时已经该分支已经构建完成，加入选项；

## 简答绘制图形

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/574675e16b23475cb29aaff86d4c3a17~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 解题代码

```js
var generateParenthesis = function (n) {
    const res = [];
    const backTracing = (lRemain, rRemain, str) => { // 左右括号所剩的数量，str是当前构建的字符串
        if (str.length == 2 * n) { // 字符串构建完成
            res.push(str);           // 加入解集
            return;                  // 结束当前递归分支
        }
        if (lRemain > 0) {         // 只要左括号有剩，就可以选它，然后继续做选择（递归）
            backTracing(lRemain - 1, rRemain, str + "(");
        }
        if (lRemain < rRemain) {   // 右括号比左括号剩的多，才能选右括号
            backTracing(lRemain, rRemain - 1, str + ")"); // 然后继续做选择（递归）
        }
    };
    backTracing(n, n, ""); // 递归的入口，剩余数量都是n，初始字符串是空串
    return res;
};
复制代码
```

## 2.2 - 46. 全排列

### 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：

```js
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
复制代码
```

示例 2：

```js
输入：nums = [0,1]
输出：[[0,1],[1,0]]
复制代码
```

示例 3：

```js
输入：nums = [1]
输出：[[1]]
复制代码
```

提示： 1 <= nums.length <= 6 -10 <= nums[i] <= 10 nums 中的所有整数 互不相同

## 解题思路

1. 回溯终止条件：该条路径长度与达到nums长度；
2. 加入当前值到路径，如果结果里面已经包含这个路径，则不加入结果里面，否则继续选择这个选项；

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8130c056516043089a27244655db0e25~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 解题代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
    if (!nums.length) return
    let res = []
    let backTrack = path => {
        //长度满足条件，加入结果
        if (path.length === nums.length) {
            res.push(path)
            return
        }
        nums.forEach(item => {
            if (path.includes(item)) return //不包含重复的数字
            backTrack([...path, item]) //加入路径，继续递归选择
        });
    }
    backTrack([])
    return res
};

复制代码
```

## 2.3 - n 皇后问题

### 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。***

![image](https://upload-images.jianshu.io/upload_images/23849911-018ba83744b413ee.image?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 皇后走法规则

皇后的走法是：可以横直斜走，格数不限。因此要求皇后彼此之间不能相互攻击，等价于要求任何两个皇后都不能在同一行、同一列以及同一条斜线上。

## 示例

示例 1： ![image](https://upload-images.jianshu.io/upload_images/23849911-14b9bee8aba2ddd4.image?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```js
输入：n = 4
输出：2
复制代码
```

解释：如上图所示，4 皇后问题存在两个不同的解法。

示例 2：

```js
输入：n = 1
输出：1
复制代码
```

提示： 1 <= n <= 9

## 解题思路

1. 定义判断当前位置的检验函数，约束条件包含 ，不能同行，不能同列，不能同对角线（45度和135度）
2. 定义棋盘；标准回溯处理；

### 使用回溯的具体做法是：依次在每一行放置一个皇后，每次新放置的皇后都不能和已经放置的皇后之间有攻击，即新放置的皇后不能和任何一个已经放置的皇后在同一列以及同一条斜线上。当 NNN 个皇后都放置完毕，则找到一个可能的解，将可能的解的数量加 111。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd09da254e2a4b6d9fd9ece951486e98~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

[图片来源](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_37763204%2Farticle%2Fdetails%2F79519671)

## 解题代码

```js
var totalNQueens = function (n) {
    let count = 0; //皇后可放置的总数
    let isValid = (row, col, board, n) => {
        //所在行不用判断，每次都会下移一行
        //判断同一列的数据是否包含
        for (let i = 0; i < row; i++) {
            if (board[i][col] === 'Q') {
                return false
            }
        }
        //判断45度对角线是否包含
        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] === 'Q') {
                return false
            }
        }
        //判断135度对角线是否包含
        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; j--, i--) {
            if (board[i][j] === 'Q') {
                return false
            }
        }
        return true
    }

    let backTracing = (row, board) => {
        //走到最后一行，统计次数
        if (row === n) {
            count++;
            return
        }

        for (let x = 0; x < n; x++) {
            //判断该位置是否可以放置 皇后
            if (isValid(row, x, board, n)) {
                board[row][x] = 'Q'; //放置皇后
                backTracing(row + 1, board); //递归
                board[row][x] = '.'; //回溯，撤销处理结果
            }
        }
    }
    backTracing(0, board)
    let board = [...Array(n)].map(v => v = ([...Array(n)]).fill('.')) //棋盘
    return count
};
复制代码
```

## 2.4 - 78. 子集

### 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：

```js
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
复制代码
```

示例 2：

```js
输入：nums = [0]
输出：[[],[0]]
复制代码
```

提示： 1 <= nums.length <= 10 -10 <= nums[i] <= 10 nums 中的所有元素 互不相同

## 解题思路

1. 枚举出所有可选的数；加入选项；
2. 撤销加入的选项，将选项加入结果

## 解题代码

```js
const subsets = (nums) => {
    const res = [];
    const backTracing = (index, list) => {
        res.push(list.slice());     // 调用子递归前，加入解集
        for (let i = index; i < nums.length; i++) { // 枚举出所有可选的数
            list.push(nums[i]);       // 选这个数
            backTracing(i + 1, list);         // 基于选这个数，继续递归
            list.pop();               // 撤销选这个数
        }
    };
    backTracing(0, []);
    return res;
};
复制代码
```

## 2.5 - 77. 组合

### 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。

示例 1：

```js
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
复制代码
```

示例 2：

```js
输入：n = 1, k = 1
输出：[[1]]
复制代码
```

提示： 1 <= n <= 20 1 <= k <= n

## 解题思路

1. 枚举出所有可选的数；加入选项；
2. 撤销加入的选项，将选项加入结果
3. 剪枝条件:选项的长度满足条件；

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0fed7e92d3449c0aa28e573f4ac4138~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 解题代码

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function (n, k) {
    let result = [];
    let backTracing = (start, path) => {
        // 如果已经选满了的话，加入结果集中
        if (path.length == k) {
            result.push(path.slice());
            return;
        }
        // 从开始的数字到末尾的数字
        for (let i = start; i <= n; i++) {
            // 加入选择列表中
            path.push(i);
            // 继续深度搜索
            backTracing(i + 1, path);
            // 撤销选择
            path.pop(i);
        }
    };
    backTracing(1, []);
    return result;
};
复制代码
```

## 2.6 - 081. 允许重复选择元素的组合

### 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。

candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。

示例 1：

```js
输入: candidates = [2,3,6,7], target = 7
输出: [[7],[2,2,3]]
复制代码
```

示例 2：

```js
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
复制代码
```

示例 3：

```js
输入: candidates = [2], target = 1
输出: []
复制代码
```

示例 4：

```js
输入: candidates = [1], target = 1
输出: [[1]]
复制代码
```

示例 5：

```js
输入: candidates = [1], target = 2
输出: [[1,1]]
复制代码
```

提示： 1 <= candidates.length <= 30 1 <= candidates[i] <= 200 candidate 中的每个元素都是独一无二的。 1 <= target <= 500

## 解题思路

1. 将当前元素加入到选项里面，并将计算结果，传到选项，继续递归；
2. 当选项和大于目标值时，结束这个选项，直到找到符合的选项，并将选项加入结果；

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94816a5d728c45688526a3bf2e692a5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 解题代码

```js
var combinationSum = function (candidates, target) {
    const result = [], visited = [];
    backTracing(0, 0);
    return result;

    function backTracing(sum, cur) {
        if (target === sum) result.push(visited.slice());
        if (target <= sum) return;
        for (let i = cur; i < candidates.length; i++) {
            visited.push(candidates[i]); //加入到选项里面
            backTracing(sum + candidates[i], i);//选择这个选项，继续递归
            visited.pop(); //插销这个选择
        }
    }
};
复制代码
```

## 2.7 - 216. 组合总和 III

### 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明： 所有数字都是正整数。 解集不能包含重复的组合。

示例 1:

```js
输入: k = 3, n = 7
输出: [[1,2,4]]
复制代码
```

示例 2:

```js
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
复制代码
```

## 解题思路

同组合1

## 解题代码

```js
var combinationSum3 = function (k, n) {
    let ans = [];
    let backTracing = (start, path) => {
        if (path.length === k && path.reduce((acc, prev) => acc += prev) === n) {
            ans.push(path.slice())
            return
        }
        for (let i = start; i <= 9; i++) {
            path.push(i)
            backTracing(i + 1, path)
            path.pop(i)
        }
    }
    backTracing(1, [])
    return ans
};
复制代码
```

## 2.8 - 17. 电话号码的字母组合

### 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91285e87168643b8ae19866b16438eaf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

示例 1：

```js
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
复制代码
```

示例 2：

```js
输入：digits = ""
输出：[]
复制代码
```

示例 3：

```js
输入：digits = "2"
输出：["a","b","c"]
复制代码
```

提示： 0 <= digits.length <= 4 digits[i] 是范围 ['2', '9'] 的一个数字。

## 解题思路

1. 找到当前按钮对应的字母字符串
2. 拼接按钮对应的字符串组合
3. 选项满足长度，加入结果

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91fbe6f9d8f44ddba5dd9956697ee945~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 解题代码

```js
var letterCombinations = function (digits) {
    if(!digits.length) return []
    const dic = {
        2: 'abc',
        3: 'def',
        4: 'ghi',
        5: 'jkl',
        6: 'mno',
        7: 'pqrs',
        8: 'tuv',
        9: 'wxyz',
    }, ans = [];

    let backTracing = (cur, index) => {
        if (index > digits.length - 1) { //选项满足长度，加入结果
            ans.push(cur)
            return
        }
        let curDic = dic[digits[index]] //找到当前按钮对应的字母字符串
        for (let prop of curDic) {
            backTracing(cur + prop,index+1) //拼接按钮对应的字符串组合
        }
    }
    backTracing('', 0)
    return ans
};
复制代码
```

## 2.9 - 08.01. 三步问题

### 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

示例1:

```js
 输入：n = 3 
 输出：4
 说明: 有四种走法
复制代码
```

示例2:

```js
 输入：n = 5
 输出：13
复制代码
```

提示: n范围在[1, 1000000]之间

## 解题代码(会超时)

```js
 var waysToStep = function (n) {
    let ans = [], map = [1, 2, 3]
    let backTracing = (path, sum) => {
        if (sum >= n) {
            if (sum == n) {
                ans++;
            }
            return
        }
        for (let i = 0; i < 3; i++) {
            path.push(map[i]);
            backTracing(path, sum + map[i])
            path.pop(i)
        }
    }
    backTracing([], 0)
    return ans
};
复制代码
```

## 动态规划解法

```js
/**
 * @param {number} n
 * @return {number}
 */
var waysToStep = function (n) {
    let dp =[],mod = 1000000007;
    dp[0]=0,dp[1]=1,dp[2]=2,dp[3]=4;
    for (let i = 4; i <= n; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod
    }
    return dp[n]
};
复制代码
```

## 2-10 - 40. 组合总和 II

### 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。 注意：解集不能包含重复的组合。

示例 1:

```js
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
复制代码
```

示例 2:

```js
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
复制代码
```

提示: 1 <= candidates.length <= 100 1 <= candidates[i] <= 50 1 <= target <= 30

## 解题思路

思路同组合1

## 解题代码

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
 var combinationSum2 = function (candidates, target) {
    candidates.sort((a,b)=>a-b)
    let ans = [];
    let backTracing = (start, path, sum) => {
        if (sum >= target) {
            if (sum === target) {
                ans.push(path.slice())
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i - 1 >= start && candidates[i - 1] == candidates[i]) {
                continue;
            }
            path.push(candidates[i])
            backTracing(i + 1, path, sum + candidates[i])
            path.pop()
        }
    }
    backTracing(0, [], 0)
    return ans
};
复制代码
```

## 2-11 - 47. 全排列 II

### 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

示例 1：

```js
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
复制代码
```

示例 2：

```js
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
复制代码
```

提示： 1 <= nums.length <= 8 -10 <= nums[i] <= 10

## 解题思路

同上全排列

## 解题代码

```js
var permuteUnique = function (nums) {
   let ans = [];
   let used = Array(nums.length).fill(false)
   let backTracing = (start, path) => {
       if (start === nums.length) {
           ans.push(path.slice())
           return
       }
       for (let i = 0; i < nums.length; ++i) {
           if (used[i] || (i > 0 && nums[i] === nums[i - 1] && !used[i - 1])) {
               continue;
           }
           path.push(nums[i])
           used[i] = true
           backTracing(start + 1, path)
           used[i] = false
           path.pop()
       }
   }
   nums.sort((a, b) => a - b)
   backTracing(0, [])
   return ans

};
复制代码
```

# 三、总结

### 主要运用了回溯算法；而解决一个回溯问题，实际上就是一个决策树的遍历过程。

## 3.1 模板

```js
let backtracking=(路径，选择列表) =>{
    if (满足结束条件)) {
        存放路径;
        return;
    }
    for (选择：路径，选择列表) {
        做出选择；
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
复制代码
```

即:

1. 1.路径：也就是已经做出的选择。
2. 2.选择列表：也就是你当前可以做的选择。
3. 3.结束条件：也就是到达决策树底层，无法再做选择的条件。

## 3.2 剪枝函数

1. 1.用约束条件剪除得不到的可行解的子树
2. 2.用目标函数剪取得不到的最优解的子树

## 3.3 回溯法的一般步骤：

1. 1.设置初始化的方案（给变量赋初始值，读入已知数据等）
2. 2.变换方式去试探，若全部试完侧转（7）
3. 3.判断此法是否成功（通过约束函数），不成功则转（2）
4. 4.试探成功则前进一步再试探
5. 5.正确方案还是未找到则转（2）
6. 6.以找到一种方案则记录并打印
7. 7.退回一步（回溯），若未退到头则转（2）
8. 8.已退到头则结束或打印无解

继续加油！！！

# 四、参考文献

1. LeetCode 刷题笔记——递归与回溯的理解[LeetCode 刷题笔记——递归与回溯的理解](https://link.juejin.cn?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1434886)
2. 图解回溯算法[图解回溯算法](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgui951753%2Farticle%2Fdetails%2F108014030)
3. 回溯算法总结[回溯算法总结](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F8fc2257d1f4e)



作者：叫我詹躲躲
链接：https://juejin.cn/post/7045925463545348110
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30337832145d4969833ccb6cf4009d7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp) 

https://github.com/sl1673495/leetcode-javascript