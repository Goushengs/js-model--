## 前期准备

在做下面👇的题目之前，我希望你能清楚几个知识点。

(如果你感觉一上来不想看这些列举的知识点的话，直接看后面的例子再来理解它们也可以)

**`event loop`它的执行顺序：**

- 一开始整个脚本作为一个宏任务执行
- 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
- 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完
- 执行浏览器UI线程的渲染工作
- 检查是否有`Web Worker`任务，有则执行
- 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

**微任务包括：**`MutationObserver`、`Promise.then()或catch()`、`Promise为基础开发的其它技术，比如fetch API`、`V8`的垃圾回收过程、`Node独有的process.nextTick`。

**宏任务包括**：`script` 、`setTimeout`、`setInterval` 、`setImmediate` 、`I/O` 、`UI rendering`。

**注意**⚠️：在所有任务开始的时候，由于宏任务中包括了`script`，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如`setTimeout`)将被放到下一轮宏任务中来执行。

### 1. Promise的几道基础题

#### 1.1 题目一

```arcade
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
})
console.log('1', promise1);复制代码
```

过程分析：

- 从上至下，先遇到`new Promise`，执行该构造函数中的代码`promise1`
- 然后执行同步代码`1`，此时`promise1`没有被`resolve`或者`reject`，因此状态还是`pending`

结果：

```coffeescript
'promise1'
'1' Promise{<pending>}复制代码
```

#### 1.2 题目二

```arcade
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);复制代码
```

过程分析：

- 从上至下，先遇到`new Promise`，执行其中的同步代码`1`
- 再遇到`resolve('success')`， 将`promise`的状态改为了`resolved`并且将值保存下来
- 继续执行同步代码`2`
- 跳出`promise`，往下执行，碰到`promise.then`这个微任务，将其加入微任务队列
- 执行同步代码`4`
- 本轮宏任务全部执行完毕，检查微任务队列，发现`promise.then`这个微任务且状态为`resolved`，执行它。

结果：

```basic
1 2 4 3复制代码
```

#### 1.3 题目三

```arcade
const promise = new Promise((resolve, reject) => {
  console.log(1);
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);复制代码
```

过程分析

- 和题目二相似，只不过在`promise`中并没有`resolve`或者`reject`
- 因此`promise.then`并不会执行，它只有在被改变了状态之后才会执行。

结果：

```basic
1 2 4复制代码
```

#### 1.4 题目四

```arcade
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res => {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);复制代码
```

过程分析：

- 从上至下，先遇到`new Promise`，执行该构造函数中的代码`promise1`
- 碰到`resolve`函数, 将`promise1`的状态改变为`resolved`, 并将结果保存下来
- 碰到`promise1.then`这个微任务，将它放入微任务队列
- `promise2`是一个新的状态为`pending`的`Promise`
- 执行同步代码`1`， 同时打印出`promise1`的状态是`resolved`
- 执行同步代码`2`，同时打印出`promise2`的状态是`pending`
- 宏任务执行完毕，查找微任务队列，发现`promise1.then`这个微任务且状态为`resolved`，执行它。

结果：

```coffeescript
'promise1'
'1' Promise{<resolved>: 'resolve1'}
'2' Promise{<pending>}
'resolve1'复制代码
```

#### 1.5 题目五

接下来看看这道题：

```arcade
const fn = () => (new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
}))
fn().then(res => {
  console.log(res)
})
console.log('start')复制代码
```

这道题里最先执行的是`'start'`吗 🤔️ ？

请仔细看看哦，`fn`函数它是直接返回了一个`new Promise`的，而且`fn`函数的调用是在`start`之前，所以它里面的内容应该会先执行。

结果：

```scheme
1
'start'
'success'复制代码
```

#### 1.6 题目六

如果把`fn`的调用放到`start`之后呢？

```arcade
const fn = () =>
  new Promise((resolve, reject) => {
    console.log(1);
    resolve("success");
  });
console.log("start");
fn().then(res => {
  console.log(res);
});复制代码
```

是的，现在`start`就在`1`之前打印出来了，因为`fn`函数是之后执行的。

**注意⚠️**：之前我们很容易就以为看到new Promise()就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。

答案：

```1c
"start"
1
"success"复制代码
```

好嘞，学完了这几道基础题，让我们来用个表情包压压惊。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bb6c5b5d2a70~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



### 2. Promise结合setTimeout

#### 2.1 题目一

```arcade
console.log('start')
setTimeout(() => {
  console.log('time')
})
Promise.resolve().then(() => {
  console.log('resolve')
})
console.log('end')复制代码
```

过程分析：

- 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出`start`和`end`。
- `setTimout`作为一个宏任务被放入宏任务队列(下一个)
- `Promise.then`作为一个微任务被放入微任务队列
- 本次宏任务执行完，检查微任务，发现`Promise.then`，执行它
- 接下来进入下一个宏任务，发现`setTimeout`，执行。

结果：

```scheme
'start'
'end'
'resolve'
'time'复制代码
```

#### 2.2 题目二

```arcade
const promise = new Promise((resolve, reject) => {
  console.log(1);
  setTimeout(() => {
    console.log("timerStart");
    resolve("success");
    console.log("timerEnd");
  }, 0);
  console.log(2);
});
promise.then((res) => {
  console.log(res);
});
console.log(4);复制代码
```

过程分析：

和题目`1.2`很像，不过在`resolve`的外层加了一层`setTimeout`定时器。

- 从上至下，先遇到`new Promise`，执行该构造函数中的代码`1`
- 然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行
- 执行同步代码`2`
- 跳出`promise`函数，遇到`promise.then`，但其状态还是为`pending`，这里理解为先不执行
- 执行同步代码`4`
- 一轮循环过后，进入第二次宏任务，发现延迟队列中有`setTimeout`定时器，执行它
- 首先执行`timerStart`，然后遇到了`resolve`，将`promise`的状态改为`resolved`且保存结果并将之前的`promise.then`推入微任务队列
- 继续执行同步代码`timerEnd`
- 宏任务全部执行完毕，查找微任务队列，发现`promise.then`这个微任务，执行它。

因此执行结果为：

```1c
1
2
4
"timerStart"
"timerEnd"
"success"复制代码
```

#### 2.3 题目三

题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么：

**(1)**:

```arcade
setTimeout(() => {
  console.log('timer1');
  setTimeout(() => {
    console.log('timer3')
  }, 0)
}, 0)
setTimeout(() => {
  console.log('timer2')
}, 0)
console.log('start')复制代码
```

**(2)**:

```arcade
setTimeout(() => {
  console.log('timer1');
  Promise.resolve().then(() => {
    console.log('promise')
  })
}, 0)
setTimeout(() => {
  console.log('timer2')
}, 0)
console.log('start')复制代码
```

**执行结果：**

```scheme
'start'
'timer1'
'timer2'
'timer3'复制代码
'start'
'timer1'
'promise'
'timer2'复制代码
```

这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。

一个是为定时器`timer3`，一个是为`Promise.then`

但是如果是定时器`timer3`的话，它会在`timer2`后执行，而`Promise.then`却是在`timer2`之前执行。

你可以这样理解，`Promise.then`是微任务，它会被加入到本轮中的微任务列表，而定时器`timer3`是宏任务，它会被加入到下一轮的宏任务中。

理解完这两个案例，可以来看看下面一道比较难的题目了。

#### 2.3 题目三

```arcade
Promise.resolve().then(() => {
  console.log('promise1');
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
console.log('start');复制代码
```

这道题稍微的难一些，在`promise`中执行定时器，又在定时器中执行`promise`；

并且要注意的是，这里的`Promise`是直接`resolve`的，而之前的`new Promise`不一样。

(偷偷告诉你，这道题往下一点有流程图)

因此过程分析为：

- 刚开始整个脚本作为第一次宏任务来执行，我们将它标记为**宏1**，从上至下执行
- 遇到`Promise.resolve().then`这个微任务，将`then`中的内容加入第一次的微任务队列标记为**微1**
- 遇到定时器`timer1`，将它加入下一次宏任务的延迟列表，标记为**宏2**，等待执行(先不管里面是什么内容)
- 执行**宏1**中的同步代码`start`
- 第一次宏任务(**宏1**)执行完毕，检查第一次的微任务队列(**微1**)，发现有一个`promise.then`这个微任务需要执行
- 执行打印出**微1**中同步代码`promise1`，然后发现定时器`timer2`，将它加入**宏2**的后面，标记为**宏3**
- 第一次微任务队列(**微1**)执行完毕，执行第二次宏任务(**宏2**)，首先执行同步代码`timer1`
- 然后遇到了`promise2`这个微任务，将它加入此次循环的微任务队列，标记为**微2**
- **宏2**中没有同步代码可执行了，查找本次循环的微任务队列(**微2**)，发现了`promise2`，执行它
- 第二轮执行完毕，执行**宏3**，打印出`timer2`

所以结果为：

```scheme
'start'
'promise1'
'timer1'
'promise2'
'timer2'复制代码
```

如果感觉有点绕的话，可以看下面这张图，就一目了然了。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708b0d8489e5732~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



#### 2.4 题目四

```coffeescript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() => {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() => {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)复制代码
```

过程分析：

- 从上至下，先执行第一个`new Promise`中的函数，碰到`setTimeout`将它加入下一个宏任务列表
- 跳出`new Promise`，碰到`promise1.then`这个微任务，但其状态还是为`pending`，这里理解为先不执行
- `promise2`是一个新的状态为`pending`的`Promise`
- 执行同步代码`console.log('promise1')`，且打印出的`promise1`的状态为`pending`
- 执行同步代码`console.log('promise2')`，且打印出的`promise2`的状态为`pending`
- 碰到第二个定时器，将其放入下一个宏任务列表
- 第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务
- 先执行第一个定时器里的内容，将`promise1`的状态改为`resolved`且保存结果并将之前的`promise1.then`推入微任务队列
- 该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是`promise1.then`，它抛出了一个错误，且将`promise2`的状态设置为了`rejected`
- 第一个定时器执行完毕，开始执行第二个定时器中的内容
- 打印出`'promise1'`，且此时`promise1`的状态为`resolved`
- 打印出`'promise2'`，且此时`promise2`的状态为`rejected`

完整的结果为：

```erlang-repl
'promise1' Promise{<pending>}
'promise2' Promise{<pending>}
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'promise1' Promise{<resolved>: "success"}
'promise2' Promise{<rejected>: Error: error!!!}复制代码
```

#### 2.5 题目五

如果你上面这道题搞懂了之后，我们就可以来做做这道了，你应该能很快就给出答案：

```arcade
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("success");
    console.log("timer1");
  }, 1000);
  console.log("promise1里的内容");
});
const promise2 = promise1.then(() => {
  throw new Error("error!!!");
});
console.log("promise1", promise1);
console.log("promise2", promise2);
setTimeout(() => {
  console.log("timer2");
  console.log("promise1", promise1);
  console.log("promise2", promise2);
}, 2000);复制代码
```

结果：

```erlang-repl
'promise1里的内容'
'promise1' Promise{<pending>}
'promise2' Promise{<pending>}
'timer1'
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'timer2'
'promise1' Promise{<resolved>: "success"}
'promise2' Promise{<rejected>: Error: error!!!}复制代码
```

### 3. Promise中的then、catch、finally

额，可能你看到下面👇这么多的`1，2，3`脾气就上来了，不是说好了本篇文章没什么屁话嘛，怎么还是这么多一二三四。

😂，你要理解我的用心良苦啊，我这是帮你把知识点都列举出来，做个总结而已。当然，你也可以先不看，先去做后面的题，然后再回过头来看这些，你就觉得这些点都好好懂啊，甚至都不需要记。

**总结：**

1. `Promise`的状态一经改变就不能再改变。(见3.1)
2. `.then`和`.catch`都会返回一个新的`Promise`。(上面的👆1.4证明了)
3. `catch`不管被连接到哪里，都能捕获上层未捕捉过的错误。(见3.2)
4. 在`Promise`中，返回任意一个非 `promise` 的值都会被包裹成 `promise` 对象，例如`return 2`会被包装为`return Promise.resolve(2)`。
5. `Promise` 的 `.then` 或者 `.catch` 可以被调用多次, 但如果`Promise`内部的状态一经改变，并且有了一个值，那么后续每次调用`.then`或者`.catch`的时候都会直接拿到该值。(见3.5)
6. `.then` 或者 `.catch` 中 `return` 一个 `error` 对象并不会抛出错误，所以不会被后续的 `.catch` 捕获。(见3.6)
7. `.then` 或 `.catch` 返回的值不能是 promise 本身，否则会造成死循环。(见3.7)
8. `.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生值透传。(见3.8)
9. `.then`方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为`catch`是`.then`第二个参数的简便写法。(见3.9)
10. `.finally`方法也是返回一个`Promise`，他在`Promise`结束的时候，无论结果为`resolved`还是`rejected`，都会执行里面的回调函数。

#### 3.1 题目一

```arcade
const promise = new Promise((resolve, reject) => {
  resolve("success1");
  reject("error");
  resolve("success2");
});
promise
.then(res => {
    console.log("then: ", res);
  }).catch(err => {
    console.log("catch: ", err);
  })复制代码
```

结果：

```1c
"then: success1"复制代码
```

构造函数中的 `resolve` 或 `reject` 只有第一次执行有效，多次调用没有任何作用 。验证了第一个结论，`Promise`的状态一经改变就不能再改变。

#### 3.2 题目二

```arcade
const promise = new Promise((resolve, reject) => {
  reject("error");
  resolve("success2");
});
promise
.then(res => {
    console.log("then1: ", res);
  }).then(res => {
    console.log("then2: ", res);
  }).catch(err => {
    console.log("catch: ", err);
  }).then(res => {
    console.log("then3: ", res);
  })复制代码
```

结果：

```actionscript
"catch: " "error"
"then3: " undefined复制代码
```

验证了第三个结论，`catch`不管被连接到哪里，都能捕获上层未捕捉过的错误。

至于`then3`也会被执行，那是因为`catch()`也会返回一个`Promise`，且由于这个`Promise`没有返回值，所以打印出来的是`undefined`。

#### 3.3 题目三

```arcade
Promise.resolve(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    return 3;
  })
  .then(res => {
    console.log(res);
  });复制代码
```

结果：

```
1
2复制代码
```

`Promise`可以链式调用，不过`promise` 每次调用 `.then` 或者 `.catch` 都会返回一个新的 `promise`，从而实现了链式调用, 它并不像一般我们任务的链式调用一样`return this`。

上面的输出结果之所以依次打印出`1`和`2`，那是因为`resolve(1)`之后走的是第一个`then`方法，并没有走`catch`里，所以第二个`then`中的`res`得到的实际上是第一个`then`的返回值。

且`return 2`会被包装成`resolve(2)`。

#### 3.4 题目四

如果把`3.3`中的`Promise.resolve(1)`改为`Promise.reject(1)`又会怎么样呢？

```arcade
Promise.reject(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    console.log(err);
    return 3
  })
  .then(res => {
    console.log(res);
  });复制代码
```

结果：

```
1
3复制代码
```

结果打印的当然是 `1 和 3`啦，因为`reject(1)`此时走的就是`catch`，且第二个`then`中的`res`得到的就是`catch`中的返回值。

#### 3.5 题目五

```arcade
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('timer')
    resolve('success')
  }, 1000)
})
const start = Date.now();
promise.then(res => {
  console.log(res, Date.now() - start)
})
promise.then(res => {
  console.log(res, Date.now() - start)
})复制代码
```

执行结果：

```scheme
'timer'
'success' 1001
'success' 1002复制代码
```

当然，如果你足够快的话，也可能两个都是`1001`。

`Promise` 的 `.then` 或者 `.catch` 可以被调用多次，但这里 `Promise` 构造函数只执行一次。或者说 `promise` 内部状态一经改变，并且有了一个值，那么后续每次调用 `.then` 或者 `.catch` 都会直接拿到该值。

#### 3.6 题目六

```arcade
Promise.resolve().then(() => {
  return new Error('error!!!')
}).then(res => {
  console.log("then: ", res)
}).catch(err => {
  console.log("catch: ", err)
})复制代码
```

猜猜这里的结果输出的是什么 🤔️ ？

你可能想到的是进入`.catch`然后被捕获了错误。

结果并不是这样的，它走的是`.then`里面：

```1c
"then: " "Error: error!!!"复制代码
```

这也验证了第4点和第6点，返回任意一个非 `promise` 的值都会被包裹成 `promise` 对象，因此这里的`return new Error('error!!!')`也被包裹成了`return Promise.resolve(new Error('error!!!'))`。

当然如果你抛出一个错误的话，可以用下面👇两的任意一种：

```javascript
return Promise.reject(new Error('error!!!'));
// or
throw new Error('error!!!')复制代码
```

#### 3.7 题目七

```coffeescript
const promise = Promise.resolve().then(() => {
  return promise;
})
promise.catch(console.err)复制代码
```

`.then` 或 `.catch` 返回的值不能是 promise 本身，否则会造成死循环。

因此结果会报错：

```cpp
Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>复制代码
```

#### 3.8 题目八

```sas
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)复制代码
```

这道题看着好像很简单，又感觉很复杂的样子，怎么这么多个`.then`啊... 😅



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708baaf2b1e9075~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



其实你只要记住**原则8**：`.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生值透传。

第一个`then`和第二个`then`中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将`resolve(1)` 的值直接传到最后一个`then`里。

所以输出结果为：

```
1复制代码
```

#### 3.9 题目九

下面来介绍一下`.then`函数中的两个参数。

第一个参数是用来处理`Promise`成功的函数，第二个则是处理失败的函数。

也就是说`Promise.resolve('1')`的值会进入成功的函数，`Promise.reject('2')`的值会进入失败的函数。

让我们来看看这个例子🌰：

```arcade
Promise.reject('err!!!')
  .then((res) => {
    console.log('success', res)
  }, (err) => {
    console.log('error', err)
  }).catch(err => {
    console.log('catch', err)
  })复制代码
```

这里的执行结果是：

```scheme
'error' 'error!!!'复制代码
```

它进入的是`then()`中的第二个参数里面，而如果把第二个参数去掉，就进入了`catch()`中：

```arcade
Promise.reject('error!!!')
  .then((res) => {
    console.log('success', res)
  }).catch(err => {
    console.log('catch', err)
  })复制代码
```

执行结果：

```scheme
'catch' 'error!!!'复制代码
```

但是有一个问题，如果是这个案例呢？

```qml
Promise.resolve()
  .then(function success (res) {
    throw new Error('error!!!')
  }, function fail1 (err) {
    console.log('fail1', err)
  }).catch(function fail2 (err) {
    console.log('fail2', err)
  })复制代码
```

由于`Promise`调用的是`resolve()`，因此`.then()`执行的应该是`success()`函数，可是`success()`函数抛出的是一个错误，它会被后面的`catch()`给捕获到，而不是被`fail1`函数捕获。

因此执行结果为：

```erlang-repl
fail2 Error: error!!!
			at success复制代码
```

#### 3.10 题目十

接着来看看`.finally()`，这个功能一般不太用在面试中，不过如果碰到了你也应该知道该如何处理。

其实你只要记住它三个很重要的知识点就可以了：

1. `.finally()`方法不管`Promise`对象最后的状态如何都会执行
2. `.finally()`方法的回调函数不接受任何的参数，也就是说你在`.finally()`函数中是没法知道`Promise`最终的状态是`resolved`还是`rejected`的
3. 它最终返回的默认会是一个**上一次的Promise对象值**，不过如果抛出的是一个异常则返回异常的`Promise`对象。

来看看这个简单的例子🌰：

```arcade
Promise.resolve('1')
  .then(res => {
    console.log(res)
  })
  .finally(() => {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() => {
    console.log('finally2')
  	return '我是finally2返回的值'
  })
  .then(res => {
    console.log('finally2后面的then函数', res)
  })复制代码
```

这两个`Promise`的`.finally`都会执行，且就算`finally2`返回了新的值，它后面的`then()`函数接收到的结果却还是`'2'`，因此打印结果为：

```scheme
'1'
'finally2'
'finally'
'finally2后面的then函数' '2'复制代码
```

至于为什么`finally2`的打印要在`finally`前面，请看下一个例子中的解析。

不过在此之前让我们再来确认一下，`finally`中要是抛出的是一个异常是怎样的：

```arcade
Promise.resolve('1')
  .finally(() => {
    console.log('finally1')
    throw new Error('我是finally中抛出的异常')
  })
  .then(res => {
    console.log('finally后面的then函数', res)
  })
  .catch(err => {
    console.log('捕获错误', err)
  })复制代码
```

执行结果为：

```javascript
'finally1'
'捕获错误' Error: 我是finally中抛出的异常复制代码
```

但是如果改为`return new Error('我是finally中抛出的异常')`，打印出来的就是`'finally后面的then函数 1'`

OK，👌，让我们来看一个比较难的例子🌰：

```arcade
function promise1 () {
  let p = new Promise((resolve) => {
    console.log('promise1');
    resolve('1')
  })
  return p;
}
function promise2 () {
  return new Promise((resolve, reject) => {
    reject('error')
  })
}
promise1()
  .then(res => console.log(res))
  .catch(err => console.log(err))
  .finally(() => console.log('finally1'))

promise2()
  .then(res => console.log(res))
  .catch(err => console.log(err))
  .finally(() => console.log('finally2'))复制代码
```

执行过程：

- 首先定义了两个函数`promise1`和`promise2`，先不管接着往下看。
- `promise1`函数先被调用了，然后执行里面`new Promise`的同步代码打印出`promise1`
- 之后遇到了`resolve(1)`，将`p`的状态改为了`resolved`并将结果保存下来。
- 此时`promise1`内的函数内容已经执行完了，跳出该函数
- 碰到了`promise1().then()`，由于`promise1`的状态已经发生了改变且为`resolved`因此将`promise1().then()`这条微任务加入本轮的微任务列表(**这是第一个微任务**)
- 这时候要注意了，代码并不会接着往链式调用的下面走，也就是不会先将`.finally`加入微任务列表，那是因为`.then`本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管`.finally()`
- 再往下走碰到了`promise2()`函数，其中返回的`new Promise`中并没有同步代码需要执行，所以执行`reject('error')`的时候将`promise2`函数中的`Promise`的状态变为了`rejected`
- 跳出`promise2`函数，遇到了`promise2().catch()`，将其加入当前的微任务队列(**这是第二个微任务**)，且链式调用后面的内容得等该任务执行完后才执行，和`.then()`一样。
- OK， 本轮的宏任务全部执行完了，来看看微任务列表，存在`promise1().then()`，执行它，打印出`1`，然后遇到了`.finally()`这个微任务将它加入微任务列表(**这是第三个微任务**)等待执行
- 再执行`promise2().catch()`打印出`error`，执行完后将`finally2`加入微任务加入微任务列表(**这是第四个微任务**)
- OK， 本轮又全部执行完了，但是微任务列表还有两个新的微任务没有执行完，因此依次执行`finally1`和`finally2`。

结果：

```scheme
'promise1'
'1'
'error'
'finally1'
'finally2'复制代码
```

在这道题中其实能拓展的东西挺多的，之前没有提到，那就是你可以理解为**链式调用**后面的内容需要等前一个调用执行完才会执行。

就像是这里的`finally()`会等`promise1().then()`执行完才会将`finally()`加入微任务队列，其实如果这道题中你把`finally()`换成是`then()`也是这样的:

```arcade
function promise1 () {
  let p = new Promise((resolve) => {
    console.log('promise1');
    resolve('1')
  })
  return p;
}
function promise2 () {
  return new Promise((resolve, reject) => {
    reject('error')
  })
}
promise1()
  .then(res => console.log(res))
  .catch(err => console.log(err))
  .then(() => console.log('finally1'))

promise2()
  .then(res => console.log(res))
  .catch(err => console.log(err))
  .then(() => console.log('finally2'))复制代码
```

### 4. Promise中的all和race

在做下面👇的题目之前，让我们先来了解一下`Promise.all()`和`Promise.race()`的用法。

通俗来说，`.all()`的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。

`.race()`的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。

来看看题目一。

#### 4.1 题目一

我们知道如果直接在脚本文件中定义一个`Promise`，它构造函数的第一个参数是会立即执行的，就像这样：

```arcade
const p1 = new Promise(r => console.log('立即打印'))复制代码
```

控制台中会立即打印出 “立即打印”。

因此为了控制它什么时候执行，我们可以用一个函数包裹着它，在需要它执行的时候，调用这个函数就可以了：

```arcade
function runP1 () {
    const p1 = new Promise(r => console.log('立即打印'))
    return p1
}

runP1() // 调用此函数时才执行复制代码
```

OK 👌， 让我们回归正题。

现在来构建这么一个函数：

```arcade
function runAsync (x) {
    const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
    return p
}复制代码
```

该函数传入一个值`x`，然后间隔一秒后打印出这个`x`。

如果我用`.all()`来执行它会怎样呢？

```arcade
function runAsync (x) {
    const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
    return p
}
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
  .then(res => console.log(res))复制代码
```

先来想想此段代码在浏览器中会如何执行？

没错，当你打开页面的时候，在间隔一秒后，控制台会同时打印出`1, 2, 3`，还有一个数组`[1, 2, 3]`。

```angelscript
1
2
3
[1, 2, 3]复制代码
```

所以你现在能理解这句话的意思了吗：**有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。**

`.all()`后面的`.then()`里的回调函数接收的就是所有异步操作的结果。

而且这个结果中数组的顺序和`Promise.all()`接收到的数组顺序一致！！！

> 有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。

#### 4.2 题目二

我新增了一个`runReject`函数，它用来在`1000 * x`秒后`reject`一个错误。

同时`.catch()`函数能够捕获到`.all()`里最先的那个异常，并且只执行一次。

想想这道题会怎样执行呢 🤔️？

```arcade
function runAsync (x) {
  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
  return p
}
function runReject (x) {
  const p = new Promise((res, rej) => setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res => console.log(res))
  .catch(err => console.log(err))复制代码
```

不卖关子了 😁，让我来公布答案：

```subunit
// 1s后输出
1
3
// 2s后输出
2
Error: 2
// 4s后输出
4复制代码
```

没错，就像我之前说的，`.catch`是会捕获最先的那个异常，在这道题目中最先的异常就是`runReject(2)`的结果。

另外，如果一组异步操作中有一个异常都不会进入`.then()`的第一个回调函数参数中。

注意，为什么不说是不进入`.then()`中呢 🤔️？

哈哈，大家别忘了`.then()`方法的第二个参数也是可以捕获错误的：

```arcade
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res => console.log(res), 
  err => console.log(err))复制代码
```

#### 4.3 题目三

接下来让我们看看另一个有趣的方法`.race`。

让我看看你们的英语水平如何？

快！一秒钟告诉我`race`是什么意思？



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bb15866277a4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



好吧...你们果然很强...

`race`，比赛，赛跑的意思。

所以使用`.race()`方法，它只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，不过`race`已经不管那些任务的结果了。

来，改造一下`4.1`这道题：

```arcade
function runAsync (x) {
  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
  return p
}
Promise.race([runAsync(1), runAsync(2), runAsync(3)])
  .then(res => console.log('result: ', res))
  .catch(err => console.log(err))复制代码
```

执行结果为：

```scheme
1
'result: ' 1
2
3复制代码
```

> 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作

#### 4.4 题目四

改造一下题目`4.2`：

```arcade
function runAsync(x) {
  const p = new Promise(r =>
    setTimeout(() => r(x, console.log(x)), 1000)
  );
  return p;
}
function runReject(x) {
  const p = new Promise((res, rej) =>
    setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x)
  );
  return p;
}
Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])
  .then(res => console.log("result: ", res))
  .catch(err => console.log(err));复制代码
```

遇到错误的话，也是一样的，在这道题中，`runReject(0)`最先执行完，所以进入了`catch()`中：

```scheme
0
'Error: 0'
1
2
3复制代码
```

#### 总结

好的，让我们来总结一下`.then()`和`.race()`吧，😄

- `Promise.all()`的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。
- `.race()`的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。
- `Promise.all().then()`结果中数组的顺序和`Promise.all()`接收到的数组顺序一致。
- `all和race`传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被`then`的第二个参数或者后面的`catch`捕获；但并不会影响数组中其它的异步任务的执行。

### 5. async/await的几道题

既然谈到了`Promise`，那就肯定得再说说`async/await`，在很多时候`async`和`Promise`的解法差不多，又有些不一样。不信你来看看题目一。

#### 5.1 题目一

```arcade
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
async1();
console.log('start')复制代码
```

这道基础题输出的是啥？

答案：

```sml
'async1 start'
'async2'
'start'
'async1 end'复制代码
```

过程分析：

- 首先一进来是创建了两个函数的，我们先不看函数的创建位置，而是看它的调用位置
- 发现`async1`函数被调用了，然后去看看调用的内容
- 执行函数中的同步代码`async1 start`，之后碰到了`await`，它会阻塞`async1`后面代码的执行，因此会先去执行`async2`中的同步代码`async2`，然后跳出`async1`
- 跳出`async1`函数后，执行同步代码`start`
- 在一轮宏任务全部执行完之后，再来执行刚刚`await`后面的内容`async1 end`。

在这里，你可以理解为「紧跟着await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中」。

让我们来看看将`await`转换为`Promise.then`的伪代码：

```arcade
async function async1() {
  console.log("async1 start");
  // 原来代码
  // await async2();
  // console.log("async1 end");
  
  // 转换后代码
  new Promise(resolve => {
    console.log("async2")
    resolve()
  }).then(res => console.log("async1 end"))
}
async function async2() {
  console.log("async2");
}
async1();
console.log("start")复制代码
```

转换后的伪代码和前面的执行结果是一样的。(感谢评论区[Wing93](https://juejin.cn/user/3421335914314061)和[Jexxie](https://juejin.cn/user/1926000100012317)小伙伴的指出)

另外关于`await`和`Promise`的区别，如果我们把`await async2()`换成一个`new Promise`呢？

```arcade
async function async1() {
  console.log("async1 start");
  new Promise(resolve => {
    console.log('promise')
  })
  console.log("async1 end");
}
async1();
console.log("start")复制代码
```

此时的执行结果为：

```sml
'async start'
'promise'
'async1 end'
'start'复制代码
```

可以看到`new Promise()`并不会阻塞后面的同步代码`async1 end`的执行。

#### 5.2 题目二

现在将`async`结合定时器看看。

给题目一中的 `async2`函数中加上一个定时器：

```arcade
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  setTimeout(() => {
    console.log('timer')
  }, 0)
  console.log("async2");
}
async1();
console.log("start")复制代码
```

没错，定时器始终还是最后执行的，它被放到下一条宏任务的延迟队列中。

答案：

```sml
'async1 start'
'async2'
'start'
'async1 end'
'timer'复制代码
```

#### 5.3 题目三

来吧，小伙伴们，让我们多加几个定时器看看。😁

```arcade
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
  setTimeout(() => {
    console.log('timer1')
  }, 0)
}
async function async2() {
  setTimeout(() => {
    console.log('timer2')
  }, 0)
  console.log("async2");
}
async1();
setTimeout(() => {
  console.log('timer3')
}, 0)
console.log("start")复制代码
```

思考一下🤔，执行结果会是什么？

其实如果你能做到这里了，说明你前面的那些知识点也都掌握了，我就不需要太过详细的步骤分析了。

直接公布答案吧：

```sml
'async1 start'
'async2'
'start'
'async1 end'
'timer2'
'timer3'
'timer1'复制代码
```

定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是`0`，所以只要关注谁先被调用的。。

#### 5.4 题目四

正常情况下，`async`中的`await`命令是一个`Promise`对象，返回该对象的结果。

但如果不是`Promise`对象的话，就会直接返回对应的值，相当于`Promise.resolve()`

```arcade
async function fn () {
  // return await 1234
  // 等同于
  return 123
}
fn().then(res => console.log(res))复制代码
```

结果：

```
123复制代码
```

#### 5.5 题目五

```arcade
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')复制代码
```

这道题目比较有意思，大家要注意了。

在`async1`中`await`后面的`Promise`是没有返回值的，也就是它的状态始终是`pending`状态，因此相当于一直在`await`，`await`，`await`却始终没有响应...



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bb1987d7181b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



所以在`await`之后的内容是不会执行的，也包括`async1`后面的 `.then`。

答案为：

```sml
'script start'
'async1 start'
'promise1'
'script end'复制代码
```

#### 5.6 题目六

让我们给`5.5`中的`Promise`加上`resolve`：

```arcade
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
    resolve('promise1 resolve')
  }).then(res => console.log(res))
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')复制代码
```

现在`Promise`有了返回值了，因此`await`后面的内容将会被执行：

```sml
'script start'
'async1 start'
'promise1'
'script end'
'promise1 resolve'
'async1 success'
'async1 end'复制代码
```

#### 5.7 题目七

```arcade
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
    resolve('promise resolve')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => {
  console.log(res)
})
new Promise(resolve => {
  console.log('promise2')
  setTimeout(() => {
    console.log('timer')
  })
})复制代码
```

这道题应该也不难，不过有一点需要注意的，在`async1`中的`new Promise`它的`resovle`的值和`async1().then()`里的值是没有关系的，很多小伙伴可能看到`resovle('promise resolve')`就会误以为是`async1().then()`中的返回值。

因此这里的执行结果为：

```sml
'script start'
'async1 start'
'promise1'
'promise2'
'async1 success'
'async1 end'
'timer'复制代码
```

#### 5.8 题目八

我们再来看一道头条曾经的面试题：

```arcade
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}

async function async2() {
  console.log("async2");
}

console.log("script start");

setTimeout(function() {
  console.log("setTimeout");
}, 0);

async1();

new Promise(function(resolve) {
  console.log("promise1");
  resolve();
}).then(function() {
  console.log("promise2");
});
console.log('script end')复制代码
```

有了上面👆几题做基础，相信你很快也能答上来了。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bb005aa667c3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



自信的写下你们的答案吧。

```sml
'script start'
'async1 start'
'async2'
'promise1'
'script end'
'async1 end'
'promise2'
'setTimeout'复制代码
```

(这道题最后`async1 end`和`promise2`的顺序其实在网上饱受争议，我这里使用浏览器`Chrome V80`，`Node v12.16.1`的执行结果都是上面这个答案)

#### 5.9 题目九

好的👌，`async/await`大法已练成，咱们继续：

```arcade
async function testSometing() {
  console.log("执行testSometing");
  return "testSometing";
}

async function testAsync() {
  console.log("执行testAsync");
  return Promise.resolve("hello async");
}

async function test() {
  console.log("test start...");
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
}

test();

var promise = new Promise(resolve => {
  console.log("promise start...");
  resolve("promise");
});
promise.then(val => console.log(val));

console.log("test end...");复制代码
```

答案：

```1c
'test start...'
'执行testSometing'
'promise start...'
'test end...'
'testSometing'
'执行testAsync'
'promise'
'hello async'
'testSometing' 'hello async'复制代码
```

### 6. async处理错误

#### 6.1 题目一

在`async`中，如果 `await`后面的内容是一个异常或者错误的话，会怎样呢？

```arcade
async function async1 () {
  await async2();
  console.log('async1');
  return 'async1 success'
}
async function async2 () {
  return new Promise((resolve, reject) => {
    console.log('async2')
    reject('error')
  })
}
async1().then(res => console.log(res))复制代码
```

例如这道题中，`await`后面跟着的是一个状态为`rejected`的`promise`。

**如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。**

所以答案为：

```aspectj
'async2'
Uncaught (in promise) error复制代码
```

如果改为`throw new Error`也是一样的：

```arcade
async function async1 () {
  console.log('async1');
  throw new Error('error!!!')
  return 'async1 success'
}
async1().then(res => console.log(res))复制代码
```

结果为：

```erlang-repl
'async1'
Uncaught (in promise) Error: error!!!复制代码
```

#### 6.2 题目二

如果想要使得错误的地方不影响`async`函数后续的执行的话，可以使用`try catch`

```arcade
async function async1 () {
  try {
    await Promise.reject('error!!!')
  } catch(e) {
    console.log(e)
  }
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res => console.log(res))
console.log('script start')复制代码
```

这里的结果为：

```1c
'script start'
'error!!!'
'async1'
'async1 success'复制代码
```

或者你可以直接在`Promise.reject`后面跟着一个`catch()`方法：

```arcade
async function async1 () {
  // try {
  //   await Promise.reject('error!!!')
  // } catch(e) {
  //   console.log(e)
  // }
  await Promise.reject('error!!!')
    .catch(e => console.log(e))
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res => console.log(res))
console.log('script start')复制代码
```

运行结果是一样的。

### 7. 综合题

上面👆的题目都是被我拆分着说一些功能点，现在让我们来做一些比较难的综合题吧。

#### 7.1 题目一

```arcade
const first = () => (new Promise((resolve, reject) => {
    console.log(3);
    let p = new Promise((resolve, reject) => {
        console.log(7);
        setTimeout(() => {
            console.log(5);
            resolve(6);
            console.log(p)
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) => {
        console.log(arg);
    });
}));
first().then((arg) => {
    console.log(arg);
});
console.log(4);复制代码
```

过程分析：

- 第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在`4`之前，所以可以来看看`first`函数里面的内容了。(这一步有点类似于题目`1.5`)
- 函数`first`返回的是一个`new Promise()`，因此先执行里面的同步代码`3`
- 接着又遇到了一个`new Promise()`，直接执行里面的同步代码`7`
- 执行完`7`之后，在`p`中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走
- 碰到了`resolve(1)`，这里就把`p`的状态改为了`resolved`，且返回值为`1`，不过这里也先不执行
- 跳出`p`，碰到了`resolve(2)`，这里的`resolve(2)`，表示的是把`first`函数返回的那个`Promise`的状态改了，也先不管它。
- 然后碰到了`p.then`，将它加入本次循环的微任务列表，等待执行
- 跳出`first`函数，遇到了`first().then()`，将它加入本次循环的微任务列表(`p.then`的后面执行)
- 然后执行同步代码`4`
- 本轮的同步代码全部执行完毕，查找微任务列表，发现`p.then`和`first().then()`，依次执行，打印出`1和2`
- 本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码`5`
- 然后又遇到了一个`resolve(6)`，它是放在`p`里的，但是`p`的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说`resolve(6)`相当于没任何用处，因此打印出来的`p`为`Promise{: 1}`。(这一步类似于题目`3.1`)

结果：

```apache
3
7
4
1
2
5
Promise{<resolved>: 1}复制代码
```

做对了的小伙伴奖励自己一朵小`(大)`红`(嘴)`花`(巴)`吧，😄



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bb1c9abe9b51~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



#### 7.2 题目二

```arcade
const async1 = async () => {
  console.log('async1');
  setTimeout(() => {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 end')
  return 'async1 success'
} 
console.log('script start');
async1().then(res => console.log(res));
console.log('script end');
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res => console.log(res))
setTimeout(() => {
  console.log('timer2')
}, 1000)复制代码
```

注意的知识点：

- `async`函数中`await`的`new Promise`要是没有返回值的话则不执行后面的内容(类似题`5.5`)
- `.then`函数中的参数期待的是函数，如果不是函数的话会发生透传(类似题`3.8` )
- 注意定时器的延迟时间

因此本题答案为：

```sml
'script start'
'async1'
'promise1'
'script end'
1
'timer2'
'timer1'复制代码
```

#### 7.3 题目三

```arcade
const p1 = new Promise((resolve) => {
  setTimeout(() => {
    resolve('resolve3');
    console.log('timer1')
  }, 0)
  resolve('resovle1');
  resolve('resolve2');
}).then(res => {
  console.log(res)
  setTimeout(() => {
    console.log(p1)
  }, 1000)
}).finally(res => {
  console.log('finally', res)
})复制代码
```

注意的知识点：

- `Promise`的状态一旦改变就无法改变(类似题目`3.5`)
- `finally`不管`Promise`的状态是`resolved`还是`rejected`都会执行，且它的回调函数是接收不到`Promise`的结果的，所以`finally()`中的`res`是一个迷惑项(类似`3.10`)。
- 最后一个定时器打印出的`p1`其实是`.finally`的返回值，我们知道`.finally`的返回值如果在没有抛出错误的情况下默认会是上一个`Promise`的返回值(`3.10`中也有提到), 而这道题中`.finally`上一个`Promise`是`.then()`，但是这个`.then()`并没有返回值，所以`p1`打印出来的`Promise`的值会是`undefined`，如果你在定时器的**下面**加上一个`return 1`，则值就会变成`1`(感谢掘友[JS丛中过](https://juejin.cn/user/2260251637193639)的指出)。

答案：

```coffeescript
'resolve1'
'finally' undefined
'timer1'
Promise{<resolved>: undefined}复制代码
```

### 8. 几道大厂的面试题

#### 8.1 使用Promise实现每隔1秒输出1,2,3

这道题比较简单的一种做法是可以用`Promise`配合着`reduce`不停的在`promise`后面叠加`.then`，请看下面的代码：

```coffeescript
const arr = [1, 2, 3]
arr.reduce((p, x) => {
  return p.then(() => {
    return new Promise(r => {
      setTimeout(() => r(console.log(x)), 1000)
    })
  })
}, Promise.resolve())复制代码
```

或者你可以更简单一点写：

```coffeescript
const arr = [1, 2, 3]
arr.reduce((p, x) => p.then(() => new Promise(r => setTimeout(() => r(console.log(x)), 1000))), Promise.resolve())复制代码
```

参考链接：[如何让异步操作顺序执行](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fq%2F1010000010748967)

**拓展题**

这道拓展题来自于“万物皆可爱的[LINGLONG](https://juejin.cn/user/2436173498955032) ”小姐姐，炒鸡棒 😁👍。

题目是这样的，她把我上面👆写的箭头函数版本改造了一下：

```javascript
const arr = [1, 2, 3];
const result = arr.reduce((p, x) => p.then(new Promise(r => setTimeout(() => r(console.log(x)), 1000))), Promise.resolve());复制代码
```

眼尖的小伙伴看出区别了吗？😁

`p.then`里的代码由`() => new Promise(...)`变成了`new Promise(...)`。

现在执行结果就大不相同了。

**在一秒后按顺序同时打印出`1、2、3`:**

```
1
2
3复制代码
```

咦 🤔️？为什么会这样呢 🤔️？

只是一个小小的改变却有大大的区别。

其实刚开始看到的时候霖呆呆我也愣了那么几秒😂。不过等我们一步一步拆分并对想不通的地方写了几个案例来看就理解了。

评论区和小姐姐扯了一大堆，结果把她越弄越糊😂。后来我改变了一种思路来描述，觉得应该直接上伪代码：

```coffeescript
const arr = [1, 2, 3]
arr.reduce((p, x) => p.then(() => new Promise(r => setTimeout(() => r(console.log(x)), 1000))), Promise.resolve())复制代码
```

转换为伪代码就是这样：

(相当于是用`reduce`不停的往后面叠加`.then`)

```arcade
Promise.resolve()
  .then(() => {
    return new Promise(r => {
      setTimeout(() => {
        r(console.log(1))
      }, 1000)
    })
  })
  .then(r => {
    return new Promise(r => {
      setTimeout(() => {
        r(console.log(2))
      }, 1000)
    })
  })
  .then(r => {
    return new Promise(r => {
      setTimeout(() => {
        r(console.log(3))
      }, 1000)
    })
  })复制代码
```

可以看到，每一个`.then`都是依赖于上一个`new Promise`何时被`resolve`了才会执行的，例如第二个`.then()`，它要等`r(console.log(1)`这段代码执行了，才会执行。

那么`r(console.log(1))`什么时候执行呢？就是在第一个定时器(也就是一秒后)触发的时候才执行。这样就保证了后面接着的`.then()`要等前一个定时器执行完才能执行，也就是隔一秒输出。

而如果是这样写的话：

```javascript
const arr = [1, 2, 3];
const result = arr.reduce((p, x) => p.then(new Promise(r => setTimeout(() => r(console.log(x)), 1000))), Promise.resolve());复制代码
```

它的伪代码就是这样：

(每个`then`里面的第一个参数不是一个函数)

```arcade
Promise.resolve()
  .then(new Promise(r => {
    setTimeout(() => {
      r(console.log(1))
    }, 1000)
  }))
  .then(new Promise(r => {
    setTimeout(() => {
      r(console.log(2))
    }, 1000)
  }))
  .then(new Promise(r => {
    setTimeout(() => {
      r(console.log(3))
    }, 1000)
  }))复制代码
```

`p.then()`里面的参数如果不是函数的话，会发生透传，这个在`3.8`中已经提过了。但是发生透传，`.then()`里的代码就不执行了吗？

并不是的，我们来看这个例子：

```arcade
const p = Promise.resolve(1).then(console.log('我不关心结果'))
console.log(p)
p.then((res) => console.log(res))复制代码
```

很明显这里也发生了透传，但是`'我不关心结果'`也还是被打印出来了，并且由于透传，`p.then()`里获取到的`res`就是`1`，因此会打印出：

```lua
'我不关心结果'
Promise{
[[PromiseStatus]]: "resolved"
[[PromiseValue]]: 1
}
1复制代码
```

(第二行打印出`Promise{}`的小伙伴请把这个对象展开来看)

这个例子表明，就算发生了透传，`p.then()`中的代码依旧也是会执行的。

所以回到

```arcade
.then(new Promise(r => {
    setTimeout(() => {
      r(console.log(1))
    }, 1000)
  }))复制代码
```

中，现在`.then()`中就相当于是执行一段同步代码：

```arcade
new Promise(r => {
    setTimeout(() => {
      r(console.log(1))
    }, 1000)
  })复制代码
```

而这段代码的作用是向延迟队列中`push`一个一秒后执行的定时器任务。

并且在`push`完定时器之后，代码就马上进入了下一个`.then`(因为既然第一个`.then`已经是透传的了就没有必要等它的执行结果了)

下一个`.then`竟然也是一个透传，OK，那我继续`push`这个定时器，然后再执行第三个`.then`。

三个`.then`已经执行完成了，现在我们的延迟队列中已经有了三个定时器等待执行，**并且三个定时器的延迟时间都是1000ms!!!**。

所以等到了时间之后，就会同时打印出来了`1、2、3`。（其实准确来说，不是同时打印的，不过中间相差的时间非常非常短，大可忽略它）

现在你是否理解了其中的区别呢 😝。

#### 8.2 使用Promise实现红绿灯交替重复亮

红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：

```arcade
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}复制代码
```

答案：

```arcade
function red() {
  console.log("red");
}
function green() {
  console.log("green");
}
function yellow() {
  console.log("yellow");
}
const light = function (timer, cb) {
  return new Promise(resolve => {
    setTimeout(() => {
      cb()
      resolve()
    }, timer)
  })
}
const step = function () {
  Promise.resolve().then(() => {
    return light(3000, red)
  }).then(() => {
    return light(2000, green)
  }).then(() => {
    return light(1000, yellow)
  }).then(() => {
    return step()
  })
}

step();复制代码
```

#### 8.3 实现mergePromise函数

实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。

```arcade
const time = (timer) => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve()
    }, timer)
  })
}
const ajax1 = () => time(2000).then(() => {
  console.log(1);
  return 1
})
const ajax2 = () => time(1000).then(() => {
  console.log(2);
  return 2
})
const ajax3 = () => time(1000).then(() => {
  console.log(3);
  return 3
})

function mergePromise () {
  // 在这里写代码
}

mergePromise([ajax1, ajax2, ajax3]).then(data => {
  console.log("done");
  console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]复制代码
```

这道题有点类似于`Promise.all()`，不过`.all()`不需要管执行顺序，只需要并发执行就行了。但是这里需要等上一个执行完毕之后才能执行下一个。

解题思路：

- 定义一个数组`data`用于保存所有异步操作的结果
- 初始化一个`const promise = Promise.resolve()`，然后循环遍历数组，在`promise`后面添加执行`ajax`任务，同时要将添加的结果重新赋值到`promise`上。

答案：

```arcade
function mergePromise (ajaxArray) {
  // 存放每个ajax的结果
  const data = [];
  let promise = Promise.resolve();
  ajaxArray.forEach(ajax => {
  	// 第一次的then为了用来调用ajax
  	// 第二次的then是为了获取ajax的结果
    promise = promise.then(ajax).then(res => {
      data.push(res);
      return data; // 把每次的结果返回
    })
  })
  // 最后得到的promise它的值就是data
  return promise;
}复制代码
```

#### 8.4 根据promiseA+实现一个自己的promise

说真的，这道题被问到的概率还是挺高的，而且要说的内容也很多...

霖呆呆这里偷个懒，不想细说了...

不过哈，我保证，下下题我一定仔细说 😼.



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bb0d2846ea40~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



来吧，给你们一些好的宝典：

- [《Promise不会？？看这里！！！史上最通俗易懂的Promise！！！》](https://juejin.cn/post/6844903607968481287#heading-7)
- [《写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise》](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F23312442)

#### 8.5 封装一个异步加载图片的方法

这个相对简单一些，只需要在图片的`onload`函数中，使用`resolve`返回一下就可以了。

来看看具体代码：

```reasonml
function loadImg(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = function() {
      console.log("一张图片加载完成");
      resolve(img);
    };
    img.onerror = function() {
    	reject(new Error('Could not load image at' + url));
    };
    img.src = url;
  });复制代码
```

#### 8.6 限制异步操作的并发个数并尽可能快的完成全部

有8个图片资源的url，已经存储在数组`urls`中。

```
urls`类似于`['https://image1.png', 'https://image2.png', ....]
```

而且已经有一个函数`function loadImg`，输入一个`url`链接，返回一个`Promise`，该`Promise`在图片下载完成的时候`resolve`，下载失败则`reject`。

但有一个要求，任何时刻同时下载的链接**数量不可以超过3个**。

请写一段代码实现这个需求，要求**尽可能快速**地将所有图片下载完成。

```javascript
var urls = [
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png",
];
function loadImg(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = function() {
      console.log("一张图片加载完成");
      resolve(img);
    };
    img.onerror = function() {
    	reject(new Error('Could not load image at' + url));
    };
    img.src = url;
  });复制代码
```

看到这道题时，我最开始的想法是：

- 拿到`urls`，然后将这个数组每3个`url`一组创建成一个二维数组
- 然后用`Promise.all()`每次加载一组`url`（也就是并发3个），这一组加载完再加载下一组。

这个想法从技术上说并不难实现，有点类似于第三题。不过缺点也明显，那就是每次都要等到上一组全部加载完之后，才加载下一组，那如果上一组有`2`个已经加载完了，还有`1`个特别慢，还在加载，要等这个慢的也加载完才能进入下一组。这明显会照常卡顿，影响加载效率。

但是开始没有考虑这么多，因此有了第一个版本。

**如果你有兴趣可以看看想法一的代码，虽然对你没什么帮助，想直接知道比较好的做法的小伙伴请跳到想法二**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bb10eebdcc6e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



**想法一**💡：

```arcade
function limitLoad (urls, handler, limit) {
  const data = []; // 存储所有的加载结果
  let p = Promise.resolve();
  const handleUrls = (urls) => { // 这个函数是为了生成3个url为一组的二维数组
    const doubleDim = [];
    const len = Math.ceil(urls.length / limit); // Math.ceil(8 / 3) = 3
    console.log(len) // 3, 表示二维数组的长度为3
    for (let i = 0; i < len; i++) {
      doubleDim.push(urls.slice(i * limit, (i + 1) * limit))
    }
    return doubleDim;
  }
  const ajaxImage = (urlCollect) => { // 将一组字符串url 转换为一个加载图片的数组
    console.log(urlCollect)
    return urlCollect.map(url => handler(url))
  }
  const doubleDim = handleUrls(urls); // 得到3个url为一组的二维数组
  doubleDim.forEach(urlCollect => {
    p = p.then(() => Promise.all(ajaxImage(urlCollect))).then(res => {
      data.push(...res); // 将每次的结果展开，并存储到data中 (res为：[img, img, img])
      return data;
    })
  })
  return p;
}
limitLoad(urls, loadImg, 3).then(res => {
  console.log(res); // 最终得到的是长度为8的img数组: [img, img, img, ...]
  res.forEach(img => {
    document.body.appendChild(img);
  })
});复制代码
```

**想法二**💡：

参考[LHH大翰仔仔-Promise面试题](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4bb1521343ba)

既然题目的要求是保证每次并发请求的数量为3，那么我们可以先请求`urls`中的前面三个(下标为`0,1,2`)，并且请求的时候使用`Promise.race()`来同时请求，三个中有一个先完成了(例如下标为`1`的图片)，我们就把这个当前数组中已经完成的那一项(第`1`项)换成还没有请求的那一项(`urls`中下标为`3`)。

直到`urls`已经遍历完了，然后将最后三个没有完成的请求(也就是状态没有改变的`Promise`)用`Promise.all()`来加载它们。

不多说，流程图都给你画好了，你可以结合流程图再来看代码。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708b0d2d7baa165~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



为了方便你查看，我截了个图，不过代码在后面也有

(说真的，要我看这一大长串代码我也不愿意...)



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708b0e23417a9ec~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



代码：

```arcade
function limitLoad(urls, handler, limit) {
  let sequence = [].concat(urls); // 复制urls
  // 这一步是为了初始化 promises 这个"容器"
  let promises = sequence.splice(0, limit).map((url, index) => {
    return handler(url).then(() => {
      // 返回下标是为了知道数组中是哪一项最先完成
      return index;
    });
  });
  // 注意这里要将整个变量过程返回，这样得到的就是一个Promise，可以在外面链式调用
  return sequence
    .reduce((pCollect, url) => {
      return pCollect
        .then(() => {
          return Promise.race(promises); // 返回已经完成的下标
        })
        .then(fastestIndex => { // 获取到已经完成的下标
        	// 将"容器"内已经完成的那一项替换
          promises[fastestIndex] = handler(url).then(
            () => {
              return fastestIndex; // 要继续将这个下标返回，以便下一次变量
            }
          );
        })
        .catch(err => {
          console.error(err);
        });
    }, Promise.resolve()) // 初始化传入
    .then(() => { // 最后三个用.all来调用
      return Promise.all(promises);
    });
}
limitLoad(urls, loadImg, 3)
  .then(res => {
    console.log("图片全部加载完毕");
    console.log(res);
  })
  .catch(err => {
    console.error(err);
  });复制代码
```

## 后语

知识无价，支持原创。

参考文章：

- [《ES6之Promise常见面试题》](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_37719279%2Farticle%2Fdetails%2F80950713)
- [《如何让异步操作顺序执行》](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fq%2F1010000010748967)
- [《大白话讲解Promise（一）](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Flvdabao%2Fp%2Fes6-promise-1.html)
- [《LHH大翰仔仔-Promise面试题》](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4bb1521343ba)
- [《今日头条async/await面试题执行顺序》](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fguolinengineer%2Farticle%2Fdetails%2F85067924)
- [ 《(2.4w字,建议收藏)😇原生JS灵魂之问(下), 冲刺🚀进阶最后一公里(附个人成长经验分享)》](https://juejin.cn/post/6844904004007247880)

你盼世界， 我盼望你无bug。这篇文章就介绍到这里，一口气刷完了`45`道题，真的很爽有没有...



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bb814bdc2570~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



反正我做到后面是越来越有劲，也越来越自信了(有点飘，收一下...)

喜欢**霖呆呆**的小伙还希望可以关注霖呆呆的公众号 `LinDaiDai` 或者扫一扫下面的二维码👇👇👇.



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/28/1708bca9d251131d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



我会不定时的更新一些前端方面的知识内容以及自己的原创文章🎉

你的鼓励就是我持续创作的主要动力 😊.



作者：LinDaiDai_霖呆呆
链接：https://juejin.cn/post/6844904077537574919
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 前言

>   不知不觉已经一个半月没有坚持写博客了，事发突然这段时间经历了裁员，面了某大厂，今天也是二十三周岁 

## 1. 早期异步代码困境

- 众所周知，js是单线程的，耗时操作都是交给浏览器来处理，等时间到了从队列中取出执行，设计到事件循环的概念，笔者也分享过，可以看以下，理解了可以更好的理解`promise`。
- 我以一个需求为切入点，我模拟网络请求(异步操作) 
  - 如果网络请求成功了，你告知我成功了
  - 如果网络请求失败了，你告知我失败了

### 1.1 大聪明做法

```javascript
function requestData(url) {
  setTimeout(() => {
    if (url === 'iceweb.io') {
      return '请求成功'
    }
    return '请求失败'
  }, 3000)
}

const result = requestData('iceweb.io')

console.log(result) //undefined
复制代码
```

- 首先你要理解`js`代码的执行顺序，而不是是想当然的，代码其实并不是按照你书写的顺序执行的。

- 那么为什么是 

  ```
  undefined呢
  ```

  ？ 

  - 首先当我执行`requestData`函数，开始执行函数。遇到了异步操作不会阻塞后面代码执行的，因为js是单线程的，所以你写的`return`成功或者失败并没有返回给`requestData`，那我这个函数中，抛开异步操作，里面并没有返回值，所以值为`undefined`。

### 2.2 早期正确做法

```javascript
function requestData(url, successCB, failureCB) {
  setTimeout(() => {
    if (url === 'iceweb.io') {
      successCB('我成功了,把获取到的数据传出去', [{name:'ice', age:22}])
    } else {
      failureCB('url错误，请求失败')
    }
  }, 3000)
}

//3s后 回调successCB 
//我成功了,把获取到的数据传出去 [ { name: 'ice', age: 22 } ]
requestData('iceweb.io', (res, data) => console.log(res, data), rej => console.log(rej))

//3s后回调failureCB
//url错误，请求失败
requestData('icexxx.io', res => console.log(res) ,rej => console.log(rej))
复制代码
```

- 早期解决方案都是传入两个回调，一个失败的，一个成功的。那很多开发者会问这不是挺好的吗？挺简单的，js中函数是一等公民，可以传来传去，但是这样太灵活了，没有规范。
- 如果使用的是框架，还要阅读一下框架源码，正确失败的传实参的顺序，如果传参顺序错误这样是非常危险的。

## 2. Promise

- `Promise`(承诺)，给予调用者一个承诺，过一会返回数据给你，就可以创建一个promise对象

- 当我们`new`一个`promise`，此时我们需要传递一个回调函数，这个函数为立即执行的，称之为（executor）

- 这个回调函数，我们需要传入两个参数回调函数，

  ```
  reslove
  ```

  ,

  ```
  reject
  ```

  (函数可以进行传参) 

  - 当执行了`reslove`函数，会回调promise对象的.then函数
  - 当执行了`reject`函数，会回调promise对象的.catche函数

### 2.1 Executor立即执行

```javascript
new Promise((resolve, reject) => {
  console.log(`executor 立即执行`)
})
复制代码
```

- 传入的`executor`是立即执行的

### 2.2 requestData 重构

```javascript
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (url === 'iceweb.io') {
        //只能传递一个参数
        resolve('我成功了,把获取到的数据传出去')
      } else {
        reject('url错误，请求失败')
      }
    }, 3000)    
  })
}

//1. 请求成功
requestData('iceweb.io').then(res => {
  //我成功了,把获取到的数据传出去
  console.log(res)
})

//2. 请求失败

//2.2 第一种写法
//url错误，请求失败
requestData('iceweb.org').then(res => {},rej => console.log(rej))

//2.2 第二种写法
//url错误，请求失败
requestData('iceweb.org').catch(e => console.log(e))
复制代码
```

- 在函数中，new这个类的时候，传入的回调函数称之为`executor`（会被Promise类中自动执行）

- 在正确的时候调用`resolve`函数，失败的时候调用`reject`函数，把需要的参数传递出去。

- 异常处理 

  - 其中在

    ```
    .then
    ```

    方法中可以传入两个回调，您也可以查看

    Promise/A+

    规范 

    - 第一个则是`fulfilled`的回调
    - 第二个则是`rejected`的回调

- 那这样有什么好处呢？ 看起来比早期处理的方案还要繁琐呢? 

  1. 统一规范，可以增强阅读性和扩展性
  2. 小幅度减少回调地狱

### 2.3 promise的状态

- 首先先给大家举个栗子，把代码抽象为现实的栗子 

  - 你答应你女朋友，下周末带她去吃好吃的 (还未到下周末，此时状态为**待定状态**)
  - 时间飞快，今天就是周末了，你和你女友一起吃了烤肉、甜点、奶茶...（**已兑现状态**）
  - 时间飞快，今天就是周末了，正打算出门。不巧产品经理，因为线上出现的紧急问题，需要回公司解决一下，你(为了生活)只能委婉的拒绝一下女友，并且说明一下缘由(**已拒绝状态**)

- 使用

  ```
  promise
  ```

  的时候，给它一个承诺，我们可以将他划分为三个阶段 

  - pending(待定)，执行了executor，状态还在等待中，没有被兑现，也没有被拒绝
  - fulfilled(已兑现)，执行了`resolve`函数则代表了已兑现状态
  - rejected(已拒绝)，执行了`reject`函数则代表了已拒绝状态

- 首先，状态只要从待定状态，变为其他状态，则状态不能再改变

思考以下代码:

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('失败')
    resolve('成功')
  }, 3000);
})

promise.then(res => console.log(res)).catch(err => console.log(err))

//失败 
复制代码
```

- 当我调用`reject`之后，在调用`resolve`是无效的，因为状态已经发生改变，并且是不可逆的。

### 2.4 resolve不同值的区别

- 如果`resolve`传入一个普通的值或者对象，**只能传递接受一个参数**，那么这个值会作为`then`回调的参数

```javascript
const promise = new Promise((resolve, reject) => {
  resolve({name: 'ice', age: 22})
})

promise.then(res => console.log(res))

// {name: 'ice', age: 22}
复制代码
```

- 如果`resolve`中传入的是另外一个`Promise`，那么这个新`Promise`会决定原`Promise`的状态

```javascript
const promise = new Promise((resolve, reject) => {
  resolve(new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('ice')
    }, 3000);
  }))
})

promise.then(res => console.log(res))

//3s后 ice
复制代码
```

- 如果`resolve`中传入的是一个对象，并且这个对象有实现`then`方法，那么会执行该`then`方法，`then`方法会传入`resolve`，`reject`函数。此时的`promise`状态取决于你调用了`resolve`，还是`reject`函数。这种模式也称之为: **thenable**

```javascript
const promise = new Promise((resolve, reject) => {
  resolve({
    then(res, rej) {
      res('hi ice')
    }
  })
})

promise.then(res => console.log(res))

// hi ice
复制代码
```

### 2.5 Promise的实例方法

- 实例方法，存放在`Promise.prototype`上的方法，也就是Promise的显示原型上，当我new Promise的时候，会把返回的改对象的 promise[[prototype]]（隐式原型） === Promise.prototype (显示原型)
- 即new返回的对象的隐式原型指向了Promise的显示原型

#### 2.5.1 then方法

##### 2.5.1.1 then的参数

- `then`方法可以接受参数，一个参数为成功的回调，另一个参数为失败的回调，前面重构`requestData`中有演练过。

```javascript
const promise = new Promise((resolve, reject) => {
  resolve('request success')
  // reject('request error')
})

promise.then(res => console.log(res), rej => console.log(rej))

//request success
复制代码
```

- 如果只捕获错误，还可以这样写 
  - 因为第二个参数是捕获异常的，第一个可以写个`null`或`""`占位

```javascript
const promise = new Promise((resolve, reject) => {
  // resolve('request success')
  reject('request error')
})

promise.then(null, rej => console.log(rej))

//request error
复制代码
```

##### 2.5.1.2 then的多次调用

```javascript
const promise = new Promise((resolve, reject) => {
  resolve('hi ice')
})

promise.then(res => console.log(res))
promise.then(res => console.log(res))
promise.then(res => console.log(res))
复制代码
```

- 调用多次则会执行多次

##### 2.5.1.3 then的返回值

- `then`方法是有返回值的，它的返回值是`promise`，但是是`promise`那它的状态如何决定呢？接下来让我们一探究竟。

###### 2.5.1.3.1 返回一个普通值 ***状态:fulfilled***

```javascript
const promise = new Promise((resolve, reject) => {
  resolve('hi ice')
})

promise.then(res => ({name:'ice', age:22}))
       .then(res => console.log(res))
       
//{name:'ice', age:22}
复制代码
```

- 返回一个普通值，则相当于主动调用`Promise.resolve`，并且把返回值作为实参传递到`then`方法中。
- 如果没有返回值，则相当于返回`undefined`

###### 2.5.1.3.2 明确返回一个promise ***状态:fulfilled***

```javascript
const promise = new Promise((resolve, reject) => {
  resolve('hi ice')
})

promise.then(res => {
  return new Promise((resolve, reject) => {
    resolve('then 的返回值')
  })
}).then(res => console.log(res))

//then 的返回值
复制代码
```

- 主动返回一个`promise`对象，状态和你调用`resolve`，还是`reject`有关

###### 2.5.1.3.3 返回一个thenable对象 ***状态：fulfilled***

```javascript
const promise = new Promise((resolve, reject) => {
  resolve('hi ice')
})

promise.then(res => {
  return {
    then(resolve, reject) {
      resolve('hi webice')
    }
  }
}).then(res => console.log(res))

//hi webice
复制代码
```

- 返回了一个thenable对象，其状态取决于你是调用了`resolve`,还是`reject`

#### 2.5.2 catch方法

##### 2.5.2.1 catch的多次调用

```javascript
const promise = new Promise((resolve, reject) => {
  reject('ice error')
})

promise.catch(err => console.log(err))
promise.catch(err => console.log(err))
promise.catch(err => console.log(err))

//ice error
//ice error
//ice error
复制代码
```

##### 2.5.2.2 catch的返回值

- catch方法是有返回值的，它的返回值是promise，但是是promise那它的状态如何决定呢？接下来让我们一探究竟。
- 如果返回值明确一个promise或者thenable对象，取决于你调用了`resolve`还是`reject`

###### 2.5.2.2.1 返回一个普通对象

```javascript
const promise = new Promise((resolve, reject) => {
  reject('ice error')
})

promise.catch(err => ({name:'ice', age: 22})).then(res => console.log(res))

//{name:'ice', age: 22}
复制代码
```

###### 2.5.2.2.2 明确返回一个promise

```javascript
const promise = new Promise((resolve, reject) => {
  reject('ice error')
})

promise.catch(err => {
  return new Promise((resolve, reject) => {
    reject('ice error promise')
  })
}).catch(res => console.log(res))

//ice error promise
复制代码
```

- 此时`new Promise() `调用了`reject`函数，则会被`catch`捕获到

###### 2.5.2.2.3 返回thenable对象

```javascript
const promise = new Promise((resolve, reject) => {
  reject('ice error')
})

promise.catch(err => {
  return {
    then(resolve, reject) {
      reject('ice error then')
    }
  }
}).catch(res => console.log(res))

//ice error then
复制代码
```

#### 2.5.3 finally方法

- ES9（2018）新实例方法
- finally(最后)，无论promise状态是fulfilled还是rejected都会执行一次`finally`方法

```javascript
const promise = new Promise((resolve, reject) => {
  resolve('hi ice')
})

promise.then(res => console.log(res)).finally(() => console.log('finally execute'))

//finally execute
复制代码
```

### 2.6 Promise中的类方法/静态方法

#### 2.6.1 Promise.reslove

```javascript
Promise.resolve('ice')
//等价于
new Promise((resolve, reject) => resolve('ice'))
复制代码
```

- 有的时候，你已经预知了状态的结果为fulfilled，则可以用这种简写方式

#### 2.6.2 Promise.reject

```javascript
Promise.reject('ice error')
//等价于
new Promise((resolve, reject) => reject('ice error'))
复制代码
```

- 有的时候，你已经预知了状态的结果为rejected，则可以用这种简写方式

#### 2.6.3 Promise.all

**fulfilled 状态**

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi ice')
  }, 1000);
})

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi panda')
  }, 2000);
})

const promise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi grizzly')
  }, 3000);
})


Promise.all([promise1, promise2, promise3]).then(res => console.log(res))

//[ 'hi ice', 'hi panda', 'hi grizzly' ]
复制代码
```

- all方法的参数传入为一个可迭代对象，返回一个promise，只有三个都为`resolve`状态的时候才会调用`.then`方法。
- 只要有一个promise的状态为rejected，则会回调`.catch`方法

**rejected状态**

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi ice')
  }, 1000);
})

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('hi panda')
  }, 2000);
})

const promise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi grizzly')
  }, 3000);
})

Promise.all([promise1, promise2, promise3]).then(res => console.log(res)).catch(err => console.log(err))

//hi panda
复制代码
```

- 当遇到rejectd的时候，后续的promise结果我们是获取不到，并且会把reject的实参，传递给catch的err形参中

#### 2.6.4 Promise.allSettled

- 上面的`Promise.all`有一个缺陷，就是当遇到一个rejected的状态，那么对于后面是`resolve`或者`reject`的结果我们是拿不到的
- ES11 新增语法`Promise.allSettled`，无论状态是fulfilled/rejected都会把参数返回给我们

------

**所有promise都有结果**

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('hi ice')
  }, 1000);
})

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi panda')
  }, 2000);
})

const promise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('hi grizzly')
  }, 3000);
})

Promise.allSettled([promise1, promise2, promise3]).then(res => console.log(res))

/* [
  { status: 'rejected', reason: 'hi ice' },
  { status: 'fulfilled', value: 'hi panda' },
  { status: 'rejected', reason: 'hi grizzly' }
] */
复制代码
```

- 该方法会在所有的Promise都有结果，无论是fulfilled，还是rejected，才会有最终的结果

**其中一个promise没有结果**

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('hi ice')
  }, 1000);
})

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi panda')
  }, 2000);
})

const promise3 = new Promise((resolve, reject) => {})


Promise.allSettled([promise1, promise2, promise3]).then(res => console.log(res))
// 什么都不打印
复制代码
```

- 其中一个promise没有结果，则什么都结果都拿不到

#### 2.6.5 Promise.race

- race(竞争竞赛)
- 优先获取第一个返回的结果，无论结果是fulfilled还是rejectd

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('hi error')
  }, 1000);
})

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi panda')
  }, 2000);
})


Promise.race([promise1, promise2])
       .then(res => console.log(res))
       .catch(e => console.log(e))
       
//hi error
复制代码
```

#### 2.6.6 Promise.any

- 与race类似，只获取第一个状态为fulfilled，如果全部为rejected则报错`AggregateError`

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('hi error')
  }, 1000);
})

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('hi panda')
  }, 2000);
})


Promise.any([promise1, promise2])
       .then(res => console.log(res))
       .catch(e => console.log(e))
       
//hi panda
复制代码
```

## 3. Promise的回调地狱 (进阶)

- 我还是以一个需求作为切入点，把知识点嚼碎了，一点一点喂进你们嘴里。 
  - 当我发送网络请求的时候，需要拿到这次网络请求的数据，再发送网络请求，就这样重复三次，才能拿到我最终的结果。

### 3.1 卧龙解法

```javascript
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (url.includes('iceweb')) {
        resolve(url)
      } else {
        reject('请求错误')
      }
    }, 1000);
  })
}


requestData('iceweb.io').then(res => {
  requestData(`iceweb.org ${res}`).then(res => {
    requestData(`iceweb.com ${res}`).then(res => {
      console.log(res)
    })
  })
})

//iceweb.com iceweb.org iceweb.io
复制代码
```

- 虽然能够实现，但是多层代码的嵌套，可读性非常差，我们把这种多层次代码嵌套称之为回调地狱

### 3.2 凤雏解法

```javascript
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (url.includes('iceweb')) {
        resolve(url)
      } else {
        reject('请求错误')
      }
    }, 1000);
  })
}

requestData('iceweb.io').then(res => {
  return requestData(`iceweb.org ${res}`)
}).then(res => {
  return requestData(`iceweb.com ${res}`)
}).then(res => {
  console.log(res)
})

//iceweb.com iceweb.org iceweb.io
复制代码
```

- 利用了then链式调用这一特性，返回了一个新的promise，但是不够优雅，思考一下能不能写成同步的方式呢？

### 3.3 生成器+Promise解法

```javascript
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (url.includes('iceweb')) {
        resolve(url)
      } else {
        reject('请求错误')
      }
    }, 1000);
  })
}

function* getData(url) {
  const res1 = yield requestData(url)
  const res2 = yield requestData(res1)
  const res3 = yield requestData(res2)

  console.log(res3)
}

const generator = getData('iceweb.io')

generator.next().value.then(res1 => {
  generator.next(`iceweb.org ${res1}`).value.then(res2 => {
    generator.next(`iceweb.com ${res2}`).value.then(res3 => {
      generator.next(res3)
    })
  })
})

//iceweb.com iceweb.org iceweb.io
复制代码
```

- 大家可以发现我们的`getData`已经变为同步的形式，可以拿到我最终的结果了。那么很多同学会问，generator一直调用`.next`不是也产生了回调地狱吗？
- 其实不用关心这个，我们可以发现它这个是有规律的，我们可以封装成一个自动化执行的函数，我们就不用关心内部是如何调用的了。

### 3.4 自动化执行函数封装

```javascript
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (url.includes('iceweb')) {
        resolve(url)
      } else {
        reject('请求错误')
      }
    }, 1000);
  })
}

function* getData() {
  const res1 = yield requestData('iceweb.io')
  const res2 = yield requestData(`iceweb.org ${res1}`)
  const res3 = yield requestData(`iceweb.com ${res2}`)

  console.log(res3)
}

//自动化执行 async await相当于自动帮我们执行.next
function asyncAutomation(genFn) {
  const generator = genFn()

  const _automation = (result) => {
    let nextData = generator.next(result)
    if(nextData.done) return

    nextData.value.then(res => {
      _automation(res)
    })
  }

  _automation()
}

asyncAutomation(getData)

//iceweb.com iceweb.org iceweb.io
复制代码
```

- 利用promise+生成器的方式变相实现解决回调地狱问题，其实就是`async await`的一个变种而已
- 最早为**TJ**实现，**前端大神人物**
- async await核心代码就类似这些，内部主动帮我们调用`.next`方法

### 3.5 最终解决回调地狱的办法

```javascript
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (url.includes('iceweb')) {
        resolve(url)
      } else {
        reject('请求错误')
      }
    }, 1000);
  })
}

async function getData() {
  const res1 = await requestData('iceweb.io')
  const res2 = await requestData(`iceweb.org ${res1}`)
  const res3 = await requestData(`iceweb.com ${res2}`)

  console.log(res3)
}

getData()

//iceweb.com iceweb.org iceweb.io
复制代码
```

- 你会惊奇的发现，只要把`getData`生成器函数函数，改为`async`函数，`yeild`的关键字替换为`await`就可以实现异步代码同步写法了。

## 4. async/await 剖析

- async（异步的）
- async 用于申明一个异步函数

### 4.1 async内部代码同步执行

- 异步函数的内部代码执行过程和普通的函数是一致的，默认情况下也是会被同步执行

```javascript
async function sayHi() {
  console.log('hi ice')
}

sayHi()

//hi ice
复制代码
```

### 4.2 异步函数的返回值

- 异步函数的返回值和普通返回值有所区别
  - 普通函数主动返回什么就返回什么，不返回为`undefined`
  - 异步函数的返回值特点 
    - 明确有返回一个普通值，相当于`Promise.resolve`(返回值)
    - 返回一个thenable对象则由，then方法中的`resolve`,或者`reject`有关
    - 明确返回一个promise，则由这个promise决定
- 异步函数中可以使用`await`关键字，现在在全局也可以进行`await`，但是不推荐。会阻塞主进程的代码执行

### 4.3 异步函数的异常处理

- 如果函数内部中途发生错误，可以通过try catch的方式捕获异常
- 如果函数内部中途发生错误，也可以通过函数的返回值.catch进行捕获

```js
async function sayHi() {
  console.log(res)
}
sayHi().catch(e => console.log(e))

//或者

async function sayHi() {
  try {
    console.log(res)
  }catch(e) {
    console.log(e)
  }
}

sayHi()

//ReferenceError: res is not defined
复制代码
```

### 4.4 await 关键字

- 异步函数中可以使用`await`关键字，普通函数不行
- await特点 
  - 通常await关键字后面都是跟一个Promise 
    - 可以是普通值
    - 可以是thenable
    - 可以是Promise主动调用`resolve或者reject`
  - 这个promise状态变为fulfilled才会执行`await`后续的代码，所以`await`后面的代码，相当于包括在`.then`方法的回调中，如果状态变为rejected，你则需要在函数内部`try catch`，或者进行链式调用进行`.catch`操作

```javascript
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (url.includes('iceweb')) {
        resolve(url)
      } else {
        reject('请求错误')
      }
    }, 1000);
  })
}

async function getData() {
  const res = await requestData('iceweb.io')
  console.log(res)
}

getData()

// iceweb.io
复制代码
```

## 5. 结语

- 如果现在真的看不到未来是怎样，你就不如一直往前走，不知道什么时候天亮，去奔跑就好，跑着跑着天就亮了。



作者：上山人
链接：https://juejin.cn/post/7144308012952322084
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 前言

**如果你问我有什么方法可以让自己JS的技术活生生地提升一个等级？** 🙀

**`那就是手写Promise了！！！`** 😺

手写Promise 有一个难点就在于有很多地方需要和原生一样严谨，也就是说原生的Promise会考虑很多特殊情况~🧐

我们在实际运用时可能暂时不会碰到这些情况，可是当我们遇到的时候 **却不知底层的原理，无法精准定位和解决问题，`这就是为什么我们要知道如何手写Promise`**

如果你问我为什么看了这么多教程还是不懂如何手写Promise，那就是因为这里头有很多细节难点，很少人有人愿意把这些都讲出来，不过我今天就要把这里头的细节一个个给抠出来，*所以请大家务必先收藏再观看 ~* 奥力给😸😸😸

手写Promise包含以下知识点 👇：

- Promise
- Class 类
- 改变this指向 (call、apply和bind)
- 事件循环 Event Loop
- 等

不必担心因为上面的知识点不熟练而无法进行"手写Promise"的学习，因为本文附带 `包会套餐` 👇：

- 🔍 如果你不太熟悉Promise的话，建议先看我之前发的那篇Promise文章：[通俗易懂的Promise知识点总结，检验一下你是否真的完全掌握了promise？](https://juejin.cn/post/7020335414980378655)
- 🔍 如果不知道 `类 class` 是如何使用的，建议参考我发的这篇文章：[ES6新特性 Class 类的全方面理解](https://juejin.cn/post/7021069095336411166)
- 🔍 其他知识点讲解文章，会在文中列出，不用担心，你只需要跟着这篇文中走就完了~

手写之前先简要的复习一下 Promise，现在我们就来一边回忆一边实现Promise吧 🪐~

> *如果很熟悉 Promsie 可以跳过下面这一节`(不建议)`*

**◾ promise 核心要点**

> 本章节内容其实并不多，而且通俗易懂，建议不太熟悉Promise的同学还是循序渐进的看完本章再逐步学习Promise核心手写~

`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）

一个 `Promise` 必然处于以下几种状态之一 👇：

- 待定 `(pending)`: 初始状态，既没有被兑现，也没有被拒绝。
- 已成功 `(fulfilled)`: 意味着操作成功完成。
- 已拒绝 `(rejected)`: 意味着操作失败。

当 promise 被调用后，它会以**处理中状态** `(pending)` 开始。 这意味着调用的函数会继续执行，而 promise 仍处于处理中直到解决为止，从而为调用的函数提供所请求的任何数据。

被创建的 promise 最终会以**被解决状态** `(fulfilled)` 或 **被拒绝状态** `(rejected)` 结束，并在完成时调用相应的回调函数（传给 **then** 和 **catch**）。

◾ 为了让读者尽快对promise有一个整体的理解，我们先来看一段promise的例子 🌰：

```javascript
let p1 = new Promise((resolve, reject) => {
    resolve('成功')
    reject('失败')
})
console.log('p1', p1)

let p2 = new Promise((resolve, reject) => {
    reject('失败')
    resolve('成功')
})
console.log('p2', p2)

let p3 = new Promise((resolve, reject) => {
    throw('报错')
})
console.log('p3', p3)
复制代码
```

输出结果为：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/850f66b296cb4c9582a8711c4955db67~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

**这里包含了四个知识点 👇：**

- 1、执行了`resolve()`，Promise状态会变成`fulfilled`，即 **已完成状态**
- 2、执行了`reject()`，Promise状态会变成`rejected`，即 **被拒绝状态**
- 3、Promise只以`第一次为准`，第一次成功就`永久`为`fulfilled`，第一次失败就永远状态为`rejected`
- 4、Promise中有`throw`的话，就相当于执行了`reject()`

◾ 接下来看下面一段代码，学习新的知识点：

```javascript
let myPromise1 = new Promise(() => {});

console.log('myPromise1 :>> ', myPromise1);

let myPromise2 = new Promise((resolve, reject) => {
    let a = 1;
    for (let index = 0; index < 5; index++) {
        a++;
    }
})

console.log('myPromise2 :>> ', myPromise2)

myPromise2.then(() => {
    console.log("myPromise2执行了then");
})
复制代码
```

输出结果为：

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40c613f7a4534fda80b6c13c346dba15~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**这里包含了三个知识点** 👇：

- 1、Promise的初始状态是`pending`
- 2、Promise里没有执行`resolve()`、`reject()`以及`throw`的话，这个**promise的状态也是`pending`**
- 3、基于上一条，`pending`状态下的promise不会执行回调函数`then()`

**◾ 最后一点：**

```javascript
let myPromise0 = new Promise();
console.log('myPromise0 :>> ', myPromise0);
复制代码
```

输出结果：

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b95ce2e9ddc74e4eae9eb80d8dd54ba8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

这个里包含了一个知识点：

- 规定必须给`Promise`对象传入一个执行函数，否则将会报错。

# 一、定义初始结构

原生的promise我们一般都会用new来创建实例 👇 ：

```javascript
let promise = new Promise()
复制代码
```

所以我们手写的时候可以用构造函数或者class来创建，为了方便代码的整体观看就用class。

🔍 如果不知道 `类 class` 是如何使用的，建议参考我写的这篇文章：[ES6新特性 Class 类的全方面理解](https://juejin.cn/post/7021069095336411166)

把我们手写的Promise命名为myPromise，*具体名字可以按自己想法，都可以*

首先创建一个`myPromise`类

```javascript
class myPromise {}
复制代码
```

在new一个promise实例的时候肯定是需要传入参数的

```javascript
let promise = new Promise(() => {})
复制代码
```

不然这个实例用处不大；而这个参数我们知道是一个函数，并且当我们传入这个函数参数的时候，这个函数参数会自动执行。

因此，我们需要在类的`构造函数constructor`里面添加一个参数，这里就用func来做形参，并且执行一下这个参数

```javascript
class myPromise {
+    constructor(func) {
+       func();
+   }
}
复制代码
```

# 二、实现 resolve 和 reject

接下来，大家都知道需要为这个函数参数传入它自己的函数，也就是`resolve()`和`reject()`

原生的promise里面可以传入`resolve`和`reject`两个参数

```javascript
let promise = new Promise((resolve, reject) => {})
复制代码
```

那么我们也得允许手写这边可以传入这两个参数：

```javascript
class myPromise {
    constructor(func) {
+       func(resolve, reject);
    }
}
复制代码
```

这里这样写明显有一个问题 🤨，那就是手写这边不知道哪里调用`resolve()`和`reject()`这两个参数，毕竟`resolve()`和`reject()`还没有定义

因此就需要创造出这两个对象 😀

有一点我们需要知道的是`resolve()`和`reject()`也是以函数的形式来执行的，我们在原生`promise`里也是在`resolve`和`reject`后面加括号`()`来执行的，因此我们可以用类方法的形式来创建这两个函数：

```javascript
class myPromise {
    constructor(func) {
        func(resolve, reject);
    }
+   resolve() {}
+   reject() {}
}
复制代码
```

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6b473ae29e4418a9998a3b3dedcd04~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

创建这两个方法以后我们发现`func`里面的两个参数颜色还是原来的颜色，编辑器就是在告诉我们：这两个参数还没有创建噢~😲

等下，刚刚不是已经创建了吗？🦁

是的，但是我们需要用`this`来调用自身`class`的方法，因此我们需要在构造函数里把两个参数前加上`this`：

```javascript
class myPromise {
    constructor(func) {
+       func(this.resolve, this.reject);
    }
    resolve() {}
    reject() {}
}
复制代码
```

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87e4027549bd40e5b9a647493e0b44dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

那么这里的`resolve()`和`reject()`方法应该如何执行呢？里面应该写什么内容呢？😯

这就需要用到状态了 😛

## 1. 管理状态和结果

promise有三种状态：分别是`pending`，`fulfilled`和`rejected`

- 初始的时候是`pending`
- `pending`可以转为`fulfilled`状态，但是不能逆转
- `pending`也可以转为`rejected`状态，但是也不能逆转
- 这里`fulfilled`和`rejected`也不能互转

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcaccbc6d596491cbcd2c5715e8a14d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

因此我们需要提前先把这些状态定义好，可以用`const`来创建外部的固定变量，但是这里为了统一就用`static`来创建`静态属性`：

```javascript
class myPromise {
+   static PENDING = 'pending';
+   static FULFILLED = 'fulfilled';
+   static REJECTED = 'rejected';
    constructor(func) {
        func(this.resolve, this.reject);
    }
    resolve() {}
    reject() {}
}
复制代码
```

创建了状态属性以后，还需要为每一个实例添加一个`状态属性`，在前面讲到得 `“Promise 核心要点”` 章节，我们已经知道原生Promise用`PromiseState`这个字段来保存实例的状态属性，这里就也用 `this.PromiseState` 来保存实例的状态属性，这个状态属性默认就是 `待定pending` 状态，**这样在每一个实例被创建以后就会有自身的状态属性可以进行判断和变动了**

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
+       this.PromiseState = myPromise.PENDING;
        func(this.resolve, this.reject);
    }
    resolve() {}
    reject() {}
}
复制代码
```

那么在执行`resolve()`的时候就需要判断状态是否为 `待定 pending`，如果是 `待定 pending`的话就把状态改为 `成功 fulfilled`:

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        func(this.resolve, this.reject);
    }
    resolve() {
+       if (this.PromiseState === myPromise.PENDING) {
+           this.PromiseState = myPromise.FULFILLED;
+       }
    }
    reject() {}
}
复制代码
```

同样，为给`reject`添加参数，并且把参数赋值给实例的`PromiseResult`属性:

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        func(this.resolve, this.reject);
    }
    resolve() {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
        }
    }
    reject() {
+       if (this.PromiseState === myPromise.PENDING) {
+           this.PromiseState = myPromise.REJECT;
+       }
    }
}
复制代码
```

**◾ 执行 `resolve()` 和 `reject()` 可以传参**

现在我们再回忆一下原生`Promise` 🙂，在执行`resolve()`或者`reject()`的时候都是可以传入一个参数，这样我们后面就可以使用这个参数了

```javascript
let promise = new Promise((resolve, reject) => {
    resolve('这次一定')
})
复制代码
```

我们可以把这个结果参数命名为`PromiseResult` *(和原生Promise保持一致)*，不管是成功还是拒绝的结果，两者选其一，我们让每个实例都有`PromiseResult`属性，并且给他们都赋值`null`，这里给空值`null`是因为执行`resolve()`或者`reject()`的时候会给结果赋值：

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
+       this.PromiseResult = null;
        func(this.resolve, this.reject);
    }
    resolve() {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
        }
    }
    reject() {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECT;
        }
    }
}
复制代码
```

接着我们就可以给`resolve()`添加参数，并且把参数赋值给实例的`PromiseResult`属性:

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        func(this.resolve, this.reject);
    }
+   resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
+           this.PromiseResult = result;
        }
    }
    reject() {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECT;
        }
    }
}
复制代码
```

同样，为给`reject()`添加参数，并且把参数赋值给实例的`PromiseResult`属性:

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        func(this.resolve, this.reject);
    }
    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
        }
    }
+   reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECT;
+           this.PromiseResult = reason;
        }
    }
}
复制代码
```

## 2. this 指向问题

现在的代码看起来风平浪静的，但很多人会在这里犯错~😥

大家觉得这里有什么错误？🧐

我们来`new`一个实例 🌰 执行一下代码就知道有没有问题了

```javascript
class myPromise {
    ...
}

// 测试代码
+  let promise1 = new myPromise((resolve, reject) => {
+      resolve('这次一定');
+  })
复制代码
```

运行上面代码，报错 🦁：

```
Uncaught TypeError: Cannot read property 'PromiseState ' of undefined
```

可从报错的信息里面我们貌似发现不了有什么错误🤨，因为`PromiseState `属性我们已经创建了，不应该是`undefined`~

🔍 但我们仔细看看`resolve()`和`reject()`方法里调用`PromiseState `，前面是有`this`关键字的😲

```javascript
    resolve(result) {
➡      if (this.PromiseState === myPromise.PENDING) {
➡          this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
        }
    }
    reject(reason) {
➡      if (this.PromiseState === myPromise.PENDING) {
➡          this.PromiseState = myPromise.REJECT;
            this.PromiseResult = reason;
        }
    }
复制代码
```

那么只有一种可能🧐，调用`this.PromiseState `的时候并没有调用`constructor`里的`this.PromiseState `，也就是这里的`this`已经跟丢了~

我们在`new`一个新实例的时候执行的是`constructor`里的内容，也就是`constructor`里的`this`确实是新实例的，但现在我们是在新实例被创建后再在外部环境下执行`resolve()`方法的，这里的`resolve()`看着像是和实例一起执行的，其实不然，也就**相当于不在`class`内部使用这个`this`**，而**我们没有在外部定义任何`PromiseState `变量，因此这里会报错**

解决`class`的`this`指向问题一般会用箭头函数，`bind`或者`proxy`，在这里我们就可以使用`bind`来绑定`this`，只需要在构造函数`constructor`中的`this.resolve`和`this.reject`后加上，`.bind（this）`就可以了 😺:

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
+       func(this.resolve.bind(this), this.reject.bind(this));
    }
    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult  = result;
        }
    }
    reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECT;
            this.PromiseResult = reason;
        }
    }
}

// 测试代码
let promise1 = new myPromise((resolve, reject) => {
    resolve('这次一定');
})
复制代码
```

🔍 如果这里有点蒙圈，不太懂为什么这样写，可以参考我之前写的关于`this`指向的文章：

- [JavaScript 基础系列之 call、apply 和 bind 方法的用法、区别和使用场景](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyuanyuanbyte%2FBlog%2Fissues%2F115)
- [JavaScript 深入系列之 call、apply 和 bind 方法的模拟实现](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyuanyuanbyte%2FBlog%2Fissues%2F109)

我们接着往下写~

对于`resolve`来说，这里就是给实例的`resolve()`方法绑定这个`this`为当前的实例对象，并且执行`this.resolve()`方法： ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c4f15ab1711462892c301caee12191b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp) 对于`reject`来说，这里就是给实例的`reject`方法绑定这个`this`为当前的实例对象，并且执行`this.reject`方法： ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753b61f4ae814801a5ebaafc5c8a3a94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp) 咱们来测试一下代码吧：

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        func(this.resolve.bind(this), this.reject.bind(this));
    }
    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
        }
    }
    reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECTED;
            this.PromiseResult = reason;
        }
    }
}


// 测试代码
let promise1 = new myPromise((resolve, reject) => {
    resolve('这次一定');
})
console.log(promise1); 
// myPromise {PromiseState: 'fulfilled', PromiseResult: '这次一定'}
let promise2 = new myPromise((resolve, reject) => {
    reject('下次一定');
})
console.log(promise2); 
// myPromise {PromiseState: 'rejected', PromiseResult: '下次一定'}
复制代码
```

上面是我们手写的 `myPromise`的执行情况，看看原生Promise的执行情况：

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/816ff5396d424f96ad4ce694b6a6c910~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

说明执行结果符合我们的预期，是不是觉得离成功又进了一步啦~ 👏👏👏

那么大家觉得下一步我们要做什么？是不是很多同学觉得需要写`then`了？那么我们就先来满足想要写`then`的同学们~

# 三、实现 then 方法

**因为`then`是在创建实例后再进行调用的，因此我们再创建一个 类方法，可千万不要创建在 `constructor` 里面了~** 😛

我想应该有些同学突然失忆😶，不记得`then`怎么用了，我们就来稍微写一下原生的`then`方法：

```javascript
let promise = new Promise((resolve, reject) => {
    resolve('这次一定')
})

+  promise.then(
+      result => {
+          console.log(result);
+      },
+      reason => {
+          console.log(reason.message);
+      }
+  )
复制代码
```

`then`方法可以传入两个参数，这两个参数都是函数，一个是当状态为`fulfilled 成功` 时执行的代码，另一个是当状态为 `rejected 拒绝` 时执行的代码。

虽然很多人可能一直只用一个函数参数，但不要忘记这里是两个函数参数🧐。

因此我们就可以先给手写的`then`里面添加 **两个参数**：

- 一个是 `onFulfilled` 表示 `“当状态为成功时”`
- 另一个是 `onRejected` 表示 `“当状态为拒绝时”`

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        func(this.resolve.bind(this), this.reject.bind(this));
    }
    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
        }
    }
    reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECTED;
            this.PromiseResult = reason;
        }
    }
+   then(onFulfilled, onRejected) {}
}
复制代码
```

## 1. 状态不可变

这里我们先看看`原生 Promise` 产生的结果：

```javascript
let promise = new Promise((resolve, reject) => {
    resolve('这次一定')
    reject('下次一定')
})

promise.then(
    result => {
        console.log('fulfilled', result);
    },
    reason => {
        console.log('rejected', reason.message);
    }
)
复制代码
```

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a7957b5ca14038bcff46ff8601aaf8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

可以看到控制台只显示了一个`console.log`的结果，**证明 `Promise` 只会执行`成功状态` 或者 `拒绝状态` 的其中一个**

也就是我们前文讲到的，`Promise`  只以 `第一次为准`，第一次成功就`永久`为`fulfilled`，第一次失败就`永远`状态为`rejected`

因此我们在手写的时候就必须进行判断 🤖：

◾ 如果当前实例的 `PromiseState` 状态属性为 `fulfilled 成功 ` 的话，我们就执行传进来的 `onFulfilled` 函数，并且为`onFulfilled`函数传入前面保留的`PromiseResult`属性值：

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        func(this.resolve.bind(this), this.reject.bind(this));
    }
    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
        }
    }
    reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECTED;
            this.PromiseResult = reason;
        }
    }
    then(onFulfilled, onRejected) {
+       if (this.PromiseState === myProise.FULFILLED) {
+           onFulfilled(this.PromiseResult);
+       }
    }
}
复制代码
```

◾ 如果当前实例的 `PromiseState` 状态属性为 `rejected 拒绝` 的话，我们就执行传进来的 `onRejected` 函数，并且为`onRejected`函数传入前面保留的`PromiseResult`属性值：

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        func(this.resolve.bind(this), this.reject.bind(this));
    }
    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
        }
    }
    reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECTED;
            this.PromiseResult = reason;
        }
    }
    then(onFulfilled, onRejected) {
        if (this.PromiseState === myProise.FULFILLED) {
            onFulfilled(this.PromiseResult);
        }
+       if (this.PromiseState === myPromise.REJECTED) {
+           onRejected(this.PromiseResult);
+       }
    }
}
复制代码
```

定义好了判断条件以后，我们就来测试一下代码，也是一样，在实例 🌰 上使用`then`方法：

```javascript
class myPromise {
    ...
}


// 测试代码
let promise1 = new myPromise((resolve, reject) => {
    resolve('这次一定');
+   reject('下次一定');
})
+   promise1.then(
+       result => {
+           console.log(result)
+       },
+       reason => {
+           console.log(reason.message)
+       }
+   )
复制代码
```

执行上面的测试代码，查看控制台：

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e174ad9029c648b49d71be4a809fbc89~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

可以看到控制台只显示了一个`console.log`的结果：`这次一定` 😎，证明我们已经实现了 `promise的状态不可变` 👏👏👏

写到这里并没有报错，也就是我们`暂时安全`了，为什么说`暂时安全`呢？

因为这里还有很多没有完善的地方，手写Promise的时候，有一个难点就在于有很多地方需要和原生一样严谨，也就是说原生的Promise会考虑很多特殊情况~

我们在实际运用时可能暂时不会碰到这些情况，可是当我们遇到的时候 **却不知底层的原理，`这就是为什么我们要知道如何手写Promise`**

接着写 💪

## 2. 执行异常 throw

在`new Promise`的时候，执行函数里面如果抛出错误，是会触发`then`方法的第二个参数，即`rejected`状态的回调函数

也就是在原生的Promise里面，`then`方法的第二个参数，即`rejected`状态的回调函数可以把错误的信息作为内容输出出来

到这里，有的同学可能会说，执行异常抛错，不是用`catch()`方法去接吗？为什么这里又说 `是会触发then方法的第二个参数，即rejected状态的回调函数`？😵

那我们就说道说道吧🧐：

`catch()` 方法返回一个`Promise`，并且处理拒绝的情况。它的行为与调用`Promise.prototype.then(undefined, onRejected)` 相同。

事实上, calling `obj.catch(onRejected)` 内部calls `obj.then(undefined, onRejected)`。(这句话的意思是，我们显式使用`obj.catch(onRejected)`，内部实际调用的是`obj.then(undefined, onRejected)`)

`Promise.prototype.catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数。

```javascript
p.then((val) => console.log('fulfilled:', val))
  .catch((err) => console.log('rejected', err));

// 等同于
p.then(
    null,
    err=> {console.log(err)}
) 

// 等同于
p.then((val) => console.log('fulfilled:', val))
  .then(null, (err) => console.log("rejected:", err));
复制代码
```

◾ 注意看下面的例子 🌰：

```javascript
const promise = new Promise(function(resolve, reject) {
  throw new Error('test');
});
promise.catch(function(error) {
  console.log(error);
});
// Error: test
复制代码
```

上面代码中，promise抛出一个错误，就被`catch()`方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。

```javascript
// 写法一
const promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test');
  } catch(e) {
    reject(e);
  }
});
promise.catch(function(error) {
  console.log(error);
});
// 写法二
const promise = new Promise(function(resolve, reject) {
  reject(new Error('test'));
});
promise.catch(function(error) {
  console.log(error);
});
复制代码
```

比较上面两种写法，可以发现`reject()`方法的作用，等同于抛出错误。这一点很重要，因为我们手写Promise就是用`try/catch`来处理异常，用的就是上面的思想。

◾ **一般来说，不要在`then()`方法里面定义 Reject 状态的回调函数（即`then`的第二个参数），总是使用`catch`方法。**

```javascript
// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });
  
// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
复制代码
```

上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面`then`方法执行中的错误，也更接近同步的写法（`try/catch`）。因此，建议总是使用`catch()`方法，而不使用`then()`方法的第二个参数。

**回到正题**

原生Promise在`new Promise`的时候，执行函数里面如果抛出错误，是会触发`then`方法的第二个参数 `(即rejected状态的回调函数)`，把错误的信息作为内容输出出来:

```javascript
let promise = new Promise((resolve, reject) => {
    throw new Error('白嫖不成功');
})

promise.then(
    result => {
        console.log('fulfiiled:', result)
    },
    reason => {
        console.log('rejected:', reason)
    }
)
复制代码
```

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4afbee05224a4eb99674007130dabf24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

但是如果我们在手写这边写上同样道理的测试代码，很多人就会忽略这个细节😥：

```javascript
class myPromise {
    ...
}


// 测试代码
let promise1 = new myPromise((resolve, reject) => {
+   throw new Error('白嫖不成功');
})
promise1.then(
+   result => {
+       console.log('fulfiiled:', result)
+   },
+   reason => {
+       console.log('rejected:', reason)
+   }
)
复制代码
```

我们看看控制台

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/315d46ffbd8b4a9cb4959ad4437e43b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

> `Uncaught`  未捕获

可以发现报错了😰，没有捕获到错误，没有把内容输出出来

◾ 我们可以在执行`resolve()`和`reject()`之前用`try/catch`进行判断，在`构造函数 constructor`里面完善代码，判断生成实例的时候是否有报错 🔍：

- 如果没有报错的话，就按照正常执行`resolve()`和`reject()`方法
- 如果报错的话，就把错误信息传入给`reject()`方法，并且直接执行`reject()`方法

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
+       try {
            func(this.resolve.bind(this), this.reject.bind(this));
+       } catch (error) {
+           this.reject(error)
+       }
    }
    resolve(result) {
        ...
    }
    reject(reason) {
        ...
    }
    then(onFulfilled, onRejected) {
        ...
    }
}
复制代码
```

◾ **注意这里不需要给`reject()`方法进行`this`的绑定了，因为这里是直接执行，而不是创建实例后再执行。**

▪ `func(this.resolve.bind(this), this.reject.bind(this));` 这里的`this.reject`意思是：把类方法`reject()`作为参数 传到构造函数`constructor` 里要执行的`func()`方法里，只是一个参数，并不执行，只有创建实例后调用`reject()`方法的时候才执行，此时`this`的指向已经变了，所以想要正确调用`myPromise`的`reject()`方法就要通过`.bind(this))`改变`this`指向。

▪ `this.reject(error)`，这里的`this.reject()`，是直接在构造函数里执行类方法，`this`指向不变，`this.reject()`就是直接调用类方法`reject()`，所以不用再进行`this`绑定。

◾ 这里考察了`this`绑定的一个细节🔍：

`call`、`apply`和`bind`都可以改变函数体内部 this 的指向，**但是 `bind` 和 `call/apply` 有一个很重要的区别：一个函数被 `call/apply` 的时候，会立即执行函数，但是 `bind` 会创建一个新函数，不会立即执行。**

这就是前面为什么说，` this.reject.bind(this)`只是作为参数，并没有直接执行的原因了~😀

**回到正文**

结合前面的讲解，刷新一下控制台，我们可以看到手写这边已经没有报错了👏👏👏: ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ccf8aaeace432dbe5c9879d2f65ff8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 3. 参数校验

大家觉得目前代码是不是没问题了？可以进行下一步了？

如果你觉得是的话就又掉坑了~🦁

原生Promise里**规定`then`方法里面的两个参数如果不是函数的话就要被忽略**，我们就故意在原生代码这里不传入函数作为参数：

```javascript
let promise = new Promise((resolve, reject) => {
    throw new Error('白嫖不成功');
})

promise.then(
    undefined,
    reason => {
        console.log('rejected:', reason)
    }
)
复制代码
```

运行以后我们发现在这里执行是没有问题的：

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bea1e40f6cf4b86abb33233196791b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

我们再以同样类似的不传 **函数参数** 的代码应用在 **手写代码** 上面：

```javascript
class myPromise {
	...
}

let promise1 = new myPromise((resolve, reject) => {
    resolve('这次一定');
})

promise1.then(
    undefined,
    reason => {
        console.log('rejected:', reason)
    }
)
复制代码
```

大家想想会不会有什么问题？来看看结果会怎样？🧐

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/840804fc6bab4c71b95f75d9c99f1de3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

结果就是 `Uncaught TypeError: onFulfilled is not a function`。浏览器帮你报错了，这不是我们想要的~😥

我们只想要自己来抛出错误，再来看看刚刚的手写`then`部分：

```javascript
then(onFulfilled, onRejected) {
    if (this.PromiseState === myPromise.FULFILLED) {
        onFulfilled(this.PromiseResult);
    }
    if (this.PromiseState === myPromise.REJECTED) {
        onRejected(this.PromiseResult);
    }
}
复制代码
```

我们会在里面分别执行成功和拒绝两个参数，可是我们不想修改这里的代码，那么就只能把不是函数的参数改为函数

**`Promise` 规范如果 `onFulfilled` 和 `onRejected` 不是函数，就忽略他们**。所谓“忽略”并不是什么都不干，对于`onFulfilled`来说“忽略”就是将`value`原封不动的返回，对于`onRejected`来说就是返回`reason`，`onRejected`因为是错误分支，我们返回`reason`应该`throw`一个`Error`:

这里我们就可以用 `条件运算符`，我们在进行`if`判断之前进行预先判断：

▪ 如果`onFulfilled`参数是一个函数，就把原来的`onFulfilled`内容重新赋值给它，如果`onFulfilled`参数不是一个函数，就将`value`原封不动的返回

```javascript
class myPromise {
	...
    then(onFulfilled, onRejected) {
+       onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        if (this.PromiseState === myPromise.FULFILLED) {
            onFulfilled(this.PromiseResult);
        }
        if (this.PromiseState === myPromise.REJECTED) {
            onRejected(this.PromiseResult);
        }
    }
}
复制代码
```

▪ 如果`onRejected`参数是一个函数，就把原来的`onRejected`内容重新赋值给它，如果`onRejected`参数不是一个函数，就`throw`一个`Error`

```javascript
class myPromise {
	...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
+       onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };
        if (this.PromiseState === myPromise.FULFILLED) {
            onFulfilled(this.PromiseResult);
        }
        if (this.PromiseState === myPromise.REJECTED) {
            onRejected(this.PromiseResult);
        }
    }
}
复制代码
```

现在我们再来测试一下代码：

```javascript
class myPromise {
	...
}

let promise1 = new myPromise((resolve, reject) => {
    resolve('这次一定');
})
promise1.then(
    undefined,
    reason => {
        console.log('rejected:', reason)
    }
)
复制代码
```

查看控制台，发现没有报错了👏👏👏：

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d831063ec55e424691019c6039fa4fd2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**当前实现的完整代码：**

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        try {
            func(this.resolve.bind(this), this.reject.bind(this));
        } catch (error) {
            this.reject(error)
        }
    }
    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
        }
    }
    reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECTED;
            this.PromiseResult = reason;
        }
    }
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };
        if (this.PromiseState === myPromise.FULFILLED) {
            onFulfilled(this.PromiseResult);
        }
        if (this.PromiseState === myPromise.REJECTED) {
            onRejected(this.PromiseResult);
        }
    }
}
复制代码
```

# 四、实现异步

## 1. 添加定时器

在对代码进行一些基本修补以后，我们就可以来进行下一个大功能了，也就是Promise的 **异步功能** ✨。

可以说我们在手写的代码里面依旧没有植入异步功能，毕竟最基本的`setTimeout`我们都没有使用，但是我们必须先了解一下原生Promise的一些`运行顺序规则`。

在这里我为原生代码添加上步骤信息：

```javascript
console.log(1);

let promise = new Promise((resolve, reject) => {
    console.log(2);
    resolve('这次一定');
})

promise.then(
    result => {
        console.log('fulfilled:', result);
    },
    reason => {
        console.log('rejected:', reason)
    }
)

console.log(3);
复制代码
```

我们配合这段原生Promise代码，结合控制台一起看看

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39fcb5dff169440985ce764c281c3b8c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

输出顺序为：

```javascript
1
2
3
fulfilled: 这次一定
复制代码
```

- 首先执行`console.log(1)`，输出`1`
- 接着创建`promise实例`，输出`2`，因为这里依旧是同步
- 然后碰到`resolve`的时候，修改结果值
- 到了`promise.then`会进行异步操作，也就是我们 **需要先把执行栈的内容清空**，于是就执行`console.log(3)`，输出`3`
- 接着才会执行`promise.then`里面的内容，也就是最后输出`“fulfilled: 这次一定”`

▪ 我们用同样的测试代码应用在 **手写代码** 上面：

```javascript
class myPromise {
	...
}

// 测试代码
console.log(1);
let promise1 = new myPromise((resolve, reject) => {
    console.log(2);
    resolve('这次一定');
})
promise1.then(
    result => {
        console.log('fulfilled:', result);
    },
    reason => {
        console.log('rejected:', reason)
    }
)
console.log(3);
复制代码
```

这次我们发现有些不同了😯，输出顺序为：

```javascript
1
2
fulfilled: 这次一定
3
复制代码
```

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da97821d707844529e81ee0882071271~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

`1` 和 `2` 都没有问题，问题就是`“fulfilled: 这次一定”`和`3`这里的顺序不对

◾ 其实问题很简单，就是我们刚刚说的 **没有设置异步执行** 😶

我们二话不说直接给`then`方法里面添加`setTimeout`就可以了😎，**需要在进行`if`判断以后再添加`setTimeout`，要不然状态不符合添加异步也是没有意义的**，然后在`setTimeout`里执行传入的函数参数：

```javascript
class myPromise {
	...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };
        if (this.PromiseState === myPromise.FULFILLED) {
+           setTimeout(() => {
                onFulfilled(this.PromiseResult);
+           });
        }
        if (this.PromiseState === myPromise.REJECTED) {
+           setTimeout(() => {
                onRejected(this.PromiseResult);
+           });
        }
    }
}
复制代码
```

我们使用前面的用例重新测试一下代码：

```javascript
class myPromise {
	...
}

// 测试代码
console.log(1);
let promise1 = new myPromise((resolve, reject) => {
    console.log(2);
    resolve('这次一定');
})
promise1.then(
    result => {
        console.log('fulfilled:', result);
    },
    reason => {
        console.log('rejected:', reason)
    }
)
console.log(3);
复制代码
```

输出顺序为:

```javascript
1
2
3
fulfilled: 这次一定
复制代码
```

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/937722da9c724fbea2a732000aeb8911~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

这次的顺序就比较顺眼了~👏👏👏

**在这里我们解决异步的方法是给`onFulfilled`和`onRejected`添加`setTimeout`，但是为什么要这么做呢？**

◾ 这就要讲到  [**`Promises/A+` 规范**](https://link.juejin.cn?target=https%3A%2F%2Fpromisesaplus.com%2F%23notes)  了

规范 `2.2.4`  ：

> `onFulfilled` or `onRejected` must not be called until the `execution context` stack contains only platform code. [3.1].

译文：

2.2.4 `onFulfilled` 和 `onRejected` 只有在`执行环境`堆栈仅包含平台代码时才可被调用 `注1`

规范对2.2.4做了注释：

> 3.1 Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that `onFulfilled` and `onRejected` execute asynchronously, after the event loop turn in which `then` is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or `setImmediate`, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.

译文：

**3.1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 `onFulfilled` 和 `onRejected` 方法异步执行，且应该在 `then` 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制，比如`setTimeout` 或者 `setImmediate`； 也可以采用“微任务（micro-task）”机制来实现， 比如 `MutationObserver` 或者`process.nextTick`。** 由于 promise 的实施代码本身就是平台代码（译者注： 即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列或『跳板』)。

**这里我们用的就是规范里讲到的 “宏任务” `setTimeout`**。

## 2. 回调保存

异步的问题真的解决了吗？现在又要进入Promise另一个难点了，大家务必竖起耳朵啦😛

我们来给原生的Promise里添加`setTimeout`，使得`resolve`也异步执行，那么就会出现一个问题了，`resolve`是异步的，`then`也是异步的，究竟谁会先被调用呢？

```javascript
console.log(1);
let promise = new Promise((resolve, reject) => {
    console.log(2);
+   setTimeout(() => {
        resolve('这次一定');
+       console.log(4);
+   });
})
promise.then(
    result => {
        console.log('fulfilled:', result);
    },
    reason => {
        console.log('rejected:', reason)
    }
)
console.log(3);
复制代码
```

输出顺序为：

```javascript
1
2
3
4
fulfilled: 这次一定
复制代码
```

特别要注意的是当遇到`setTimeout`的时候被异步执行了，而`resolve('这次一定')`没有被马上执行，而是先执行`console.log(4)`，等到`then`的时候再执行`resolve`里保存的值。

这里涉及到了浏览器的事件循环，`promise.then()` 和 `setTimeout()` 都是异步任务，但实际上异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：`微任务 (micro task)` 和 `宏任务 (macro task`)。

- `setTimeout()`属于宏任务
- `promise.then()`属于微任务

在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。

我们只需记住 **当 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。**

> 🔍 如果想要学习事件循环、微任务和宏任务，可以看我写的这篇文章：[JavaScript 深入系列之宏任务、微任务和事件循环 Event Loop](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyuanyuanbyte%2FBlog%2Fissues%2F92)

**回到正文**

我们用同样的代码应用到手写的部分：

```javascript
class myPromise {
	...
}

// 测试代码
console.log(1);
let promise1 = new myPromise((resolve, reject) => {
    console.log(2);
    setTimeout(() => {
        resolve('这次一定');
        console.log(4);
    });
})
promise1.then(
    result => {
        console.log('fulfilled:', result);
    },
    reason => {
        console.log('rejected:', reason)
    }
)
console.log(3);
复制代码
```

控制台输出：

```javascript
1
2
3
4
复制代码
```

可以发现 `fulfilled: 这次一定` 并没有输出

我们可以先猜测一下，没有输出的原因很可能是因为`then`方法没有被执行，看看`then`方法里面是根据条件判断来执行代码的：

```javascript
class myPromise {
	...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };
        if (this.PromiseState === myPromise.FULFILLED) {
            setTimeout(() => {
                onFulfilled(this.PromiseResult);
            });
        }
        if (this.PromiseState === myPromise.REJECTED) {
            setTimeout(() => {
                onRejected(this.PromiseResult);
            });
        }
    }
}
复制代码
```

也就是说很可能没有符合的条件，再换句话说可能没有符合的状态

那么我们就在三个位置分别输出当前的状态，这样分别来判断哪个位置出了问题:

```javascript
class myPromise {
	...
}

// 测试代码
console.log(1);
let promise1 = new myPromise((resolve, reject) => {
    console.log(2);
    setTimeout(() => {
+       console.log('A',promise1.PromiseState);
        resolve('这次一定');
+       console.log('B',promise1.PromiseState);
        console.log(4);
    });
})
promise1.then(
    result => {
+       console.log('C',promise1.PromiseState);
        console.log('fulfilled:', result);
    },
    reason => {
        console.log('rejected:', reason)
    }
)
console.log(3);
复制代码
```

输出结果为：

```javascript
1
2
3
A pending
B fulfilled
4
复制代码
```

发现只有两组状态被输出，这两组都在`console.log(4)`前被输出，证明`setTimeout`里面的状态都被输出了，只有`then`里面的状态没有被输出

这基本就可以确定是因为`then`里的状态判断出了问题

这里涉及到事件循环，我们详细解读一下：

▪ **首先**，执行`console.log(1)`，输出`1`

▪ **第二步**，创建promise，执行函数体里的`console.log(2)`，输出`2`

▪ **第三步**，遇到`setTimeout`，`setTimeout`是宏任务，将`setTimeout`加入宏任务队列，等待执行

▪ **第四步**，遇到`promise.then()`，`promise.then()`是微任务，将`promise.then()`加入微任务队列，等待执行

▪ **第五步**，执行`console.log(3)`，输出`3`，此时当前执行栈已经清空

▪ **第六步**，当前执行栈已经清空，先执行微任务队列的任务 `promise.then()`，发现promise的状态并没有改变，还是`pending`，所以没有输出。状态并没有改变的原因是：`resolve('这次一定')`是在`setTimeout`里的，但此时还没开始执行`setTimeout`，因为`setTimeout`是宏任务，宏任务在微任务后面执行

▪ **第七步**，微任务队列已经清空，开始执行宏任务 `setTimeout`：

```javascript
 setTimeout(() => {
     console.log('A',promise1.PromiseState);
     resolve('这次一定');
     console.log('B',promise1.PromiseState);
     console.log(4);
 });
复制代码
```

▪ **第八步**，执行 `console.log('A',promise1.PromiseState)`，此时promise状态还没发生变化，还是`pending`，所以输出 `A pending`

▪ **第九步**，执行 `resolve('这次一定');`，改变promise的状态为`fulfilled`

▪ **第十步**，执行 `console.log('B',promise1.PromiseState)`，输出 `B fulfilled`

▪ **第十一步**，执行 `console.log(4)`，输出`4`

> 这里暂且认为我们写的promise.then()和原生一样，方便理解

◾ 分析完上面的代码，我们知道了，因为先执行了`then`方法，但发现这个时候状态依旧是 `pending`，而我们手写部分没有定义`pending`待定状态的时候应该做什么，因此就少了`fulfilled: 这次一定` 这句话的输出

所以我们就 **直接给`then`方法里面添加待定状态的情况就可以了**，也就是用`if`进行判断:

```javascript
class myPromise {
	...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };
+       if (this.PromiseState === myPromise.PENDING) {
+ 		
+ 		}
        if (this.PromiseState === myPromise.FULFILLED) {
            setTimeout(() => {
                onFulfilled(this.PromiseResult);
            });
        }
        if (this.PromiseState === myPromise.REJECTED) {
            setTimeout(() => {
                onRejected(this.PromiseResult);
            });
        }
    }
}
复制代码
```

◾ 但是问题来了，当`then`里面判断到 `pending` 待定状态时我们要干什么？

因为这个时候`resolve`或者`reject`还没获取到任何值，因此我们必须让`then`里的函数稍后再执行，等`resolve`执行了以后，再执行`then`

为了保留`then`里的函数，我们可以创建 `数组` 来 **保存函数**。

**为什么用 `数组` 来保存这些回调呢？因为一个promise实例可能会多次 `then`，也就是经典的 `链式调用`**，而且数组是先入先出的顺序

在实例化对象的时候就让每个实例都有这两个数组：

- `onFulfilledCallbacks` ：用来 **保存成功回调**
- `onRejectedCallbacks` ：用来 **保存失败回调**

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
+       this.onFulfilledCallbacks = []; // 保存成功回调
+       this.onRejectedCallbacks = []; // 保存失败回调
        try {
            func(this.resolve.bind(this), this.reject.bind(this));
        } catch (error) {
            this.reject(error)
        }
    }
}
复制代码
```

◾ 接着就完善`then`里面的代码，也就是当判断到状态为 `pending` 待定时，暂时保存两个回调，也就是说暂且把`then`里的两个函数参数分别放在两个数组里面：

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        this.onFulfilledCallbacks = []; // 保存成功回调
        this.onRejectedCallbacks = []; // 保存失败回调
        try {
            func(this.resolve.bind(this), this.reject.bind(this));
        } catch (error) {
            this.reject(error)
        }
    }
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : () => {};
        onRejected = typeof onRejected === 'function' ? onRejected : () => {};
        if (this.PromiseState === myPromise.PENDING) {
+           this.onFulfilledCallbacks.push(onFulfilled);
+           this.onRejectedCallbacks.push(onRejected);
        }
        if (this.PromiseState === myPromise.FULFILLED) {
            setTimeout(() => {
                onFulfilled(this.PromiseResult);
            });
        }
        if (this.PromiseState === myPromise.REJECTED) {
            setTimeout(() => {
                onRejected(this.PromiseResult);
            });
        }
    }
}
复制代码
```

◾ 数组里面放完函数以后，就可以完善`resolve`和`reject`的代码了

**在执行`resolve`或者`reject`的时候，遍历自身的`callbacks`数组**，看看数组里面有没有`then`那边 **保留** 过来的 **待执行函数**，**然后逐个执行数组里面的函数**，执行的时候会传入相应的参数：

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        this.onFulfilledCallbacks = []; // 保存成功回调
        this.onRejectedCallbacks = []; // 保存失败回调
        try {
            func(this.resolve.bind(this), this.reject.bind(this));
        } catch (error) {
            this.reject(error)
        }
    }
    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
+           this.onFulfilledCallbacks.forEach(callback => {
+               callback(result)
+           })
        }
    }
    reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECTED;
            this.PromiseResult = reason;
 +          this.onRejectedCallbacks.forEach(callback => {
 +              callback(reason)
 +          })
        }
    }
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };
        if (this.PromiseState === myPromise.PENDING) {
            this.onFulfilledCallbacks.push(onFulfilled);
            this.onRejectedCallbacks.push(onRejected);
        }
        if (this.PromiseState === myPromise.FULFILLED) {
            setTimeout(() => {
                onFulfilled(this.PromiseResult);
            });
        }
        if (this.PromiseState === myPromise.REJECTED) {
            setTimeout(() => {
                onRejected(this.PromiseResult);
            });
        }
    }
}
复制代码
```

完善好代码后，让我们再来测试以下刚才的实例：

```javascript
class myPromise {
	...
}


// 测试代码
console.log(1);
let promise1 = new myPromise((resolve, reject) => {
    console.log(2);
    setTimeout(() => {
        console.log('A', promise1.PromiseState);
        resolve('这次一定');
        console.log('B', promise1.PromiseState);
        console.log(4);
    });
})
promise1.then(
    result => {
        console.log('C', promise1.PromiseState);
        console.log('fulfilled:', result);
    },
    reason => {
        console.log('rejected:', reason)
    }
)
console.log(3);
复制代码
```

输出结果：

```javascript
1
2
3
A pending
C fulfilled
fulfilled: 这次一定
B fulfilled
4
复制代码
```

**从上面的结果我们可以看到 `fulfilled: 这次一定` 打印出来啦，`promise1.then()`方法也正常执行，打印出了当前的状态：`B fulfilled`**

**但是**

细心的同学可能已经发现了，代码输出顺序还是不太对，原生Promise中，`fulfilled: 这次一定` 是最后输出的

◾ 这里有一个很多人忽略的小细节，**要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行**。因此，**在保存成功和失败回调时也要添加 `setTimeout`**

```javascript
class myPromise {
    ...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };
        if (this.PromiseState === myPromise.PENDING) {
+           this.onFulfilledCallbacks.push(() => {
+               setTimeout(() => {
+                   onFulfilled(this.PromiseResult);
+               });
+           });
+           this.onRejectedCallbacks.push(() => {
+               setTimeout(() => {
+                   onRejected(this.PromiseResult);
+               });
+           });
        }
        if (this.PromiseState === myPromise.FULFILLED) {
            setTimeout(() => {
                onFulfilled(this.PromiseResult);
            });
        }
        if (this.PromiseState === myPromise.REJECTED) {
            setTimeout(() => {
                onRejected(this.PromiseResult);
            });
        }
    }
}
复制代码
```

细节补充好了，**当前实现的完整代码：**

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';
    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        this.onFulfilledCallbacks = []; // 保存成功回调
        this.onRejectedCallbacks = []; // 保存失败回调
        try {
            func(this.resolve.bind(this), this.reject.bind(this));
        } catch (error) {
            this.reject(error)
        }
    }
    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
            this.onFulfilledCallbacks.forEach(callback => {
                callback(result)
            })
        }
    }
    reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECTED;
            this.PromiseResult = reason;
            this.onRejectedCallbacks.forEach(callback => {
                callback(reason)
            })
        }
    }
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };
        if (this.PromiseState === myPromise.PENDING) {
            this.onFulfilledCallbacks.push(() => {
                setTimeout(() => {
                    onFulfilled(this.PromiseResult);
                });
            });
            this.onRejectedCallbacks.push(() => {
                setTimeout(() => {
                    onRejected(this.PromiseResult);
                });
            });
        }
        if (this.PromiseState === myPromise.FULFILLED) {
            setTimeout(() => {
                onFulfilled(this.PromiseResult);
            });
        }
        if (this.PromiseState === myPromise.REJECTED) {
            setTimeout(() => {
                onRejected(this.PromiseResult);
            });
        }
    }
}
复制代码
```

检验一下这次是否能行：

```js
class myPromise {
    ...
}

// 测试代码
console.log(1);
let promise1 = new myPromise((resolve, reject) => {
    console.log(2);
    setTimeout(() => {
        console.log('A', promise1.PromiseState);
        resolve('这次一定');
        console.log('B', promise1.PromiseState);
        console.log(4);
    });
})
promise1.then(
    result => {
        console.log('C', promise1.PromiseState);
        console.log('fulfilled:', result);
    },
    reason => {
        console.log('rejected:', reason)
    }
)
console.log(3);
复制代码
```

输出顺序：

```javascript
1
2
3
A pending
B pending
4
C fulfilled
fulfilled: 这次一定
复制代码
```

**可以看到最后输出 `fulfilled: 这次一定` ，和原生Promise顺序一致！**

到这里我们已经完成了 **promise的回调保存**，已经越来越接近胜利了😺

## 3.  验证 then 方法多次调用

Promise 的 then 方法可以被多次调用。

用一个 🌰 ，来验证一下我们写的promise  `then` 方法是否可以多次调用：

```javascript
class myPromise {
    ...
}


// 测试代码
const promise = new myPromise((resolve, reject) => {
    setTimeout(() => {
        resolve('success')
    }, 2000);
})
promise.then(value => {
    console.log(1)
    console.log('resolve', value)
})
promise.then(value => {
    console.log(2)
    console.log('resolve', value)
})
promise.then(value => {
    console.log(3)
    console.log('resolve', value)
})
复制代码
```

运行上面 🌰，输出结果👇

```javascript
1
resolve success
2
resolve success
3
resolve success
复制代码
```

所有 `then` 中的回调函数都已经执行  😎

说明我们当前的代码，已经可以实现 `then` 方法的多次调用✨

👏👏👏 完美，继续

# 五、实现 then 方法的链式调用

**我们常常用到 `new Promise().then().then()`，这就是链式调用，用来解决回调地狱**

举个例子 🌰

```javascript
let p1 = new Promise((resolve, reject) => {
    resolve(100)
})
p1.then(res => {
    console.log('fulfilled', res);
    return 2 * res
}).then(res => {
    console.log('fulfilled', res)
})
复制代码
```

输出👇：

```javascript
fulfilled 100
fulfilled 200
复制代码
```

再举一个例子 🌰 ：

```javascript
const p2 = new Promise((resolve, reject) => {
    resolve(100)
})

p2.then(res => {
    console.log('fulfilled', res);
    return new Promise((resolve, reject) => resolve(3 * res))
}).then(res => {
    console.log('fulfilled', res)
})
复制代码
```

输出👇：

```javascript
fulfilled 100
fulfilled 300
复制代码
```

我们先试一下当前的`myPromise`是否可以实现链式调用：

```javascript
class myPromise {
    ...
}

// 测试代码
let p1 = new myPromise((resolve, reject) => {
    resolve(10)
})
p1.then(res => {
    console.log('fulfilled', res);
    return 2 * res
}).then(res => {
    console.log('fulfilled', res)
}) 
复制代码
```

毫无疑问在控制台里面是会报错的，提示 `then` 方法没有定义：

```
Uncaught TypeError: Cannot read property 'then' of undefined
```

**`Promise.prototype.then()` 方法返回一个新的Promise实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。**

## 1. Promises/A+ 规范的理解

◾ **想要实现`then`方法的链式调用，就必须彻底搞懂`then`方法，这里我们参考 [\**`Promises/A+` 规范\**](https://link.juejin.cn?target=https%3A%2F%2Fpromisesaplus.com%2F%23notes)** 👇

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/113f66b486b748fd82312640d981f4a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**规范在`2.2.7`中这样描述 👇：**

◾ **2.2.7 then 方法必须返回一个 promise 对象**

```javascript
promise2 = promise1.then(onFulfilled, onRejected);
复制代码
```

- **2.2.7.1** 如果 `onFulfilled` 或者 `onRejected` 返回一个值 `x` ，则运行下面的 **Promise 解决过程：`[[Resolve]](promise2, x)`**
- **2.2.7.2** 如果 `onFulfilled` 或者 `onRejected` 抛出一个异常 `e` ，则 `promise2` 必须拒绝执行，并返回拒因 `e`
- **2.2.7.3** 如果 `onFulfilled` 不是函数且 `promise1` 成功执行， `promise2` 必须成功执行并返回相同的值
- **2.2.7.4** 如果 `onRejected` 不是函数且 `promise1` 拒绝执行， `promise2` 必须拒绝执行并返回相同的据因

理解上面的`“返回”`部分非常重要，即：**不论 promise1 被 reject 还是被 resolve 时 promise2 都会执行 Promise 解决过程：`[[Resolve]](promise2, x)`，只有出现异常时才会被 rejected。**

注意 **2.2.7.1** ：

> If either onFulfilled or onRejected returns a value x, **`run the Promise Resolution Procedure [[Resolve]](promise2, x).`**

即：如果 `onFulfilled` 或者 `onRejected` 返回一个值 `x` ，则运行下面的 **Promise 解决过程：`[[Resolve]](promise2, x)`**

规范在 **2.3** 中详细描述 **Promise 解决过程**  `The Promise Resolution Procedure` 👇

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb4fc438128f4b3aa1f665733a491bca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

译过来 👇：

◾ **2.3 Promise 解决过程**

**Promise 解决过程** 是一个抽象的操作，其需输入一个 `promise` 和一个值，我们表示为 `[[Resolve]](promise, x)`，如果 `x` 有 `then` 方法且看上去像一个 `Promise` ，解决程序即尝试使 `promise` 接受 `x` 的状态；否则其用 `x` 的值来执行 `promise` 。

这种 `thenable` 的特性使得 `Promise` 的实现更具有通用性：**只要其暴露出一个遵循 `Promises/A+` 协议的 `then` 方法即可；这同时也使遵循 `Promises/A+` 规范的实现可以与那些不太规范但可用的实现能良好共存。**

**运行 `[[Resolve]](promise, x)` 需遵循以下步骤：**

▪ **2.3.1 `x` 与 promise 相等**

如果 `promise` 和 `x` 指向同一对象，以 `TypeError` 为据因拒绝执行 `promise`

▪ **2.3.2 `x` 为 Promise**

如果 `x` 为 Promise ，则使 `promise` 接受 `x` 的状态

- 2.3.2.1 如果 `x` 处于等待态， `promise` 需保持为等待态直至 `x` 被执行或拒绝
- 2.3.2.2 如果 `x` 处于执行态，用相同的值执行 `promise`
- 2.3.2.3 如果 `x` 处于拒绝态，用相同的据因拒绝 `promise`

▪ **2.3.3 `x` 为对象或函数**

如果 x 为对象或者函数：

- 2.3.3.1 把 `x.then` 赋值给 `then`
- 2.3.3.2 如果取 `x.then` 的值时抛出错误 `e` ，则以 `e` 为据因拒绝 `promise`
- 2.3.3.3 如果 `then` 是函数，将 `x` 作为函数的作用域 `this` 调用之。传递两个回调函数作为参数，第一个参数叫做 `resolvePromise` ，第二个参数叫做 `rejectPromise`:
  - 2.3.3.3.1 如果 `resolvePromise` 以值 `y` 为参数被调用，则运行 `[[Resolve]](promise, y)`
  - 2.3.3.3.2 如果 `rejectPromise` 以据因 `r` 为参数被调用，则以据因 `r` 拒绝 `promise`
  - 2.3.3.3.3 如果 `resolvePromise` 和 `rejectPromise` 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用
  - 2.3.3.3.4 如果调用 `then` 方法抛出了异常 `e`：
    - 2.3.3.3.4.1 如果 `resolvePromise` 或 `rejectPromise` 已经被调用，则忽略之
    - 2.3.3.3.4.2 否则以 `e` 为据因拒绝 `promise`
  - 2.3.3.4 如果 `then` 不是函数，以 `x` 为参数执行 `promise`

**▪ 2.3.4 如果 `x` 不为对象或者函数，以 `x` 为参数执行 `promise`**

如果一个 `promise` 被一个循环的 `thenable` 链中的对象解决，而 `[[Resolve]](promise, thenable)` 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 `TypeError` 为据因来拒绝 `promise`。

## 2. Promises/A+ 规范的总结

基于规范的描述，我们得到以下几点：

**◾ 1.** `then`方法本身会返回一个新的`Promise`对象，返回一个新的Promise以后它就有自己的`then`方法，这样就能实现无限的链式

**◾ 2.** 不论 `promise1` 被 `resolve()`  还是被 `reject()` 时 `promise2` 都会执行 **`Promise 解决过程：[[Resolve]](promise2, x)`**

在手写这里我们把这个 **`Promise 解决过程：[[Resolve]](promise2, x)`** 命名为 `resolvePromise()` 方法，参数为 `(promise2, x, resolve, reject)` 即：

```javascript
function resolvePromise(promise2, x, resolve, reject) {}
复制代码
```

`resolvePromise()`各参数的意义：

```javascript
/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {}
复制代码
```

其实，这个`resolvePromise(promise2, x, resolve, reject)` 即 `Promise 解决过程：[[Resolve]](promise2, x)` 就是对`resolve()、reject()` 进行**改造增强**， 针对`resolve()`和`reject()`中不同值情况 进行处理。

`resolve()`和`reject()` 返回的 `x` 值的几种情况：

1. 普通值
2. Promise对象
3. thenable对象/函数

**下面我们就根据总结的两点，结合 `Promises/A+ 规范` 来实现 `then` 方法的链式调用 💪💪💪**

## 3. then 方法返回一个新的Promise

◾ **2.2.7规范 then 方法必须返回一个 promise 对象**

我们在`then`方法里面返回一个 **`新的手写Promise实例`**，再把原来的代码复制上去：

```javascript
class myPromise {
	...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };
        
+       const promise2 = new myPromise((resolve, reject) => {
            if (this.PromiseState === myPromise.FULFILLED) {
                setTimeout(() => {
                    onFulfilled(this.PromiseResult);
                });
            } else if (this.PromiseState === myPromise.REJECTED) {
                setTimeout(() => {
                    onRejected(this.PromiseResult);
                });
            } else if (this.PromiseState === myPromise.PENDING) {
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
                        onFulfilled(this.PromiseResult);
                    });
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        onRejected(this.PromiseResult);
                    });
                });
            }
+       })
        
+       return promise2
    }
}
复制代码
```

**◾ 2.2.7.1规范** 如果 `onFulfilled` 或者 `onRejected` 返回一个值 `x` ，则运行下面的 **Promise 解决过程：`[[Resolve]](promise2, x)`**

```javascript
class myPromise {
	...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : +reason => {
            throw reason;
        };

        const promise2 = new myPromise((resolve, reject) => {
            if (this.PromiseState === myPromise.FULFILLED) {
                setTimeout(() => {
+                   let x = onFulfilled(this.PromiseResult);
+                   resolvePromise(promise2, x, resolve, reject);
                });
            } else if (this.PromiseState === myPromise.REJECTED) {
                setTimeout(() => {
+                   let x = onRejected(this.PromiseResult);
+                   resolvePromise(promise2, x, resolve, reject);
                });
            } else if (this.PromiseState === myPromise.PENDING) {
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
                        onFulfilled(this.PromiseResult);
                    });
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        onRejected(this.PromiseResult);
                    });
                });
            }
        })

        return promise2
    }
}

+/**
+ * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
+ * @param  {promise} promise2 promise1.then方法返回的新的promise对象
+ * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
+ * @param  {[type]} resolve   promise2的resolve方法
+ * @param  {[type]} reject    promise2的reject方法
+ */
+ function resolvePromise(promise2, x, resolve, reject) {}
复制代码
```

我们在 `myPromise` 类外面声明了一个 **Promise 解决过程**：

```javascript
function resolvePromise(promise2, x, resolve, reject) {

}
复制代码
```

**`resolvePromise()` 具体方法我们后面会补充~**

**◾ 2.2.7.2 如果 `onFulfilled` 或者 `onRejected` 抛出一个异常 `e` ，则 `promise2` 必须拒绝执行，并返回拒因 `e`**

```javascript
class myPromise {
	...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };

        const promise2 = new myPromise((resolve, reject) => {
            if (this.PromiseState === myPromise.FULFILLED) {
                setTimeout(() => {
+                   try {
                        let x = onFulfilled(this.PromiseResult);
                        resolvePromise(promise2, x, resolve, reject);
+                   } catch (e) {
+                       reject(e); // 捕获前面onFulfilled中抛出的异常
+                   }
                });
            } else if (this.PromiseState === myPromise.REJECTED) {
                setTimeout(() => {
+                   try {
                        let x = onRejected(this.PromiseResult);
                        resolvePromise(promise2, x, resolve, reject);
+                   } catch (e) {
+                       reject(e)
+                   }
                });
            } else if (this.PromiseState === myPromise.PENDING) {
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
                        onFulfilled(this.PromiseResult);
                    });
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        onRejected(this.PromiseResult);
                    });
                });
            }
        })

        return promise2
    }
}

/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {}
复制代码
```

**◾ `fulfilled` 和 `rejected` 状态处理完，不要忘了 `pending` 状态的情况**

我们在 `pending` 状态保存的 `resolve()` 和 `reject()` 回调也要符合 `2.2.7.1 和 2.2.7.2 规范`：

> 如果 `onFulfilled` 或者 `onRejected` 返回一个值 `x` ，则运行 Promise 解决过程：`[[Resolve]](promise2, x)`

> 如果 `onFulfilled` 或者 `onRejected` 抛出一个异常 `e` ，则 `promise2` 必须拒绝执行，并返回拒因 `e`

```javascript
class myPromise {
	...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };

        const promise2 = new myPromise((resolve, reject) => {
            if (this.PromiseState === myPromise.FULFILLED) {
                setTimeout(() => {
                    try {
                        let x = onFulfilled(this.PromiseResult);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (e) {
                        reject(e); // 捕获前面onFulfilled中抛出的异常
                    }
                });
            } else if (this.PromiseState === myPromise.REJECTED) {
                setTimeout(() => {
                    try {
                        let x = onRejected(this.PromiseResult);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (e) {
                        reject(e)
                    }
                });
            } else if (this.PromiseState === myPromise.PENDING) {
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
+                       try {
+                           let x = onFulfilled(this.PromiseResult);
+                           resolvePromise(promise2, x, resolve, reject)
+                       } catch (e) {
+                           reject(e);
+                       }
                    });
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
+                       try {
+                           let x = onRejected(this.PromiseResult);
+                           resolvePromise(promise2, x, resolve, reject);
+                       } catch (e) {
+                           reject(e);
+                       }
                    });
                });
            }
        })

        return promise2
    }
}

/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {}
复制代码
```

**◾ 2.2.7.3 如果 `onFulfilled` 不是函数且 `promise1` 成功执行， `promise2` 必须成功执行并返回相同的值**

```js
class myPromise {
    ...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };

        const promise2 = new myPromise((resolve, reject) => {
            if (this.PromiseState === myPromise.FULFILLED) {
                setTimeout(() => {
                    try {
+                       if (typeof onFulfilled !== 'function') {
+                           resolve(this.PromiseResult);
+                       } else {
                            let x = onFulfilled(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
+                       }
                    } catch (e) {
                        reject(e);
                    }
                });
            } else if (this.PromiseState === myPromise.REJECTED) {
                setTimeout(() => {
                    try {
                        let x = onRejected(this.PromiseResult);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (e) {
                        reject(e)
                    }
                });
            } else if (this.PromiseState === myPromise.PENDING) {
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
                        try {
+                           if (typeof onFulfilled !== 'function') {
+                               resolve(this.PromiseResult);
+                           } else {
                                let x = onFulfilled(this.PromiseResult);
                                resolvePromise(promise2, x, resolve, reject);
+                           }
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            let x = onRejected(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            }
        })

        return promise2
    }
}

/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {}
复制代码
```

**◾ 2.2.7.4 如果 `onRejected` 不是函数且 `promise1` 拒绝执行， `promise2` 必须拒绝执行并返回相同的据因**

```js
class myPromise {
    ...
    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {
            throw reason;
        };

        const promise2 = new myPromise((resolve, reject) => {
            if (this.PromiseState === myPromise.FULFILLED) {
                setTimeout(() => {
                    try {
                        if (typeof onFulfilled !== 'function') {
                            resolve(this.PromiseResult);
                        } else {
                            let x = onFulfilled(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
                        }
                    } catch (e) {
                        reject(e);
                    }
                });
            } else if (this.PromiseState === myPromise.REJECTED) {
                setTimeout(() => {
                    try {
+                       if (typeof onRejected !== 'function') {
+                           reject(this.PromiseResult);
+                       } else {
                            let x = onRejected(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
+                       }
                    } catch (e) {
                        reject(e)
                    }
                });
            } else if (this.PromiseState === myPromise.PENDING) {
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            if (typeof onFulfilled !== 'function') {
                                resolve(this.PromiseResult);
                            } else {
                                let x = onFulfilled(this.PromiseResult);
                                resolvePromise(promise2, x, resolve, reject);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        try {
+                           if (typeof onRejected !== 'function') {
+                               reject(this.PromiseResult);
+                           } else {
                                let x = onRejected(this.PromiseResult);
                                resolvePromise(promise2, x, resolve, reject);
+                           }
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            }
        })

        return promise2
    }
}

/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {}
复制代码
```

规范 **2.2.7.3** 和 **2.2.7.4** 对 `onFulfilled` 和 `onRejected` 不是函数的情况做了更详细的描述，根据描述我们对 `onFulfilled` 和 `onRejected` 引入了新的参数校验，所以之前的参数校验就可以退役了：

```js
class myPromise {
    ...
    then(onFulfilled, onRejected) {
-       onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
-       onRejected = typeof onRejected === 'function' ? onRejected : reason => {
-           throw reason;
-       };
    
    ...
    }
}

/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {}
复制代码
```

搞定 `then` 方法 😎

下面我们开始着手写 **promise 解决过程 `resolvePromise(promise2, x, resolve, reject)`**

# 六、实现 resolvePromise 方法

**◾ 2.3.1 如果 `promise` 和 `x` 指向同一对象，以 `TypeError` 为据因拒绝执行 `promise`**

```javascript
class myPromise {
    ...
    then(onFulfilled, onRejected) {
        const promise2 = new myPromise((resolve, reject) => {
            if (this.PromiseState === myPromise.FULFILLED) {
                setTimeout(() => {
                    try {
                        if (typeof onFulfilled !== 'function') {
                            resolve(this.PromiseResult);
                        } else {
                            let x = onFulfilled(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
                        }
                    } catch (e) {
                        reject(e);
                    }
                });
            } else if (this.PromiseState === myPromise.REJECTED) {
                setTimeout(() => {
                    try {
                        if (typeof onRejected !== 'function') {
                            reject(this.PromiseResult);
                        } else {
                            let x = onRejected(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
                        }
                    } catch (e) {
                        reject(e)
                    }
                });
            } else if (this.PromiseState === myPromise.PENDING) {
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            if (typeof onFulfilled !== 'function') {
                                resolve(this.PromiseResult);
                            } else {
                                let x = onFulfilled(this.PromiseResult);
                                resolvePromise(promise2, x, resolve, reject);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            if (typeof onRejected !== 'function') {
                                reject(this.PromiseResult);
                            } else {
                                let x = onRejected(this.PromiseResult);
                                resolvePromise(promise2, x, resolve, reject);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            }
        })

        return promise2
    }
}

/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {
+   if (x === promise2) {
+       throw new TypeError('Chaining cycle detected for promise');
+   }
}
复制代码
```

在这里我们只需要抛出一个 `TypeError` 的异常即可，因为调用 `resolvePromise` 方法外层的 `try...catch` 会抓住这个异常，然后 **以 TypeError 为据因拒绝执行 promise。**

如果从 `onFulfilled` 或 `onRejected` 中返回的 x 就是 promise2，会导致 **循环引用报错**，这部分的处理就是要解决这个问题。

举一个 **循环引用** 的例子🌰：

```javascript
const promise = new Promise((resolve, reject) => {
  resolve(100)
})
const p1 = promise.then(value => {
  console.log(value)
  return p1
})
复制代码
```

使用原生 Promise 执行这个代码，会报类型错误：

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce362aa04d1474899056757d69c2a80~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**◾ 2.3.2 如果 `x` 为 Promise ，则使 `promise` 接受 `x` 的状态**

```javascript
class myPromise {
	...
}

/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {
    if (x === promise2) {
        throw new TypeError('Chaining cycle detected for promise');
    }

+   if (x instanceof myPromise) {
+       /**
+        * 2.3.2 如果 x 为 Promise ，则使 promise2 接受 x 的状态
+        *       也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y
+        */
+       x.then(y => {
+           resolvePromise(promise2, y, resolve, reject)
+       }, reject);
+   }
}
复制代码
```

马上就要成功啦😸，还有最后一条😎

**◾ 2.3.3 如果 `x` 为对象或者函数** **◾ 2.3.4 如果 `x` 不为对象或者函数，以 `x` 为参数执行 `promise`**

在判断`x`是对象或函数时，`x` 不能是 `null`，因为 `typeof  null`的值也为 `object`

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1976a2fb1142468185be97771c418c3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

我们应该显式的声明 `x != null`，这样 当 `x` 为 `null` 时，直接执行`resolve(x)`，否则，如果不这样不声明，`x` 为 `null` 时就会走到`catch`然后`reject`，这不是我们要的，所以需要检测下`null`：

```javascript
if (x != null && ((typeof x === 'object' || (typeof x === 'function'))))
复制代码
```

**◾ 2.3.3 和 2.3.4 规范实现如下：**

```javascript
class myPromise {
	...
}

/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {
    if (x === promise2) {
        throw new TypeError('Chaining cycle detected for promise');
    }

    if (x instanceof myPromise) {
        /**
         * 2.3.2 如果 x 为 Promise ，则使 promise2 接受 x 的状态
         *       也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y
         */
        x.then(y => {
            resolvePromise(promise2, y, resolve, reject)
        }, reject);
+   } else if (x !== null && ((typeof x === 'object' || (typeof x === 'function')))) {
+       // 2.3.3 如果 x 为对象或函数
+       try {
+           // 2.3.3.1 把 x.then 赋值给 then
+           var then = x.then;
+       } catch (e) {
+           // 2.3.3.2 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise
+           return reject(e);
+       }
+
+       /**
+        * 2.3.3.3 
+        * 如果 then 是函数，将 x 作为函数的作用域 this 调用之。
+        * 传递两个回调函数作为参数，
+        * 第一个参数叫做 `resolvePromise` ，第二个参数叫做 `rejectPromise`
+        */
+       if (typeof then === 'function') {
+           // 2.3.3.3.3 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用
+           let called = false; // 避免多次调用
+           try {
+               then.call(
+                   x,
+                   // 2.3.3.3.1 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)
+                   y => {
+                       if (called) return;
+                       called = true;
+                       resolvePromise(promise2, y, resolve, reject);
+                   },
+                   // 2.3.3.3.2 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise
+                   r => {
+                       if (called) return;
+                       called = true;
+                       reject(r);
+                   }
+               )
+           } catch (e) {
+               /**
+                * 2.3.3.3.4 如果调用 then 方法抛出了异常 e
+                * 2.3.3.3.4.1 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之
+                */
+               if (called) return;
+               called = true;
+
+               /**
+                * 2.3.3.3.4.2 否则以 e 为据因拒绝 promise
+                */
+               reject(e);
+           }
+       } else {
+           // 2.3.3.4 如果 then 不是函数，以 x 为参数执行 promise
+           resolve(x);
+       }
+   } else {
+       // 2.3.4 如果 x 不为对象或者函数，以 x 为参数执行 promise
+       return resolve(x);
+   }
}
复制代码
```

**打完收工**✨✨✨✨

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/083987eb143d45f7bb02b903dc56fe99~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**`resolvePromise()`方法 完整代码：**

```javascript
/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {
    if (x === promise2) {
        throw new TypeError('Chaining cycle detected for promise');
    }

    if (x instanceof myPromise) {
        /**
         * 2.3.2 如果 x 为 Promise ，则使 promise2 接受 x 的状态
         *       也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y
         */
        x.then(y => {
            resolvePromise(promise2, y, resolve, reject)
        }, reject);
    } else if (x !== null && ((typeof x === 'object' || (typeof x === 'function')))) {
        // 2.3.3 如果 x 为对象或函数
        try {
            // 2.3.3.1 把 x.then 赋值给 then
            var then = x.then;
        } catch (e) {
            // 2.3.3.2 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise
            return reject(e);
        }

        /**
         * 2.3.3.3 
         * 如果 then 是函数，将 x 作为函数的作用域 this 调用之。
         * 传递两个回调函数作为参数，
         * 第一个参数叫做 `resolvePromise` ，第二个参数叫做 `rejectPromise`
         */
        if (typeof then === 'function') {
            // 2.3.3.3.3 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用
            let called = false; // 避免多次调用
            try {
                then.call(
                    x,
                    // 2.3.3.3.1 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)
                    y => {
                        if (called) return;
                        called = true;
                        resolvePromise(promise2, y, resolve, reject);
                    },
                    // 2.3.3.3.2 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise
                    r => {
                        if (called) return;
                        called = true;
                        reject(r);
                    }
                )
            } catch (e) {
                /**
                 * 2.3.3.3.4 如果调用 then 方法抛出了异常 e
                 * 2.3.3.3.4.1 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之
                 */
                if (called) return;
                called = true;

                /**
                 * 2.3.3.3.4.2 否则以 e 为据因拒绝 promise
                 */
                reject(e);
            }
        } else {
            // 2.3.3.4 如果 then 不是函数，以 x 为参数执行 promise
            resolve(x);
        }
    } else {
        // 2.3.4 如果 x 不为对象或者函数，以 x 为参数执行 promise
        return resolve(x);
    }
}
复制代码
```

# 七、完整的 Promises/A+ 实现

到这里我们的`myPromsie`已经完成了 **Promises/A+ 规范** 😸

> ES6的官方Promise还有很多API，但这些都不在Promises/A+里面

这里为大家提供了两个完整的 Promises/A+ 实现版本：

1. 清爽简洁 无注释版
2. 按步分析 注释加持版

## 1. 清爽简洁 无注释版

**完整的 Promises/A+ 实现 `(清爽简洁 无注释版)`：**

*完整版的代码较长，这里如果看不清楚的可以去我的GitHub上看，我专门维护了一个 手写 Promsie 的仓库*：[github.com/yuanyuanbyt…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyuanyuanbyte%2FPromise)

```javascript
class myPromise {
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';

    constructor(func) {
        this.PromiseState = myPromise.PENDING;
        this.PromiseResult = null;
        this.onFulfilledCallbacks = [];
        this.onRejectedCallbacks = [];
        try {
            func(this.resolve.bind(this), this.reject.bind(this));
        } catch (error) {
            this.reject(error)
        }
    }

    resolve(result) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
            this.onFulfilledCallbacks.forEach(callback => {
                callback(result)
            })
        }
    }

    reject(reason) {
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECTED;
            this.PromiseResult = reason;
            this.onRejectedCallbacks.forEach(callback => {
                callback(reason)
            })
        }
    }

    then(onFulfilled, onRejected) {
        let promise2 = new myPromise((resolve, reject) => {
            if (this.PromiseState === myPromise.FULFILLED) {
                setTimeout(() => {
                    try {
                        if (typeof onFulfilled !== 'function') {
                            resolve(this.PromiseResult);
                        } else {
                            let x = onFulfilled(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
                        }
                    } catch (e) {
                        reject(e);
                    }
                });
            } else if (this.PromiseState === myPromise.REJECTED) {
                setTimeout(() => {
                    try {
                        if (typeof onRejected !== 'function') {
                            reject(this.PromiseResult);
                        } else {
                            let x = onRejected(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
                        }
                    } catch (e) {
                        reject(e)
                    }
                });
            } else if (this.PromiseState === myPromise.PENDING) {
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            if (typeof onFulfilled !== 'function') {
                                resolve(this.PromiseResult);
                            } else {
                                let x = onFulfilled(this.PromiseResult);
                                resolvePromise(promise2, x, resolve, reject);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            if (typeof onRejected !== 'function') {
                                reject(this.PromiseResult);
                            } else {
                                let x = onRejected(this.PromiseResult);
                                resolvePromise(promise2, x, resolve, reject);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            }
        })

        return promise2
    }
}

function resolvePromise(promise2, x, resolve, reject) {
    if (x === promise2) {
        throw new TypeError('Chaining cycle detected for promise');
    }

    if (x instanceof myPromise) {
        x.then(y => {
            resolvePromise(promise2, y, resolve, reject)
        }, reject);
    } else if (x !== null && ((typeof x === 'object' || (typeof x === 'function')))) {
        try {
            var then = x.then;
        } catch (e) {
            return reject(e);
        }

        if (typeof then === 'function') {
            let called = false;
            try {
                then.call(
                    x,
                    y => {
                        if (called) return;
                        called = true;
                        resolvePromise(promise2, y, resolve, reject);
                    },
                    r => {
                        if (called) return;
                        called = true;
                        reject(r);
                    }
                )
            } catch (e) {
                if (called) return;
                called = true;

                reject(e);
            }
        } else {
            resolve(x);
        }
    } else {
        return resolve(x);
    }
}
复制代码
```

## 2. 按步分析 注释加持版

**完整的 Promises/A+ 实现 `(按步分析 注释加持版)`：**

*完整版的代码较长，这里如果看不清楚的可以去我的GitHub上看，我专门维护了一个 手写 Promsie 的仓库*：[github.com/yuanyuanbyt…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyuanyuanbyte%2FPromise)

```javascript
class myPromise {
    // 用static创建静态属性，用来管理状态
    static PENDING = 'pending';
    static FULFILLED = 'fulfilled';
    static REJECTED = 'rejected';

    // 构造函数：通过new命令生成对象实例时，自动调用类的构造函数
    constructor(func) { // 给类的构造方法constructor添加一个参数func
        this.PromiseState = myPromise.PENDING; // 指定Promise对象的状态属性 PromiseState，初始值为pending
        this.PromiseResult = null; // 指定Promise对象的结果 PromiseResult
        this.onFulfilledCallbacks = []; // 保存成功回调
        this.onRejectedCallbacks = []; // 保存失败回调
        try {
            /**
             * func()传入resolve和reject，
             * resolve()和reject()方法在外部调用，这里需要用bind修正一下this指向
             * new 对象实例时，自动执行func()
             */
            func(this.resolve.bind(this), this.reject.bind(this));
        } catch (error) {
            // 生成实例时(执行resolve和reject)，如果报错，就把错误信息传入给reject()方法，并且直接执行reject()方法
            this.reject(error)
        }
    }

    resolve(result) { // result为成功态时接收的终值
        // 只能由pending状态 => fulfilled状态 (避免调用多次resolve reject)
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.FULFILLED;
            this.PromiseResult = result;
            /**
             * 在执行resolve或者reject的时候，遍历自身的callbacks数组，
             * 看看数组里面有没有then那边 保留 过来的 待执行函数，
             * 然后逐个执行数组里面的函数，执行的时候会传入相应的参数
             */
            this.onFulfilledCallbacks.forEach(callback => {
                callback(result)
            })
        }
    }

    reject(reason) { // reason为拒绝态时接收的终值
        // 只能由pending状态 => rejected状态 (避免调用多次resolve reject)
        if (this.PromiseState === myPromise.PENDING) {
            this.PromiseState = myPromise.REJECTED;
            this.PromiseResult = reason;
            this.onRejectedCallbacks.forEach(callback => {
                callback(reason)
            })
        }
    }

    /**
     * [注册fulfilled状态/rejected状态对应的回调函数] 
     * @param {function} onFulfilled  fulfilled状态时 执行的函数
     * @param {function} onRejected  rejected状态时 执行的函数 
     * @returns {function} newPromsie  返回一个新的promise对象
     */
    then(onFulfilled, onRejected) {
        // 2.2.7规范 then 方法必须返回一个 promise 对象
        let promise2 = new myPromise((resolve, reject) => {
            if (this.PromiseState === myPromise.FULFILLED) {
                /**
                 * 为什么这里要加定时器setTimeout？
                 * 2.2.4规范 onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 注1
                 * 这里的平台代码指的是引擎、环境以及 promise 的实施代码。
                 * 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。
                 * 这个事件队列可以采用“宏任务（macro-task）”机制，比如setTimeout 或者 setImmediate； 也可以采用“微任务（micro-task）”机制来实现， 比如 MutationObserver 或者process.nextTick。
                 */
                setTimeout(() => {
                    try {
                        if (typeof onFulfilled !== 'function') {
                            // 2.2.7.3规范 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值
                            resolve(this.PromiseResult);
                        } else {
                            // 2.2.7.1规范 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)，即运行resolvePromise()
                            let x = onFulfilled(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
                        }
                    } catch (e) {
                        // 2.2.7.2规范 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e
                        reject(e); // 捕获前面onFulfilled中抛出的异常
                    }
                });
            } else if (this.PromiseState === myPromise.REJECTED) {
                setTimeout(() => {
                    try {
                        if (typeof onRejected !== 'function') {
                            // 2.2.7.4规范 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因
                            reject(this.PromiseResult);
                        } else {
                            let x = onRejected(this.PromiseResult);
                            resolvePromise(promise2, x, resolve, reject);
                        }
                    } catch (e) {
                        reject(e)
                    }
                });
            } else if (this.PromiseState === myPromise.PENDING) {
                // pending 状态保存的 onFulfilled() 和 onRejected() 回调也要符合 2.2.7.1，2.2.7.2，2.2.7.3 和 2.2.7.4 规范
                this.onFulfilledCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            if (typeof onFulfilled !== 'function') {
                                resolve(this.PromiseResult);
                            } else {
                                let x = onFulfilled(this.PromiseResult);
                                resolvePromise(promise2, x, resolve, reject);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
                this.onRejectedCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            if (typeof onRejected !== 'function') {
                                reject(this.PromiseResult);
                            } else {
                                let x = onRejected(this.PromiseResult);
                                resolvePromise(promise2, x, resolve, reject);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            }
        })

        return promise2
    }
}

/**
 * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled或onRejected的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */
function resolvePromise(promise2, x, resolve, reject) {
    // 2.3.1规范 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise
    if (x === promise2) {
        throw new TypeError('Chaining cycle detected for promise');
    }

    if (x instanceof myPromise) {
        /**
         * 2.3.2 如果 x 为 Promise ，则使 promise2 接受 x 的状态
         *       也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y
         */
        x.then(y => {
            resolvePromise(promise2, y, resolve, reject)
        }, reject);
    } else if (x !== null && ((typeof x === 'object' || (typeof x === 'function')))) {
        // 2.3.3 如果 x 为对象或函数
        try {
            // 2.3.3.1 把 x.then 赋值给 then
            var then = x.then;
        } catch (e) {
            // 2.3.3.2 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise
            return reject(e);
        }

        /**
         * 2.3.3.3 
         * 如果 then 是函数，将 x 作为函数的作用域 this 调用之。
         * 传递两个回调函数作为参数，
         * 第一个参数叫做 `resolvePromise` ，第二个参数叫做 `rejectPromise`
         */
        if (typeof then === 'function') {
            // 2.3.3.3.3 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用
            let called = false; // 避免多次调用
            try {
                then.call(
                    x,
                    // 2.3.3.3.1 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)
                    y => {
                        if (called) return;
                        called = true;
                        resolvePromise(promise2, y, resolve, reject);
                    },
                    // 2.3.3.3.2 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise
                    r => {
                        if (called) return;
                        called = true;
                        reject(r);
                    }
                )
            } catch (e) {
                /**
                 * 2.3.3.3.4 如果调用 then 方法抛出了异常 e
                 * 2.3.3.3.4.1 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之
                 */
                if (called) return;
                called = true;

                // 2.3.3.3.4.2 否则以 e 为据因拒绝 promise
                reject(e);
            }
        } else {
            // 2.3.3.4 如果 then 不是函数，以 x 为参数执行 promise
            resolve(x);
        }
    } else {
        // 2.3.4 如果 x 不为对象或者函数，以 x 为参数执行 promise
        return resolve(x);
    }
}
复制代码
```

# 八、Promise A+ 测试

如何证明我们写的`myPromise`就符合 **Promises/A+** 规范呢？

跑一下 Promise A+ 测试 就好啦~

## 1. 安装官方测试工具

我们使用Promises/A+官方的测试工具 [promises-aplus-tests](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpromises-aplus%2Fpromises-tests) 来对我们的`myPromise`进行测试

**安装 `promises-aplus-tests`:**

```shell
npm install promises-aplus-tests -D
复制代码
```

**安装完测试工具后的项目目录：**

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7151919f5a44882b61466d0e2cf7d31~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 2.  使用 CommonJS 对外暴露 myPromise 类

```javascript
class myPromise {
	...
}

function resolvePromise(promise2, x, resolve, reject) { 
	...
}

+ module.exports = myPromise;
复制代码
```

## 3. 实现静态方法 deferred

要使用 `promises-aplus-tests` 这个工具测试，必须实现一个静态方法`deferred()`，官方对这个方法的定义如下:

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/370aab7c0bed4cd6b360ddee24b0cd0d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

意思就是：

我们要给自己手写的`myPromise`上实现一个静态方法`deferred()`，该方法要返回一个包含`{ promise, resolve, reject }`的对象：

- `promise` 是一个处于`pending`状态的 Promsie。
- `resolve(value)` 用`value`解决上面那个`promise`
- `reject(reason)` 用`reason`拒绝上面那个`promise`

**`deferred()`的实现如下：**

```javascript
class myPromise {
	...
}

function resolvePromise(promise2, x, resolve, reject) { 
	...
}

+  myPromise.deferred = function () {
+      let result = {};
+      result.promise = new myPromise((resolve, reject) => {
+          result.resolve = resolve;
+          result.reject = reject;
+      });
+      return result;
+  }

module.exports = myPromise;
复制代码
```

## 4. 配置 package.json

我们实现了`deferred `方法，也通过 CommonJS 对外暴露了`myPromise`，最后配置一下`package.json`就可以跑测试啦~😺

新建一个 `package.json` ，**配置如下：**

```javascript
// package.json
{
  "devDependencies": {
    "promises-aplus-tests": "^2.1.2"
  },
  "scripts": {
    "test": "promises-aplus-tests myPromise"
  }
}
复制代码
```

**项目目录：**

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/830bd69f1d4f42c397004c45e954e33a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

准备工作已就绪👏👏👏

激动人心的时刻马上就要到啦，嘿嘿😸

## 5. 完美通过官方872个测试用例

**执行测试命令：**

```shell
npm run test
复制代码
```

肯定都等不及了吧~😜 快来看看我们的测试结果吧，走起 🚀

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93d8240233514a888b2276a84afbbcb3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

Promises/A+ 测试总共872用例，我们写的Promise完美通过了所有用例:

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/825b38548ff847b1afbd4342da1aebad~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

# 九、其他方法

在 ES6 的官方 Promise 还有很多API，比如：

- Promise.resolve
- Promise.reject
- Promise.prototype.catch
- Promise.prototype.finally
- Promise.all
- Promise.allSettled
- Promise.race

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d7cd1a55e1342019cb28ba1405a9da5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

虽然这些都不在 Promises/A+ 规范里面，但是我们也来实现一下吧，加深理解。其实我们前面我们用了很大功夫实现了 Promises/A+ ，现在再来实现这些已经是小菜一碟了，因为这些API全部是前面的封装而已。

## 1. 实现 Promise.resolve

## 2. 实现 Promise.reject

## 3. 实现 Promise.prototype.catch

## 4. 实现 Promise.prototype.finally

## 5. 实现 Promise.all

## 6. 实现 Promise.allSettled

## 7. 实现 Promise.any

## 8. 实现 Promise.race()

*因文章字数限制，Promise 其他方法的手写实现已放在下篇：* [看了就会，手写 Promise 全部 API 教程，包括处于 TC39 第四阶段草案的 Promise.any()](https://juejin.cn/post/7044088065874198536)

# ❤️ 结尾

如果这篇文章 **对你的学习** 有所 **帮助**，欢迎 **点赞** 👍 **收藏** ⭐ **留言** 📝 ，**你的支持** 是我 **创作分享** 的 **动力！**

*学习过程中如果有疑问，[点击这里](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyuanyuanbyte%2FBlog)，可以获得我的联系方式，与我交流~*

**关注公众号「前端圆圆」**，第一时间获取文章更新。

**更多更全更详细** 的 **优质内容**， **[猛戳这里查看](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyuanyuanbyte%2FBlog)**

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd520cf6949f40fcae03b779c4019802~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

# 声明

本文 “第四节：实现异步” 之前的内容 都是学习自B站 up主 **技术蛋老师**：[www.bilibili.com/video/BV1RR…](https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1RR4y1p7my)

*注：本篇文章的内容我已于 B站 up主 **技术蛋老师** 交流并取得认可，已经获得免责。*

没有 蛋老师 的视频，这篇文章可能要很晚才能跟大家见面~

**蛋老师 [space.bilibili.com/327247876](https://link.juejin.cn?target=https%3A%2F%2Fspace.bilibili.com%2F327247876) 的视频质量都很高**，节流和防抖我就是通过蛋老师的视频学习的，里面还有很多视频内容，通俗易懂，我自己都后悔没有早点接触蛋老师，少走多少弯路啊，**欢迎大家支持关注蛋老师**💝~

# 参考



笔者刚接触`async/await`时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：

1. `Promise`的实现原理
2. `async/await`的实现原理
3. `Generator`的实现原理

# Promise实现

在成文过程中，笔者查阅了很多讲解Promise实现的文章，但感觉大多文章都很难称得上条理清晰，有的上来就放大段Promise规范翻译，有的在Promise基础使用上浪费篇幅，又或者把一个简单的东西长篇大论，过度讲解，我推荐头铁的同学直接拉到本章小结看最终实现，结合着注释直接啃代码也能理解十之八九

回归正题，文章开头我们先点一下Promise为我们解决了什么问题：在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。下面我们就来一步步实现一个Promise：

## 1. 观察者模式

我们先来看一个最简单的Promise使用：

```javascript
const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('result')
    },
    1000);
}) 

p1.then(res => console.log(res), err => console.log(err))
复制代码
```

观察这个例子，我们分析Promise的调用流程：

- `Promise`的构造方法接收一个`executor()`，在`new Promise()`时就立刻执行这个executor回调
- `executor()`内部的异步任务被放入宏/微任务队列，等待执行
- `then()`被执行，收集成功/失败回调，放入成功/失败队列
- `executor()`的异步任务被执行，触发`resolve/reject`，从成功/失败队列中取出回调依次执行

其实熟悉设计模式的同学，很容易就能意识到这是个**观察者模式**，这种`收集依赖 -> 触发通知 -> 取出依赖执行` 的方式，被广泛运用于观察者模式的实现，在Promise里，执行顺序是`then收集依赖 -> 异步触发resolve -> resolve执行依赖`。依此，我们可以勾勒出Promise的大致形状：

```js
class MyPromise {
  // 构造方法接收一个回调
  constructor(executor) {
    this._resolveQueue = []    // then收集的执行成功的回调队列
    this._rejectQueue = []     // then收集的执行失败的回调队列

    // 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue
    let _resolve = (val) => {
      // 从成功队列里取出回调依次执行
      while(this._resolveQueue.length) {
        const callback = this._resolveQueue.shift()
        callback(val)
      }
    }
    // 实现同resolve
    let _reject = (val) => {
      while(this._rejectQueue.length) {
        const callback = this._rejectQueue.shift()
        callback(val)
      }
    }
    // new Promise()时立即执行executor,并传入resolve和reject
    executor(_resolve, _reject)
  }

  // then方法,接收一个成功的回调和一个失败的回调，并push进对应队列
  then(resolveFn, rejectFn) {
    this._resolveQueue.push(resolveFn)
    this._rejectQueue.push(rejectFn)
  }
}
复制代码
```

写完代码我们可以测试一下:

```js
const p1 = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve('result')
  }, 1000);
})
p1.then(res => console.log(res))
//一秒后输出result
复制代码
```

我们运用观察者模式简单的实现了一下`then`和`resolve`，使我们能够在then方法的回调里取得异步操作的返回值，但我们这个Promise离最终实现还有很长的距离，下面我们来一步步补充这个Promise：

## 2. Promise A+规范

上面我们已经简单地实现了一个超低配版Promise，但我们会看到很多文章和我们写的不一样，他们的Promise实现中还引入了各种状态控制，这是由于ES6的Promise实现需要遵循[Promise/A+规范](https://link.juejin.cn?target=https%3A%2F%2Fpromisesaplus.com%2F)，是规范对Promise的状态控制做了要求。Promise/A+的规范比较长，这里只总结两条核心规则：

> 1. Promise本质是一个状态机，且状态只能为以下三种：`Pending（等待态）`、`Fulfilled（执行态）`、`Rejected（拒绝态）`，状态的变更是单向的，只能从Pending -> Fulfilled 或 Pending -> Rejected，状态变更不可逆
> 2. `then方法`接收两个可选参数，分别对应状态改变时触发的回调。then方法返回一个promise。then 方法可以被同一个 promise 调用多次。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/26/161d2454e68ff07b~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp) 根据规范，我们补充一下Promise的代码：

```js
//Promise/A+规范的三种状态
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class MyPromise {
  // 构造方法接收一个回调
  constructor(executor) {
    this._status = PENDING     // Promise状态
    this._resolveQueue = []    // 成功队列, resolve时触发
    this._rejectQueue = []     // 失败队列, reject时触发

    // 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue
    let _resolve = (val) => {
      if(this._status !== PENDING) return   // 对应规范中的"状态只能由pending到fulfilled或rejected"
      this._status = FULFILLED              // 变更状态

      // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"
      // 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调
      while(this._resolveQueue.length) {    
        const callback = this._resolveQueue.shift()
        callback(val)
      }
    }
    // 实现同resolve
    let _reject = (val) => {
      if(this._status !== PENDING) return   // 对应规范中的"状态只能由pending到fulfilled或rejected"
      this._status = REJECTED               // 变更状态
      while(this._rejectQueue.length) {
        const callback = this._rejectQueue.shift()
        callback(val)
      }
    }
    // new Promise()时立即执行executor,并传入resolve和reject
    executor(_resolve, _reject)
  }

  // then方法,接收一个成功的回调和一个失败的回调
  then(resolveFn, rejectFn) {
    this._resolveQueue.push(resolveFn)
    this._rejectQueue.push(rejectFn)
  }
}
复制代码
```

## 3. then的链式调用

补充完规范，我们接着来实现链式调用，这是Promise实现的重点和难点，我们先来看一下then是如何链式调用的：

```js
const p1 = new Promise((resolve, reject) => {
  resolve(1)
})

p1
  .then(res => {
    console.log(res)
    //then回调中可以return一个Promise
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(2)
      }, 1000);
    })
  })
  .then(res => {
    console.log(res)
    //then回调中也可以return一个值
    return 3
  })
  .then(res => {
    console.log(res)
  })
复制代码
```

输出

```
1
2
3
复制代码
```

我们思考一下如何实现这种链式调用：

1. 显然`.then()`需要返回一个Promise，这样才能找到then方法，所以我们会把then方法的返回值包装成Promise。
2. `.then()`的回调需要拿到上一个`.then()`的返回值
3. `.then()`的回调需要顺序执行，以上面这段代码为例，虽然中间return了一个Promise，但执行顺序仍要保证是1->2->3。我们要等待当前Promise状态变更后，再执行下一个then收集的回调，这就要求我们对then的返回值分类讨论

```js
// then方法
then(resolveFn, rejectFn) {
  //return一个新的promise
  return new MyPromise((resolve, reject) => {
    //把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论
    const fulfilledFn = value => {
      try {
        //执行第一个(当前的)Promise的成功回调,并获取返回值
        let x = resolveFn(value)
        //分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve
        //这里resolve之后，就能被下一个.then()的回调获取到返回值，从而实现链式调用
        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
      } catch (error) {
        reject(error)
      }
    }
    //把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用
    this._resolveQueue.push(fulfilledFn)

    //reject同理
    const rejectedFn  = error => {
      try {
        let x = rejectFn(error)
        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
      } catch (error) {
        reject(error)
      }
    }
    this._rejectQueue.push(rejectedFn)
  })
}
复制代码
```

然后我们就能测试一下链式调用：

```js
const p1 = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve(1)
  }, 500);
})

p1
  .then(res => {
    console.log(res)
    return 2
  })
  .then(res => {
    console.log(res)
    return 3
  })
  .then(res => {
    console.log(res)
  })

//输出 1 2 3
复制代码
```



## 4.值穿透 & 状态已变更的情况

我们已经初步完成了链式调用，但是对于 then() 方法，我们还要两个细节需要处理一下

1. **值穿透**：根据规范，如果 then() 接收的参数不是function，那么我们应该忽略它。如果没有忽略，当then()回调不为function时将会抛出异常，导致链式调用中断
2. **处理状态为resolve/reject的情况**：其实我们上边 then() 的写法是对应状态为`padding`的情况，但是有些时候，resolve/reject 在 then() 之前就被执行（比如`Promise.resolve().then()`），如果这个时候还把then()回调push进resolve/reject的执行队列里，那么回调将不会被执行，因此对于状态已经变为`fulfilled`或`rejected`的情况，我们直接执行then回调：

```js
// then方法,接收一个成功的回调和一个失败的回调
  then(resolveFn, rejectFn) {
    // 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行
    typeof resolveFn !== 'function' ? resolveFn = value => value : null
    typeof rejectFn !== 'function' ? rejectFn = reason => {
      throw new Error(reason instanceof Error? reason.message:reason);
    } : null
  
    // return一个新的promise
    return new MyPromise((resolve, reject) => {
      // 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论
      const fulfilledFn = value => {
        try {
          // 执行第一个(当前的)Promise的成功回调,并获取返回值
          let x = resolveFn(value)
          // 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }
  
      // reject同理
      const rejectedFn  = error => {
        try {
          let x = rejectFn(error)
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }
  
      switch (this._status) {
        // 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行
        case PENDING:
          this._resolveQueue.push(fulfilledFn)
          this._rejectQueue.push(rejectedFn)
          break;
        // 当状态已经变为resolve/reject时,直接执行then回调
        case FULFILLED:
          fulfilledFn(this._value)    // this._value是上一个then回调return的值(见完整版代码)
          break;
        case REJECTED:
          rejectedFn(this._value)
          break;
      }
    })
  }
复制代码
```



## 5.兼容同步任务

完成了then的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise的执行顺序是`new Promise -> then()收集回调 -> resolve/reject执行回调`，这一顺序是建立在**executor是异步任务**的前提上的，如果executor是一个同步任务，那么顺序就会变成`new Promise -> resolve/reject执行回调 -> then()收集回调`，resolve的执行跑到then之前去了，为了兼容这种情况，我们给`resolve/reject`执行回调的操作包一个setTimeout，让它异步执行。

> 这里插一句，有关这个setTimeout，其实还有一番学问。虽然规范没有要求回调应该被放进宏任务队列还是微任务队列，但其实Promise的默认实现是放进了微任务队列，我们的实现（包括大多数Promise手动实现和polyfill的转化）都是使用setTimeout放入了宏任务队列（当然我们也可以用MutationObserver模拟微任务）

```js
//Promise/A+规定的三种状态
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class MyPromise {
  // 构造方法接收一个回调
  constructor(executor) {
    this._status = PENDING     // Promise状态
    this._value = undefined    // 储存then回调return的值
    this._resolveQueue = []    // 成功队列, resolve时触发
    this._rejectQueue = []     // 失败队列, reject时触发

    // 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue
    let _resolve = (val) => {
      //把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况
      const run = () => {
        if(this._status !== PENDING) return   // 对应规范中的"状态只能由pending到fulfilled或rejected"
        this._status = FULFILLED              // 变更状态
        this._value = val                     // 储存当前value

        // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调
        while(this._resolveQueue.length) {    
          const callback = this._resolveQueue.shift()
          callback(val)
        }
      }
      setTimeout(run)
    }
    // 实现同resolve
    let _reject = (val) => {
      const run = () => {
        if(this._status !== PENDING) return   // 对应规范中的"状态只能由pending到fulfilled或rejected"
        this._status = REJECTED               // 变更状态
        this._value = val                     // 储存当前value
        while(this._rejectQueue.length) {
          const callback = this._rejectQueue.shift()
          callback(val)
        }
      }
      setTimeout(run)
    }
    // new Promise()时立即执行executor,并传入resolve和reject
    executor(_resolve, _reject)
  }

  // then方法,接收一个成功的回调和一个失败的回调
  then(resolveFn, rejectFn) {
    // 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行
    typeof resolveFn !== 'function' ? resolveFn = value => value : null
    typeof rejectFn !== 'function' ? rejectFn = reason => {
      throw new Error(reason instanceof Error? reason.message:reason);
    } : null
  
    // return一个新的promise
    return new MyPromise((resolve, reject) => {
      // 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论
      const fulfilledFn = value => {
        try {
          // 执行第一个(当前的)Promise的成功回调,并获取返回值
          let x = resolveFn(value)
          // 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }
  
      // reject同理
      const rejectedFn  = error => {
        try {
          let x = rejectFn(error)
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }
  
      switch (this._status) {
        // 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行
        case PENDING:
          this._resolveQueue.push(fulfilledFn)
          this._rejectQueue.push(rejectedFn)
          break;
        // 当状态已经变为resolve/reject时,直接执行then回调
        case FULFILLED:
          fulfilledFn(this._value)    // this._value是上一个then回调return的值(见完整版代码)
          break;
        case REJECTED:
          rejectedFn(this._value)
          break;
      }
    })
  }
}
复制代码
```

然后我们可以测试一下这个Promise：

```js
const p1 = new MyPromise((resolve, reject) => {
  resolve(1)          //同步executor测试
})

p1
  .then(res => {
    console.log(res)
    return 2          //链式调用测试
  })
  .then()             //值穿透测试
  .then(res => {
    console.log(res)
    return new MyPromise((resolve, reject) => {
      resolve(3)      //返回Promise测试
    })
  })
  .then(res => {
    console.log(res)
    throw new Error('reject测试')   //reject测试
  })
  .then(() => {}, err => {
    console.log(err)
  })

// 输出 
// 1 
// 2 
// 3 
// Error: reject测试
复制代码
```

到这里，我们已经实现了Promise的主要功能`(｀∀´)Ψ`剩下的几个方法都非常简单，我们顺手收拾掉：



## Promise.prototype.catch()

> `catch()方法`返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。

```js
//catch方法其实就是执行一下then的第二个回调
catch(rejectFn) {
  return this.then(undefined, rejectFn)
}
复制代码
```



## Promise.prototype.finally()

> `finally()方法`返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。在finally之后，还可以继续then。并且会将值原封不动的传递给后面的then

```js
//finally方法
finally(callback) {
  return this.then(
    value => MyPromise.resolve(callback()).then(() => value),             // MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise
    reason => MyPromise.resolve(callback()).then(() => { throw reason })  // reject同理
  )
}
复制代码
```

PS. 有同学问我`MyPromise.resolve(callback())`的意义，这里补充解释一下：这个写法其实涉及到一个`finally()`的使用细节，**finally()如果return了一个reject状态的Promise，将会改变当前Promise的状态**，这个`MyPromise.resolve`就用于改变Promise状态，在finally()没有返回reject态Promise或throw错误的情况下，去掉`MyPromise.resolve`也是一样的（欢迎大家向我提问，勘误的过程中也能很好地加深自己对Promise的理解，大家可以在各个交流群里直接@我）

> 参考资料：[对 Promise.prototype.finally() 的粗浅理解](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Ff0b94daf9bf7)



## Promise.resolve()

> `Promise.resolve(value)`方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有"then" 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。

```js
//静态的resolve方法
static resolve(value) {
  if(value instanceof MyPromise) return value // 根据规范, 如果参数是Promise实例, 直接return这个实例
  return new MyPromise(resolve => resolve(value))
}
复制代码
```



## Promise.reject()

> `Promise.reject()`方法返回一个带有拒绝原因的Promise对象。

```js
//静态的reject方法
static reject(reason) {
  return new MyPromise((resolve, reject) => reject(reason))
}
复制代码
```



## Promise.all()

> `Promise.all(iterable)`方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。

```js
//静态的all方法
static all(promiseArr) {
  let index = 0
  let result = []
  return new MyPromise((resolve, reject) => {
    promiseArr.forEach((p, i) => {
      //Promise.resolve(p)用于处理传入值不为Promise的情况
      MyPromise.resolve(p).then(
        val => {
          index++
          result[i] = val
          //所有then执行后, resolve结果
          if(index === promiseArr.length) {
            resolve(result)
          }
        },
        err => {
          //有一个Promise被reject时，MyPromise的状态变为reject
          reject(err)
        }
      )
    })
  })
}
复制代码
```



## Promise.race()

> `Promise.race(iterable)`方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。

```js
static race(promiseArr) {
  return new MyPromise((resolve, reject) => {
    //同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态
    for (let p of promiseArr) {
      MyPromise.resolve(p).then(  //Promise.resolve(p)用于处理传入值不为Promise的情况
        value => {
          resolve(value)        //注意这个resolve是上边new MyPromise的
        },
        err => {
          reject(err)
        }
      )
    }
  })
}
复制代码
```



## 完整代码

```js
//Promise/A+规定的三种状态
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class MyPromise {
  // 构造方法接收一个回调
  constructor(executor) {
    this._status = PENDING     // Promise状态
    this._value = undefined    // 储存then回调return的值
    this._resolveQueue = []    // 成功队列, resolve时触发
    this._rejectQueue = []     // 失败队列, reject时触发

    // 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue
    let _resolve = (val) => {
      //把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况
      const run = () => {
        if(this._status !== PENDING) return   // 对应规范中的"状态只能由pending到fulfilled或rejected"
        this._status = FULFILLED              // 变更状态
        this._value = val                     // 储存当前value

        // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 "then 方法可以被同一个 promise 调用多次"
        // 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调
        while(this._resolveQueue.length) {    
          const callback = this._resolveQueue.shift()
          callback(val)
        }
      }
      setTimeout(run)
    }
    // 实现同resolve
    let _reject = (val) => {
      const run = () => {
        if(this._status !== PENDING) return   // 对应规范中的"状态只能由pending到fulfilled或rejected"
        this._status = REJECTED               // 变更状态
        this._value = val                     // 储存当前value
        while(this._rejectQueue.length) {
          const callback = this._rejectQueue.shift()
          callback(val)
        }
      }
      setTimeout(run)
    }
    // new Promise()时立即执行executor,并传入resolve和reject
    executor(_resolve, _reject)
  }

  // then方法,接收一个成功的回调和一个失败的回调
  then(resolveFn, rejectFn) {
    // 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行
    typeof resolveFn !== 'function' ? resolveFn = value => value : null
    typeof rejectFn !== 'function' ? rejectFn = reason => {
      throw new Error(reason instanceof Error? reason.message:reason);
    } : null
  
    // return一个新的promise
    return new MyPromise((resolve, reject) => {
      // 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论
      const fulfilledFn = value => {
        try {
          // 执行第一个(当前的)Promise的成功回调,并获取返回值
          let x = resolveFn(value)
          // 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }
  
      // reject同理
      const rejectedFn  = error => {
        try {
          let x = rejectFn(error)
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }
  
      switch (this._status) {
        // 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行
        case PENDING:
          this._resolveQueue.push(fulfilledFn)
          this._rejectQueue.push(rejectedFn)
          break;
        // 当状态已经变为resolve/reject时,直接执行then回调
        case FULFILLED:
          fulfilledFn(this._value)    // this._value是上一个then回调return的值(见完整版代码)
          break;
        case REJECTED:
          rejectedFn(this._value)
          break;
      }
    })
  }

  //catch方法其实就是执行一下then的第二个回调
  catch(rejectFn) {
    return this.then(undefined, rejectFn)
  }

  //finally方法
  finally(callback) {
    return this.then(
      value => MyPromise.resolve(callback()).then(() => value),             //执行回调,并returnvalue传递给后面的then
      reason => MyPromise.resolve(callback()).then(() => { throw reason })  //reject同理
    )
  }

  //静态的resolve方法
  static resolve(value) {
    if(value instanceof MyPromise) return value //根据规范, 如果参数是Promise实例, 直接return这个实例
    return new MyPromise(resolve => resolve(value))
  }

  //静态的reject方法
  static reject(reason) {
    return new MyPromise((resolve, reject) => reject(reason))
  }

  //静态的all方法
  static all(promiseArr) {
    let index = 0
    let result = []
    return new MyPromise((resolve, reject) => {
      promiseArr.forEach((p, i) => {
        //Promise.resolve(p)用于处理传入值不为Promise的情况
        MyPromise.resolve(p).then(
          val => {
            index++
            result[i] = val
            if(index === promiseArr.length) {
              resolve(result)
            }
          },
          err => {
            reject(err)
          }
        )
      })
    })
  }

  //静态的race方法
  static race(promiseArr) {
    return new MyPromise((resolve, reject) => {
      //同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态
      for (let p of promiseArr) {
        MyPromise.resolve(p).then(  //Promise.resolve(p)用于处理传入值不为Promise的情况
          value => {
            resolve(value)        //注意这个resolve是上边new MyPromise的
          },
          err => {
            reject(err)
          }
        )
      }
    })
  }
}
复制代码
```

洋洋洒洒150多行的代码，到这里，我们终于可以给Promise的实现做一个结尾了。我们从一个最简单的Promise使用实例开始，通过对调用流程的分析，根据观察者模式实现了Promise的大致骨架，然后依据Promise/A+规范填充代码，重点实现了then 的链式调用，最后完成了Promise的静态/实例方法。其实Promise实现在整体上并没有太复杂的思想，但我们日常使用的时候往往忽略了很多Promise细节，因而很难写出一个符合规范的Promise实现，源码的实现过程，其实也是对Promise使用细节重新学习的过程。

# async/await实现

虽然前边花了这么多篇幅讲Promise的实现，不过探索`async/await`暂停执行的机制才是我们的初衷，下面我们就来进入这一块的内容。同样地，开头我们点一下async/await的使用意义。 在多个回调依赖的场景中，尽管Promise通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。

> 设想一个这样的场景，异步任务a->b->c之间存在依赖关系，如果我们通过then链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b不往下执行到c，那么也不是很方便控制

```js
Promise.resolve(a)
  .then(b => {
    // do something
  })
  .then(c => {
    // do something
  })
复制代码
```

> 但是如果通过async/await来实现这个场景，可读性和流程控制都会方便不少。

```js
async () => {
  const a = await Promise.resolve(a);
  const b = await Promise.resolve(b);
  const c = await Promise.resolve(c);
}
复制代码
```



那么我们要如何实现一个async/await呢，首先我们要知道，**async/await实际上是对Generator（生成器）的封装**，是一个语法糖。由于Generator出现不久就被async/await取代了，很多同学对Generator比较陌生，因此我们先来看看Generator的用法：

> ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。

```JS
function* myGenerator() {
  yield '1'
  yield '2'
  return '3'
}

const gen = myGenerator();  // 获取迭代器
gen.next()  //{value: "1", done: false}
gen.next()  //{value: "2", done: false}
gen.next()  //{value: "3", done: true}
复制代码
```

也可以通过给`next()`传参, 让yield具有返回值

```js
function* myGenerator() {
  console.log(yield '1')  //test1
  console.log(yield '2')  //test2
  console.log(yield '3')  //test3
}

// 获取迭代器
const gen = myGenerator();

gen.next()
gen.next('test1')
gen.next('test2')
gen.next('test3')
复制代码
```

我们看到Generator的用法，应该️会感到很熟悉，`*/yield`和`async/await`看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：

- `async/await`自带执行器，不需要手动调用next()就能自动执行下一步
- `async`函数返回值是Promise对象，而Generator返回的是生成器对象
- `await`能够返回Promise的resolve/reject的值

**我们对async/await的实现，其实也就是对应以上三点封装Generator**

## 1.自动执行

我们先来看一下，对于这样一个Generator，手动执行是怎样一个流程

```js
function* myGenerator() {
  yield Promise.resolve(1);
  yield Promise.resolve(2);
  yield Promise.resolve(3);
}

// 手动执行迭代器
const gen = myGenerator()
gen.next().value.then(val => {
  console.log(val)
  gen.next().value.then(val => {
    console.log(val)
    gen.next().value.then(val => {
      console.log(val)
    })
  })
})

//输出1 2 3
复制代码
```

我们也可以通过给`gen.next()`传值的方式，让yield能返回resolve的值

```js
function* myGenerator() {
  console.log(yield Promise.resolve(1))   //1
  console.log(yield Promise.resolve(2))   //2
  console.log(yield Promise.resolve(3))   //3
}

// 手动执行迭代器
const gen = myGenerator()
gen.next().value.then(val => {
  // console.log(val)
  gen.next(val).value.then(val => {
    // console.log(val)
    gen.next(val).value.then(val => {
      // console.log(val)
      gen.next(val)
    })
  })
})
复制代码
```

显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且yield能返回resolve的值，基于这两个需求，我们进行一个基本的封装，这里`async/await`是关键字，不能重写，我们用函数来模拟：

```js
function run(gen) {
  var g = gen()                     //由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环

  function _next(val) {             //封装一个方法, 递归执行g.next()
    var res = g.next(val)           //获取迭代器对象，并返回resolve的值
    if(res.done) return res.value   //递归终止条件
    res.value.then(val => {         //Promise的then方法是实现自动迭代的前提
      _next(val)                    //等待Promise完成就自动执行下一个next，并传入resolve的值
    })
  }
  _next()  //第一次执行
}
复制代码
```

对于我们之前的例子，我们就能这样执行：

```js
function* myGenerator() {
  console.log(yield Promise.resolve(1))   //1
  console.log(yield Promise.resolve(2))   //2
  console.log(yield Promise.resolve(3))   //3
}

run(myGenerator)
复制代码
```

这样我们就初步实现了一个`async/await`。上边的代码只有五六行，但并不是一下就能看明白的，我们之前用了四个例子来做铺垫，也是为了让读者更好地理解这段代码。 简单来说，我们封装了一个run方法，run方法里我们把执行下一步的操作封装成`_next()`，每次Promise.then()的时候都去执行`_next()`，实现自动迭代的效果。在迭代的过程中，我们还把resolve的值传入`gen.next()`，使得yield得以返回Promise的resolve的值

> 这里插一句，是不是只有`.then方法`这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield后边除了接Promise，还可以接`thunk函数`，thunk函数不是一个新东西，所谓thunk函数，就是**单参的只接受回调的函数**，详细介绍可以看[阮一峰Thunk 函数的含义和用法](https://link.juejin.cn?target=https%3A%2F%2Fp1-jj.byteimg.com%2Ftos-cn-i-t2oaga2asx%2Fgold-user-assets%2F2020%2F3%2F15%2F170dc5e88df6c208~tplv-t2oaga2asx-image.image)，无论是Promise还是thunk函数，其核心都是通过**传入回调**的方式来实现Generator的自动执行。thunk函数只作为一个拓展知识，理解有困难的同学也可以跳过这里，并不影响后续理解。

## 2.返回Promise & 异常处理

虽然我们实现了Generator的自动执行以及让yield返回resolve的值，但上边的代码还存在着几点问题：

1. **需要兼容基本类型**：这段代码能自动执行的前提是`yield`后面跟Promise，为了兼容后面跟着基本类型值的情况，我们需要把yield跟的内容(`gen().next.value`)都用`Promise.resolve()`转化一遍
2. **缺少错误处理**：上边代码里的Promise如果执行失败，就会导致后续执行直接中断，我们需要通过调用`Generator.prototype.throw()`，把错误抛出来，才能被外层的try-catch捕获到
3. **返回值是Promise**：`async/await`的返回值是一个Promise，我们这里也需要保持一致，给返回值包一个Promise

我们改造一下run方法：

```js
function run(gen) {
  //把返回值包装成promise
  return new Promise((resolve, reject) => {
    var g = gen()

    function _next(val) {
      //错误处理
      try {
        var res = g.next(val) 
      } catch(err) {
        return reject(err); 
      }
      if(res.done) {
        return resolve(res.value);
      }
      //res.value包装为promise，以兼容yield后面跟基本类型的情况
      Promise.resolve(res.value).then(
        val => {
          _next(val);
        }, 
        err => {
          //抛出错误
          g.throw(err)
        });
    }
    _next();
  });
}
复制代码
```

然后我们可以测试一下：

```js
function* myGenerator() {
  try {
    console.log(yield Promise.resolve(1)) 
    console.log(yield 2)   //2
    console.log(yield Promise.reject('error'))
  } catch (error) {
    console.log(error)
  }
}

const result = run(myGenerator)     //result是一个Promise
//输出 1 2 error
复制代码
```

到这里，一个`async/await`的实现基本完成了。最后我们可以看一下babel对async/await的转换结果，其实整体的思路是一样的，但是写法稍有不同：

```js
//相当于我们的run()
function _asyncToGenerator(fn) {
  // return一个function，和async保持一致。我们的run直接执行了Generator，其实是不太规范的
  return function() {
    var self = this
    var args = arguments
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);

      //相当于我们的_next()
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
      }
      //处理异常
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
      }
      _next(undefined);
    });
  };
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
复制代码
```

使用方式：

```js
const foo = _asyncToGenerator(function* () {
  try {
    console.log(yield Promise.resolve(1))   //1
    console.log(yield 2)                    //2
    return '3'
  } catch (error) {
    console.log(error)
  }
})

foo().then(res => {
  console.log(res)                          //3
})
复制代码
```

有关`async/await`的实现，到这里就告一段落了。但是直到结尾，我们也不知道await到底是如何暂停执行的，有关await暂停执行的秘密，我们还要到Generator的实现中去寻找答案

# Generator实现

我们从一个简单的Generator使用实例开始，一步步探究Generator的实现原理：

```js
function* foo() {
  yield 'result1'
  yield 'result2'
  yield 'result3'
}
  
const gen = foo()
console.log(gen.next().value)
console.log(gen.next().value)
console.log(gen.next().value)
复制代码
```

我们可以在[babel官网](https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Frepl%2F%23%3Fbrowsers%3D%26build%3D%26builtIns%3Dfalse%26spec%3Dfalse%26loose%3Dfalse%26code_lz%3DGYVwdgxgLglg9mAVAAmHOAKAlMg3gKGWQE8YBTAGwBNkByAJzIGcQKoBGWwk86uxlmwBMXIqUo0GzVlADMXAL7d8EBEyjIA5mTDIAvKnTYVauBTIA6CnE0ZtYC2DIAPKNgsA3AIYUQZLCZgTGaW1rb2ji5uWJ4-fgGqQSFWNnY6ka7u3r7-QA%26debug%3Dfalse%26forceAllTransforms%3Dfalse%26shippedProposals%3Dfalse%26circleciRepo%3D%26evaluate%3Dfalse%26fileSize%3Dfalse%26timeTravel%3Dfalse%26sourceType%3Dmodule%26lineWrap%3Dtrue%26presets%3Des2015%2Creact%2Cstage-2%26prettier%3Dfalse%26targets%3D%26version%3D7.5.5%26externalPlugins%3D)上在线转化这段代码，看看ES5环境下是如何实现Generator的：

```js
"use strict";

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(foo);

function foo() {
  return regeneratorRuntime.wrap(function foo$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return 'result1';

        case 2:
          _context.next = 4;
          return 'result2';

        case 4:
          _context.next = 6;
          return 'result3';

        case 6:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var gen = foo();
console.log(gen.next().value);
console.log(gen.next().value);
console.log(gen.next().value);
复制代码
```

代码咋一看不长，但如果仔细观察会发现有两个不认识的东西 —— `regeneratorRuntime.mark`和`regeneratorRuntime.wrap`，这两者其实是 regenerator-runtime 模块里的两个方法，regenerator-runtime 模块来自facebook的 regenerator 模块，完整代码在[runtime.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fregenerator%2Fblob%2Fmaster%2Fpackages%2Fregenerator-runtime%2Fruntime.js)，这个runtime有700多行...-_-||，因此我们不能全讲，不太重要的部分我们就简单地过一下，重点讲解暂停执行相关部分代码

> 个人觉得啃源码的效果不是很好，建议读者拉到末尾先看结论和简略版实现，源码作为一个补充理解

## regeneratorRuntime.mark()

`regeneratorRuntime.mark(foo)`这个方法在第一行被调用，我们先看一下runtime里mark()方法的定义

```js
//runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码
runtime.mark = function(genFun) {
  genFun.__proto__ = GeneratorFunctionPrototype;
  genFun.prototype = Object.create(Gp);
  return genFun;
};
复制代码
```

这里边`GeneratorFunctionPrototype`和`Gp`我们都不认识，他们被定义在runtime里，不过没关系，我们只要知道`mark()方法`为生成器函数（foo）绑定了一系列原型就可以了，这里就简单地过了

## regeneratorRuntime.wrap()

从上面babel转化的代码我们能看到，执行`foo()`，其实就是执行`wrap()`，那么这个方法起到什么作用呢，他想包装一个什么东西呢，我们先来看看wrap方法的定义：

```js
//runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码
function wrap(innerFn, outerFn, self) {
  var generator = Object.create(outerFn.prototype);
  var context = new Context([]);
  generator._invoke = makeInvokeMethod(innerFn, self, context);

  return generator;
}
复制代码
```

wrap方法先是创建了一个generator，并继承`outerFn.prototype`；然后new了一个`context对象`；`makeInvokeMethod方法`接收`innerFn(对应foo$)`、`context`和`this`，并把返回值挂到`generator._invoke`上；最后return了generator。**其实wrap()相当于是给generator增加了一个_invoke方法**

这段代码肯定让人产生很多疑问，outerFn.prototype是什么，Context又是什么，makeInvokeMethod又做了哪些操作。下面我们就来一一解答：

> `outerFn.prototype`其实就是`genFun.prototype`，

这个我们结合一下上面的代码就能知道

> `context`可以直接理解为这样一个全局对象，用于储存各种状态和上下文：

```js
var ContinueSentinel = {};

var context = {
  done: false,
  method: "next",
  next: 0,
  prev: 0,
  abrupt: function(type, arg) {
    var record = {};
    record.type = type;
    record.arg = arg;

    return this.complete(record);
  },
  complete: function(record, afterLoc) {
    if (record.type === "return") {
      this.rval = this.arg = record.arg;
      this.method = "return";
      this.next = "end";
    }

    return ContinueSentinel;
  },
  stop: function() {
    this.done = true;
    return this.rval;
  }
};
复制代码
```

> ```
> makeInvokeMethod`的定义如下，它return了一个`invoke方法`，invoke用于判断当前状态和执行下一步，其实就是我们调用的`next()
> ```

```js
//以下是编译后的代码
function makeInvokeMethod(innerFn, context) {
  // 将状态置为start
  var state = "start";

  return function invoke(method, arg) {
    // 已完成
    if (state === "completed") {
      return { value: undefined, done: true };
    }
    
    context.method = method;
    context.arg = arg;

    // 执行中
    while (true) {
      state = "executing";

      var record = {
        type: "normal",
        arg: innerFn.call(self, context)    // 执行下一步,并获取状态(其实就是switch里边return的值)
      };

      if (record.type === "normal") {
        // 判断是否已经执行完成
        state = context.done ? "completed" : "yield";

        // ContinueSentinel其实是一个空对象,record.arg === {}则跳过return进入下一个循环
        // 什么时候record.arg会为空对象呢, 答案是没有后续yield语句或已经return的时候,也就是switch返回了空值的情况(跟着上面的switch走一下就知道了)
        if (record.arg === ContinueSentinel) {
          continue;
        }
        // next()的返回值
        return {
          value: record.arg,
          done: context.done
        };
      }
    }
  };
}
复制代码
```

> 为什么`generator._invoke`实际上就是`gen.next`呢，因为在runtime对于next()的定义中，next()其实就return了_invoke方法

```js
// Helper for defining the .next, .throw, and .return methods of the
// Iterator interface in terms of a single ._invoke method.
function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
}

defineIteratorMethods(Gp);
复制代码
```

## 低配实现 & 调用流程分析

这么一遍源码下来，估计很多读者还是懵逼的，毕竟源码中纠集了很多概念和封装，一时半会不好完全理解，让我们跳出源码，实现一个简单的Generator，然后再回过头看源码，会得到更清晰的认识

```js
// 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case
function gen$(_context) {
  while (1) {
    switch (_context.prev = _context.next) {
      case 0:
        _context.next = 2;
        return 'result1';

      case 2:
        _context.next = 4;
        return 'result2';

      case 4:
        _context.next = 6;
        return 'result3';

      case 6:
      case "end":
        return _context.stop();
    }
  }
}

// 低配版context  
var context = {
  next:0,
  prev: 0,
  done: false,
  stop: function stop () {
    this.done = true
  }
}

// 低配版invoke
let gen = function() {
  return {
    next: function() {
      value = context.done ? undefined: gen$(context)
      done = context.done
      return {
        value,
        done
      }
    }
  }
} 

// 测试使用
var g = gen() 
g.next()  // {value: "result1", done: false}
g.next()  // {value: "result2", done: false}
g.next()  // {value: "result3", done: false}
g.next()  // {value: undefined, done: true}
复制代码
```

这段代码并不难理解，我们分析一下调用流程：

1. 我们定义的`function* `生成器函数被转化为以上代码
2. 转化后的代码分为三大块： 
   - `gen$(_context)`由yield分割生成器函数代码而来
   - `context对象`用于储存函数执行上下文
   - `invoke()方法`定义next()，用于执行gen$(_context)来跳到下一步
3. 当我们调用`g.next()`，就相当于调用`invoke()方法`，执行`gen$(_context)`，进入switch语句，switch根据context的标识，执行对应的case块，return对应结果
4. 当生成器函数运行到末尾（没有下一个yield或已经return），switch匹配不到对应代码块，就会return空值，这时`g.next()`返回`{value: undefined, done: true}`

从中我们可以看出，**Generator实现的核心在于`上下文的保存`，函数并没有真的被挂起，每一次yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个context对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样**

# 总结 & 致谢

有关Promise、async/await、Generator的原理就实现到这里了，感谢大家能够跟我一起走完全程，不知不觉，我们花了近9千字来讲述有关异步编程的故事，异步编程的世界环环相扣，一开始，笔者只是出于对await挂起机制的好奇，后来，从一个 "await是如何实现暂停执行" 的小问题，引出了对异步编程的一系列思考和实现原理。三者的实现，其实也是前端异步编程一步步演化推进的过程。

成文过程中得到很多大佬的帮助，这四篇参考文章都是我阅读了很多相关文章后精选的四篇，建议大家结合阅读，大佬们写的比我好很多，另外感谢冴羽大佬在Generator机制上给予的解惑~

## 何为Promise.all？

`Promise.all` 是 es6 `Promise` 对象上的一个方法，它的功能就是将多个`Promise`实例包装成一个`promise`实例。以下是 MDN 对 `Promise.all` 的描述：

> Promise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个[`Promise`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise)实例， 那个输入的所有 promise 的 resolve 回调的结果是一个数组。这个[`Promise`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise)的 resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束，或者输入的 iterable 里没有 promise 了的时候。它的 reject 回调执行是，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且reject的是第一个抛出的错误信息。

我戴上我的300度近视眼镜，仔细地提取出这段描述中的**关键字**：

1. `Promise.all` 的返回值是一个新的 `Promise` 实例。
2. `Promise.all` 接受一个可遍历的数据容器，容器中每个元素都应是 `Promise` 实例。咱就是说，假设这个容器就是数组。
3. 数组中每个 `Promise` 实例都成功时（由`pendding`状态转化为`fulfilled`状态），`Promise.all` 才成功。这些 `Promise` 实例所有的 `resolve` 结果会按照原来的顺序集合在一个数组中作为 `Promise.all` 的 `resolve` 的结果。
4. 数组中只要有一个 `Promise` 实例失败（由`pendding`状态转化为`rejected`状态），`Promise.all` 就失败。`Promise.all` 的 `.catch()` 会捕获到这个 `reject`。

### 原生 Promise.all 测试

咱先看看原生的`Promise.all`的是啥效果。

```js
const p1 = Promise.resolve('p1')

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p2 延时一秒')
  }, 1000)
})

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p3 延时两秒')
  }, 2000)
})

const p4 = Promise.reject('p4 rejected')

const p5 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('p5 rejected 延时1.5秒')
  }, 1500)
})

// 所有Promise实例都成功
Promise.all([p1, p2, p3])
  .then(res => {
    console.log(res)
  })
  .catch(err => console.log(err)) // 2秒后打印 [ 'p1', 'p2 延时一秒', 'p3 延时两秒' ]
  
// 一个Promise实例失败
Promise.all([p1, p2, p4])
  .then(res => {
    console.log(res)
  })
  .catch(err => console.log(err)) // p4 rejected
  
// 一个延时失败的Promise
 Promise.all([p1, p2, p5])
  .then(res => {
    console.log(res)
  })
  .catch(err => console.log(err)) // 1.5秒后打印 p5 rejected
  
// 两个Promise实例失败
Promise.all([p1, p4, p5])
  .then(res => {
    console.log(res)
  })
  .catch(err => console.log(err)) // p4 rejected


复制代码
```

**注意**

上面 `p4` 和 `p5` 在未传入 `Promise.all` 时需要注释掉，因为一个调用了 `reject` 的 `Promise` 实例如果没有使用 `.catch()` 方法去捕获错误会报错。但如果 `Promise` 实例定义了自己的 `.catch`，就不会触发 `Promise.all` 的 `.catch()` 方法。

OK，理论存在，实践开始！

## 手动实现Promise.all

1. `Promise.all` 接受一个数组，返回值是一个新的 `Promise` 实例

```js
Promise.MyAll = function (promises) {
  return new Promise((resolve, reject) => {

  })
}
复制代码
```

1. 数组中所有 `Promise` 实例都成功，`Promise.all` 才成功。不难想到，咱得需要一个数组来收集这些 `Promise` 实例的 `resolve` 结果。但有句俗话说得好：“不怕一万，就怕万一”，万一数组里面有元素不是 `Promise`咋办 —— 那就得用 `Promise.resolve()` 把它办了。这里还有一个问题，`Promise` 实例是不能直接调用 `resolve` 方法的，咱得在 `.then()` 中去收集结果。注意要保持结果的顺序。

```js
Promise.MyAll = function (promises) {
  let arr = []
  return new Promise((resolve, reject) => {
    promises.forEach((item, i) => {
      Promise.resolve(item).then(res => {
        arr[i] = res
      })
    }) 
  })
}
复制代码
```

1. 将收集到的结果（数组`arr`）作为参数传给外层的 `resolve` 方法。这里咱们肯定是有一个判断条件的，如何判断所有 `Promise` 实例都成功了呢？新手容易写出这句代码（没错就是我本人了😭）：

```js
if (arr.length === promises.length) resolve(arr)
复制代码
```

咱仔细想想 `Promise` 使用来干嘛的 —— 处理异步任务。对呀，异步任务很多都需要花时间呀，如果这些 `Promise` 中最后一个先完成呢？那 `arr` 数组不就只有最后一项了，前面的所有项都是 `empty`。所以这里咱们应该创建一个计数器，每有一个 `Promise` 实例成功，计数器加一：

```js
Promise.MyAll = function (promises) {
  let arr = [],
    count = 0
  return new Promise((resolve, reject) => {
    promises.forEach((item, i) => {
      Promise.resolve(item).then(res => {
        arr[i] = res
        count += 1
        if (count === promises.length) resolve(arr)
      })
    })
  })
}
复制代码
```

1. 最后就是处理失败的情况了，这里有两种写法，第一种是用 `.catch()` 方法捕获失败：

```js
Promise.MyAll = function (promises) {
  let arr = [],
    count = 0
  return new Promise((resolve, reject) => {
    promises.forEach((item, i) => {
      Promise.resolve(item).then(res => {
        arr[i] = res
        count += 1
        if (count === promises.length) resolve(arr)
      }).catch(reject)
    })
  })
}
复制代码
```

第二种写法就是给 `.then()` 方法传入第二个参数，这个函数是处理错误的回调函数：

```js
Promise.MyAll = function (promises) {
  let arr = [],
    count = 0
  return new Promise((resolve, reject) => {
    promises.forEach((item, i) => {
      Promise.resolve(item).then(res => {
        arr[i] = res
        count += 1
        if (count === promises.length) resolve(arr)
      }, reject)
    })
  })
}
复制代码
```

### 测试案例

致此 `Promise.all` 大功告成，赶紧拿来测试一下（摩拳擦掌）：

```js
const p1 = Promise.resolve('p1')
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p2 延时一秒')
  }, 1000)
})
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p3 延时两秒')
  }, 2000)
})

const p4 = Promise.reject('p4 rejected')

const p5 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('p5 rejected 延时1.5秒')
  }, 1500)
})

// 所有 Promsie 都成功
Promise.MyAll([p1, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // 2秒后打印 [ 'p1', 'p2 延时一秒', 'p3 延时两秒' ]
  
// 一个 Promise 失败
Promise.MyAll([p1, p2, p4])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p4 rejected
  
// 一个延时失败的 Promise
Promise.MyAll([p1, p2, p5])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // 1.5秒后打印 p5 rejected 延时1.5秒
 
// 两个失败的 Promise
Promise.MyAll([p1, p4, p5])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p4 rejected
复制代码
```

“OhOhOhOh~~~~”，与原生的 `Promise.all`运行结果不能说很像，只能说一模一样。老话说的好，趁热打铁——正在火候上。我打开某个学习网站（[MDN Web Docs (mozilla.org)](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2F)），了解到 `Promise` 对象用于同时处理多个 `Promise` 的方法还有 `Promise.race`、`Promise.any`、`Promise.allSettle`。从小老师就教会了咱们举一反三，仔细看了这三个方法的描述之后，我还真给反出来了😄。

## Promise.race

`Promise.race` 从字面意思理解就是赛跑，以状态变化最快的那个 `Promise` 实例为准，最快的 `Promise` 成功 `Promise.race` 就成功，最快的 `Promise` 失败 `Promise.race` 就失败。

咱来看看原生 `Promise.race` 效果

### 原生 Promise.race 测试

```js
const p1 = Promise.resolve('p1')
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p2 延时一秒')
  }, 1000)
})
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p3 延时两秒')
  }, 2000)
})

const p4 = Promise.reject('p4 rejected')

const p5 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('p5 rejected 延时1秒')
  }, 1500)
})

// p1无延时，p2延时1s，p3延时2s
Promise.race([p1, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p1

// p4无延时reject
Promise.race([p4, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p4 rejected
  
// p5 延时1.5秒reject，p2延时1s
Promise.race([p5, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // 1s后打印: p2 延时一秒
复制代码
```

理论存在，实践开始

### 手写Promise.race

整体流程与 `Promise` 差不多，只是对数组中的 `Promise` 实例处理的逻辑不一样，这里我们需要将最快改变状态的 `Promise` 结果作为 `Promise.race` 的结果，相对来说就比较简单了，代码如下：

```js
Promise.MyRace = function (promises) {
  return new Promise((resolve, reject) => {
    // 这里不需要使用索引，只要能循环出每一项就行
    for (const item of promises) {
      Promise.resolve(item).then(resolve, reject)
    }
  })
}
复制代码
```

### 测试案例

还是刚才几个案例，咱就不重复写了😁

```js
// p1无延时，p2延时1s，p3延时2s
Promise.MyRace([p1, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p1

// p4无延时reject
Promise.MyRace([p4, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p4 rejected
  
// p5 延时1.5秒reject，p2延时1s
Promise.MyRace([p5, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // 1s后打印: p2 延时一秒
复制代码
```

可以看到，结果与原生的 `Promise.race` 是一致的，成功！

## Promise.any

`Promise.any` 与 `Promise.all` 可以看做是相反的。`Promise.any` 中只要有一个 `Promise` 实例成功就成功，只有当所有的 `Promise` 实例失败时 `Promise.any` 才失败，此时`Promise.any` 会把所有的失败/错误集合在一起，返回一个失败的 `promise `和[`AggregateError`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FAggregateError)类型的实例。MDN 上说这个方法还处于试验阶段，如果 `node` 或者浏览器版本过低可能无法使用，各位看官自行测试下。

### 原生 Promise.any 测试

```js
const p1 = Promise.resolve('p1')
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p2 延时一秒')
  }, 1000)
})
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p3 延时两秒')
  }, 2000)
})

const p4 = Promise.reject('p4 rejected')

const p5 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('p5 rejected 延时1.5秒')
  }, 1500)
})

// 所有 Promise 都成功
Promise.any([p1, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p1
  
// 两个 Promise 成功
Promise.any([p1, p2, p4])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p1

// 只有一个延时成功的 Promise
Promise.any([p2, p4, p5])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p2 延时1秒

// 所有 Promise 都失败
Promise.any([p4, p5])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // AggregateError: All promises were rejected
复制代码
```

可以看出，如果 `Promise.any` 中有多个成功的 `Promise` 实例，则以最快成功的那个结果作为自身 `resolve` 的结果。

OK，理论存在，实践开始

### 手写Promise.any

1. 依葫芦画瓢，咱们先写出 `Promise.any` 的整体结构：

```js
Promise.MyAny = function (promises) {
  return new Promise((resolve, reject) => {
    promises.forEach((item, i) => {

    })
  })
}
复制代码
```

1. 这里跟`Promise.all` 的逻辑是反的，咱们需要收集 `reject` 的 `Promise`，也需要一个数组和计数器，用计数器判断是否所有的 `Promise` 实例都失败。另外在收集失败的 `Promise` 结果时咱需要打上一个失败的标记方便分析结果。

```js
Promise.MyAny = function (promises) {
  let arr = [],
    count = 0
  return new Promise((resolve, reject) => {
    promises.forEach((item, i) => {
      Promise.resolve(item).then(resolve, err => {
        arr[i] = { status: 'rejected', val: err }
        count += 1
        if (count === promises.length) reject(new Error('没有promise成功'))
      })
    })
  })
}
复制代码
```

这里我没有使用 MDN 上规定的 `AggregateError` 实例，手写嘛，随心所欲一点，写自己看着舒服的😄

### 测试案例

```js
// 所有 Promise 都成功
Promise.MyAny([p1, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p1
  
// 两个 Promise 成功
Promise.MyAny([p1, p2, p4])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p1

// 只有一个延时成功的 Promise
Promise.MyAny([p2, p4, p5])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // p2 延时1秒

// 所有 Promise 都失败
Promise.MyAny([p4, p5])
  .then(res => console.log(res))
  .catch(err => console.log(err)) // 没有promise成功
复制代码
```

## Promise.allSettled

有时候，咱代码人总是会有点特殊的需求：如果咱希望一组 `Promise` 实例无论成功与否，都等它们异步操作结束了在继续执行下一步操作，这可如何是好？于是就出现了 `Promise.allSettled`。

### 原生 `Promise.allSettled` 测试

```js
const p1 = Promise.resolve('p1')
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p2 延时一秒')
  }, 1000)
})
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p3 延时两秒')
  }, 2000)
})

const p4 = Promise.reject('p4 rejected')

const p5 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('p5 rejected 延时1.5秒')
  }, 1500)
})

// 所有 Promise 实例都成功
Promise.allSettled([p1, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) 
// [
//   { status: 'fulfilled', value: 'p1' },
//   { status: 'fulfilled', value: 'p2 延时一秒' },
//   { status: 'fulfilled', value: 'p3 延时两秒' }
// ]

// 有一个 Promise 失败
Promise.allSettled([p1, p2, p4])
  .then(res => console.log(res))
  .catch(err => console.log(err))
// [
//   { status: 'fulfilled', value: 'p1' },
//   { status: 'fulfilled', value: 'p2 延时一秒' },
//   { status: 'rejected' , value: 'p4 rejected' }
// ]

// 所有 Promise 都失败
Promise.allSettled([p4, p5])
  .then(res => console.log(res))
  .catch(err => console.log(err))
// [
//   { status: 'rejected', reason: 'p4 rejected' },
//   { status: 'rejected', reason: 'p5 rejected 延时1.5秒' }
// ]
复制代码
```

可以看到，与 `Promise.any` 类似，`Promise.allSettled` 也给所有收集到的结果打上了标记。而且 `Promise.allSettled` 是不会变成 `rejected` 状态的，不管一组 `Promise` 实例的各自结果如何，`Promise.allSettled` 都会转变为 `fulfilled` 状态。

OK，理论存在，实践开始

### 手写 Promise.allSettled

咱就是说，得用个数组把所有的 `Promise` 实例的结果（无论成功与否）都收集起来，判断收集完了（所有 `Promise` 实例状态都改变了），咱就将这个收集到的结果 `resolve` 掉。收集成功 `Promise` 结果的逻辑咱们在 `Promise.all` 中实现过，收集失败 `Promise` 结果咱们在 `Promise.any` 中处理过。这波，这波是依葫芦画瓢——照样。

```js
Promise.MyAllSettled = function (promises) {
  let arr = [],
    count = 0
  return new Promise((resolve, reject) => {
    promises.forEach((item, i) => {
      Promise.resolve(item).then(res => {
        arr[i] = { status: 'fulfilled', val: res }
        count += 1
        if (count === promises.length) resolve(arr)
      }, (err) => {
        arr[i] = { status: 'rejected', val: err }
        count += 1
        if (count === promises.length) resolve(arr)
      })
    })
  })
}
复制代码
```

这代码，逻辑上虽说没问题，但各位优秀的程序员们肯定是看不顺眼的，怎么会有两段重复的代码捏，不行，咱得封装一下。

```js
Promise.MyAllSettled = function (promises) {
  let arr = [],
    count = 0
  return new Promise((resolve, reject) => {
    const processResult = (res, index, status) => {
      arr[index] = { status: status, val: res }
      count += 1
      if (count === promises.length) resolve(arr)
    }

    promises.forEach((item, i) => {
      Promise.resolve(item).then(res => {
        processResult(res, i, 'fulfilled')
      }, err => {
        processResult(err, i, 'rejected')
      })
    })
  })
}
复制代码
```

perfect，俗话说得好：没病走两步。老样子，给代码跑几个案例。

### 测试案例

```js
// 所有 Promise 实例都成功
Promise.MyAllSettled([p1, p2, p3])
  .then(res => console.log(res))
  .catch(err => console.log(err)) 
// [
//   { status: 'fulfilled', value: 'p1' },
//   { status: 'fulfilled', value: 'p2 延时一秒' },
//   { status: 'fulfilled', value: 'p3 延时两秒' }
// ]

// 有一个 MyAllSettled 失败
Promise.allSettled([p1, p2, p4])
  .then(res => console.log(res))
  .catch(err => console.log(err))
// [
//   { status: 'fulfilled', value: 'p1' },
//   { status: 'fulfilled', value: 'p2 延时一秒' },
//   { status: 'rejected' , value: 'p4 rejected' }
// ]

// 所有 MyAllSettled 都失败
Promise.allSettled([p4, p5])
  .then(res => console.log(res))
  .catch(err => console.log(err))
// [
//   { status: 'rejected', reason: 'p4 rejected' },
//   { status: 'rejected', reason: 'p5 rejected 延时1.5秒' }
// ]
复制代码
```

致此，大功告成，我可以骄傲地对妈妈说：“妈妈，我再也不怕 Promise.all”了

## 结语

这次字节飞书面试对我来说是一个巨大的机遇，第一次体验面大厂的感觉，可能有暴躁老哥要说了：“字节面试题就这？你是水文章骗赞的吧”。害，没办法，主要是我太菜了，从代码不知为何物到现在前端学习者，尔来8月右一周矣，水平确实比较次，面试官比较和善，就没有为难我，问的问题都比较基础。但我仍然收获颇丰，感谢字节团队，感谢前端这个包容、进步的环境，我会好好总结这次面试，尽可能地提升自己，加油！

## 前言

大家好，我是林三心，相信大家在日常开发中都用过**Promise**，我一直有个梦想，就是**以最通俗的话，讲最复杂的知识**，所以我把**通俗易懂**放在了首位，今天就带大家手写实现以下**Promise吧**，相信大家一看就懂。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/032d1f70ba34471e81d047b3ff7e2eab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## resolve和reject

咱们来看一段Promise的代码：

```js
let p1 = new Promise((resolve, reject) => {
    resolve('成功')
    reject('失败')
})
console.log('p1', p1)

let p2 = new Promise((resolve, reject) => {
    reject('失败')
    resolve('成功')
})
console.log('p2', p2)

let p3 = new Promise((resolve, reject) => {
    throw('报错')
})
console.log('p3', p3)

复制代码
```

那么会输出什么呢？请看：

![截屏2021-08-01 上午11.53.33.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db87e7956fa24650bb60902bc3f113b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

这里暴露出了四个知识点：

- 1、执行了`resolve`，Promise状态会变成`fulfilled`
- 2、执行了`reject`，Promise状态会变成`rejected`
- 3、Promise只以`第一次为准`，第一次成功就`永久`为`fulfilled`，第一次失败就永远状态为`rejected`
- 4、Promise中有`throw`的话，就相当于执行了`reject` 那么咱们就把这四个知识点一步步实现吧！！！

### 1、实现resolve与reject

大家要注意：Promise的初始状态是`pending`

这里很重要的一步是`resolve和reject的绑定this`，为什么要绑定`this`呢？这是为了resolve和reject的`this指向`永远指向当前的`MyPromise实例`，防止随着函数执行环境的改变而改变

```js
class MyPromise {
    // 构造方法
    constructor(executor) {

        // 初始化值
        this.initValue()
        // 初始化this指向
        this.initBind()
        // 执行传进来的函数
        executor(this.resolve, this.reject)
    }

    initBind() {
        // 初始化this
        this.resolve = this.resolve.bind(this)
        this.reject = this.reject.bind(this)
    }

    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态
    }

    resolve(value) {
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
    }

    reject(reason) {
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
    }
}
复制代码
```

咱们来测试一下代码吧：

```js
const test1 = new MyPromise((resolve, reject) => {
    resolve('成功')
})
console.log(test1) // MyPromise { PromiseState: 'fulfilled', PromiseResult: '成功' }

const test2 = new MyPromise((resolve, reject) => {
    reject('失败')
})
console.log(test2) // MyPromise { PromiseState: 'rejected', PromiseResult: '失败' }
复制代码
```

### 2. 状态不可变

其实上面的代码是有问题的，什么问题呢？看看：

```js
const test1 = new MyPromise((resolve, reject) => {
    resolve('成功')
    reject('失败')
})
console.log(test1) // MyPromise { PromiseState: 'rejected', PromiseResult: '失败' }
复制代码
```

正确的应该是状态为`fulfilled`，结果是`成功`，这里明显没有`以第一次为准`

之前说了，Promise只以`第一次为准`，第一次成功就`永久`为`fulfilled`，第一次失败就永远状态为`rejected`，具体是什么流程呢？我给大家画了一张图：

Promise有三种状态：

- `pending`：等待中，是初始状态
- `fulfilled`：成功状态
- `rejected`：失败状态

一旦状态从`pending`变为`fulfilled或者rejected`，那么此Promise实例的状态就定死了。 ![截屏2021-08-01 下午12.33.10.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c9636d819ef4bc78af95fb80c9a7be4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

其实实现起来也很容易，加个判断条件就行：

```js
    resolve(value) {
        // state是不可变的
+        if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
    }

    reject(reason) {
        // state是不可变的
+        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
    }
复制代码
```

再来看看效果：

```js
const test1 = new MyPromise((resolve, reject) => {
    // 只以第一次为准
    resolve('成功')
    reject('失败')
})
console.log(test1) // MyPromise { PromiseState: 'fulfilled', PromiseResult: '成功' }
复制代码
```

### 3. throw

![截屏2021-08-01 下午12.57.17.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa2e17b24a124dadba540e86350f1302~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

Promise中有`throw`的话，就相当于执行了`reject`。这就要使用`try catch`了

```js
+        try {
            // 执行传进来的函数
            executor(this.resolve, this.reject)
+        } catch (e) {
            // 捕捉到错误直接执行reject
+            this.reject(e)
+        }
复制代码
```

咱们来看看效果：

```js
const test3 = new MyPromise((resolve, reject) => {
    throw('失败')
})
console.log(test3) // MyPromise { PromiseState: 'rejected', PromiseResult: '失败' }
复制代码
```

## then

咱们平时使用then方法是这么用的：

```js
// 马上输出 ”成功“
const p1 = new Promise((resolve, reject) => {
    resolve('成功')
}).then(res => console.log(res), err => console.log(err))

// 1秒后输出 ”失败“
const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('失败')
    }, 1000)
}).then(res => console.log(res), err => console.log(err))

// 链式调用 输出 200
const p3 = new Promise((resolve, reject) => {
    resolve(100)
}).then(res => 2 * res, err => console.log(err))
  .then(res => console.log(res), err => console.log(err))
复制代码
```

可以总结出这几个知识点：

- then接收两个回调，一个是`成功回调`，一个是`失败回调`
- 当Promise状态为`fulfilled`执行`成功回调`，为`rejected`执行`失败回调`
- 如resolve或reject在定时器里，`则定时器结束后再执行then`
- then支持`链式调用`，下一次then执行`受上一次then返回值的影响`

下面咱们就一步一步地去实现他吧

### 1. 实现then

```js
    then(onFulfilled, onRejected) {
        // 接收两个回调 onFulfilled, onRejected
        
        // 参数校验，确保一定是函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }

        if (this.PromiseState === 'fulfilled') {
            // 如果当前为成功状态，执行第一个回调
            onFulfilled(this.PromiseResult)
        } else if (this.PromiseState === 'rejected') {
            // 如果当前为失败状态，执行第二哥回调
            onRejected(this.PromiseResult)
        }

    }
复制代码
```

咱们来看看效果：

```js
// 输出 ”成功“
const test = new MyPromise((resolve, reject) => {
    resolve('成功')
}).then(res => console.log(res), err => console.log(err))
复制代码
```

### 2. 定时器情况

上面我们已经实现了`then`的基本功能。那如果是`定时器`情况呢？

还是那个代码，怎么才能保证，1秒后才执行then里的失败回调呢？

```js
// 1秒后输出 ”成功“
const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('失败')
    }, 1000)
}).then(res => console.log(res), err => console.log(err))
复制代码
```

我们不能确保1秒后才执行then函数，但是我们可以保证1秒后再执行then里的回调，可能这里大家有点懵逼，我同样用一张图给大家讲讲吧：

![截屏2021-08-01 下午9.05.24.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ba5a2544b1144548cdc63362fa27d23~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

也就是在这1秒时间内，我们可以先把then里的两个回调保存起来，然后等到1秒过后，执行了resolve或者reject，咱们再去判断状态，并且判断要去执行刚刚保存的两个回调中的哪一个回调。

那么问题来了，我们怎么知道当前1秒还没走完甚至还没开始走呢？其实很好判断，只要状态是`pending`，那就证明定时器还没跑完，因为如果定时器跑完的话，那状态肯定就不是`pending`，而是`fulfilled或者rejected`

那是用什么来保存这些回调呢？建议使用`数组`，因为一个promise实例可能会`多次then`，用数组就一个一个保存了

```js
    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态
+        this.onFulfilledCallbacks = [] // 保存成功回调
+        this.onRejectedCallbacks = [] // 保存失败回调
    }

    resolve(value) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
        // 执行保存的成功回调
+        while (this.onFulfilledCallbacks.length) {
+            this.onFulfilledCallbacks.shift()(this.PromiseResult)
+        }
    }

    reject(reason) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
        // 执行保存的失败回调
+        while (this.onRejectedCallbacks.length) {
+            this.onRejectedCallbacks.shift()(this.PromiseResult)
+        }
    }
    
    then(onFulfilled, onRejected) {
        // 接收两个回调 onFulfilled, onRejected

        // 参数校验，确保一定是函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }

        if (this.PromiseState === 'fulfilled') {
            // 如果当前为成功状态，执行第一个回调
            onFulfilled(this.PromiseResult)
        } else if (this.PromiseState === 'rejected') {
            // 如果当前为失败状态，执行第二哥回调
            onRejected(this.PromiseResult)
+        } else if (this.PromiseState === 'pending') {
+            // 如果状态为待定状态，暂时保存两个回调
+            this.onFulfilledCallbacks.push(onFulfilled.bind(this))
+            this.onRejectedCallbacks.push(onRejected.bind(this))
+        }

    }

复制代码
```

加完上面的代码，咱们来看看定时器的效果吧：

```js
const test2 = new MyPromise((resolve, reject) => {
    setTimeout(() => {
        resolve('成功') // 1秒后输出 成功
        // resolve('成功') // 1秒后输出 失败
    }, 1000)
}).then(res => console.log(res), err => console.log(err))
复制代码
```

### 3. 链式调用

then支持`链式调用`，下一次then执行`受上一次then返回值的影响`，给大家举个例子：

```js
// 链式调用 输出 200
const p3 = new Promise((resolve, reject) => {
    resolve(100)
}).then(res => 2 * res, err => console.log(err))
    .then(res => console.log(res), err => console.log(err))

// 链式调用 输出300
const p4 = new Promise((resolve, reject) => {
    resolve(100)
}).then(res => new Promise((resolve, reject) => resolve(3 * res)), err => console.log(err))
    .then(res => console.log(res), err => console.log(err))
复制代码
```

从上方例子，我们可以获取到几个知识点：

- 1、then方法本身会返回一个新的Promise对象
- 2、如果返回值是promise对象，返回值为成功，新promise就是成功
- 3、如果返回值是promise对象，返回值为失败，新promise就是失败
- 4、如果返回值非promise对象，新promise对象就是成功，值为此返回值

咱们知道then是Promise上的方法，那如何实现then完还能再then呢？很简单，then执行后返回一个`Promise对象`就行了，就能保证then完还能继续执行then：

![截屏2021-08-01 下午9.06.02.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62a3c3afcf0a4262a1a7e52231c34dbc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

代码实现：

```js
    then(onFulfilled, onRejected) {
        // 接收两个回调 onFulfilled, onRejected

        // 参数校验，确保一定是函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }


        var thenPromise = new MyPromise((resolve, reject) => {

            const resolvePromise = cb => {
                try {
                    const x = cb(this.PromiseResult)
                    if (x === thenPromise) {
                        // 不能返回自身哦
                        throw new Error('不能返回自身。。。')
                    }
                    if (x instanceof MyPromise) {
                        // 如果返回值是Promise
                        // 如果返回值是promise对象，返回值为成功，新promise就是成功
                        // 如果返回值是promise对象，返回值为失败，新promise就是失败
                        // 谁知道返回的promise是失败成功？只有then知道
                        x.then(resolve, reject)
                    } else {
                        // 非Promise就直接成功
                        resolve(x)
                    }
                } catch (err) {
                    // 处理报错
                    reject(err)
                    throw new Error(err)
                }
            }

            if (this.PromiseState === 'fulfilled') {
                // 如果当前为成功状态，执行第一个回调
                resolvePromise(onFulfilled)
            } else if (this.PromiseState === 'rejected') {
                // 如果当前为失败状态，执行第二个回调
                resolvePromise(onRejected)
            } else if (this.PromiseState === 'pending') {
                // 如果状态为待定状态，暂时保存两个回调
                // 如果状态为待定状态，暂时保存两个回调
                this.onFulfilledCallbacks.push(resolvePromise.bind(this, onFulfilled))
                this.onRejectedCallbacks.push(resolvePromise.bind(this, onRejected))
            }
        })

        // 返回这个包装的Promise
        return thenPromise

    }
复制代码
```

现在大家可以试试效果怎么样了，大家要**边敲边试**哦：

```js
const test3 = new Promise((resolve, reject) => {
  resolve(100) // 输出 状态：成功 值： 200
  // reject(100) // 输出 状态：成功 值：300
}).then(res => 2 * res, err => 3 * err)
  .then(res => console.log('成功', res), err => console.log('失败', err))


  const test4 = new Promise((resolve, reject) => {
    resolve(100) // 输出 状态：失败 值：200
    // reject(100) // 输出 状态：成功 值：300
    // 这里可没搞反哦。真的搞懂了，就知道了为啥这里是反的
  }).then(res => new Promise((resolve, reject) => reject(2 * res)), err => new Promise((resolve, reject) => resolve(3 * err)))
    .then(res => console.log('成功', res), err => console.log('失败', err))
复制代码
```

### 4. 微任务

看过`js执行机制`的兄弟都知道，then方法是`微任务`，啥叫微任务呢？其实不知道也不要紧，我通过下面例子让你知道：

```js
const p = new Promise((resolve, reject) => {
    resolve(1)
}).then(res => console.log(res), err => console.log(err))

console.log(2)

输出顺序是 2 1
复制代码
```

为啥不是 1 2 呢？因为then是个微任务啊。。。同样，我们也要给我们的MyPromise加上这个特性(我这里使用定时器，大家别介意哈)

只需要让`resolvePromise函数`异步执行就可以了

```js
 const resolvePromise = cb => {
    setTimeout(() => {
        try {
            const x = cb(this.PromiseResult)
            if (x === thenPromise) {
                // 不能返回自身哦
                throw new Error('不能返回自身。。。')
            }
            if (x instanceof MyPromise) {
                // 如果返回值是Promise
                // 如果返回值是promise对象，返回值为成功，新promise就是成功
                // 如果返回值是promise对象，返回值为失败，新promise就是失败
                // 谁知道返回的promise是失败成功？只有then知道
                x.then(resolve, reject)
            } else {
                // 非Promise就直接成功
                resolve(x)
            }
        } catch (err) {
            // 处理报错
            reject(err)
            throw new Error(err)
        }
    })
}
复制代码
```

看看效果：

```js
const test4 = new MyPromise((resolve, reject) => {
    resolve(1)
}).then(res => console.log(res), err => console.log(err))

console.log(2)

输出顺序 2 1

复制代码
```

## 其他方法

这些方法都比较简单，我就不太过详细地讲了，大家也可以借这个机会，自己摸索，巩固这篇文章的知识。

### all

- 接收一个Promise数组，数组中如有非Promise项，则此项当做成功
- 如果所有Promise都成功，则返回成功结果数组
- 如果有一个Promise失败，则返回这个失败结果

```js
    static all(promises) {
        const result = []
        let count = 0
        return new MyPromise((resolve, reject) => {
            const addData = (index, value) => {
                result[index] = value
                count++
                if (count === promises.length) resolve(result)
            }
            promises.forEach((promise, index) => {
                if (promise instanceof MyPromise) {
                    promise.then(res => {
                        addData(index, res)
                    }, err => reject(err))
                } else {
                    addData(index, promise)
                }
            })
        })
    }
复制代码
```

### race

- 接收一个Promise数组，数组中如有非Promise项，则此项当做成功
- 哪个Promise最快得到结果，就返回那个结果，无论成功失败

```js
    static race(promises) {
        return new MyPromise((resolve, reject) => {
            promises.forEach(promise => {
                if (promise instanceof MyPromise) {
                    promise.then(res => {
                        resolve(res)
                    }, err => {
                        reject(err)
                    })
                } else {
                    resolve(promise)
                }
            })
        })
    }
复制代码
```

### allSettled

- 接收一个Promise数组，数组中如有非Promise项，则此项当做成功
- 把每一个Promise的结果，集合成数组，返回

```js
    static allSettled(promises) {
        return new Promise((resolve, reject) => {
            const res = []
            let count = 0
            const addData = (status, value, i) => {
                res[i] = {
                    status,
                    value
                }
                count++
                if (count === promises.length) {
                    resolve(res)
                }
            }
            promises.forEach((promise, i) => {
                if (promise instanceof MyPromise) {
                    promise.then(res => {
                        addData('fulfilled', res, i)
                    }, err => {
                        addData('rejected', err, i)
                    })
                } else {
                    addData('fulfilled', promise, i)
                }
            })
        })
    }
复制代码
```

### any

any与all相反

- 接收一个Promise数组，数组中如有非Promise项，则此项当做成功
- 如果有一个Promise成功，则返回这个成功结果
- 如果所有Promise都失败，则报错

```js
    static any(promises) {
        return new Promise((resolve, reject) => {
            let count = 0
            promises.forEach((promise) => {
                promise.then(val => {
                    resolve(val)
                }, err => {
                    count++
                    if (count === promises.length) {
                        reject(new AggregateError('All promises were rejected'))
                    }
                })
            })
        })
    }
}
复制代码
```

### 结语

再也不怕面试官问你Promise原理啦哈哈哈哈😁

如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。

### 从一道题目出发

今天看到一道面试题，是关于`async/await`、`promise`和`setTimeout`的执行顺序，题目如下：

```javascript
async function async1() {
	console.log('async1 start');
	await async2();
	console.log('asnyc1 end');
}
async function async2() {
	console.log('async2');
}
console.log('script start');
setTimeout(() => {
	console.log('setTimeOut');
}, 0);
async1();
new Promise(function (reslove) {
	console.log('promise1');
	reslove();
}).then(function () {
	console.log('promise2');
})
console.log('script end');
复制代码
```

我给出的答案：

```sql
script start
async1 start
async2
asnyc1 end // x
promise1
script end
promise2
setTimeOut
复制代码
```

正确的答案：

```sql
script start
async1 start
async2
promise1
script end
asnyc1 end
promise2
setTimeOut
复制代码
```

为什么`promise1`比`asnyc1 end`先出来呢？带着这个疑问，我去了解了一下**事件循环机制**。

### js EventLoop 事件循环机制

JavaScript的事件分两种:

| 宏任务(macro-task)         | 微任务(micro-task)                              |
| -------------------------- | ----------------------------------------------- |
| script                     | promise.[ then/catch/finally ]((非new Promise)) |
| setTimeout                 | process.nextTick(Node.js 环境)                  |
| setInterval                | MutaionOberver（浏览器环境）                    |
| setImmediate(Node.js 环境) | Object.observe                                  |
| IO操作                     | x                                               |
| UI交互事件                 | x                                               |
| postMessage                | x                                               |
| MessageChannel             | x                                               |

事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。

> **注意：** `setTimeOut`并不是直接的把你的回掉函数放进上述的异步队列中去，而是在定时器的时间到了之后，把回掉函数放到执行异步队列中去。如果此时这个队列已经有很多任务了，那就排在他们的后面。这也就解释了为什么`setTimeOut`为什么不能精准的执行的问题了。`setTimeOut`执行需要满足两个条件：
>
> 1. 主进程必须是空闲的状态，如果到时间了，主进程不空闲也不会执行你的回调函数
> 2. 这个回调函数需要等到插入异步队列时前面的异步函数都执行完了，才会执行

### **promise、async/await**

首先，`new Promise`是同步的任务，会被放到主进程中去立即执行。而`.then()`函数是异步任务会放到异步队列中去，那什么时候放到异步队列中去呢？当你的`promise`状态结束的时候，就会立即放进异步队列中去了。

**带`async`关键字的函数会返回一个`promise`对象**，如果里面没有`await`，执行起来等同于普通函数；如果没有`await`，`async`函数并没有很厉害是不是。

`await` 关键字要在 `async` 关键字函数的内部，`await` 写在外面会报错；`await`如同他的语意，就是在等待，等待右侧的表达式完成。此时的`await`会让出线程，阻塞`async`内后续的代码，先去执行`async`外的代码。等外面的同步代码执行完毕，才会执行里面的后续代码。就算`await`的不是`promise`对象，是一个同步函数，也会等这样操作。

### 流程梳理

我们整体再梳理一下上面代码执行的流程：

> 1. 整个代码片段（script）作为一个宏任务执行`console.log('script start')`，输出`script start`；
> 2. 执行`setTimeout`，是一个异步动作，放入宏任务异步队列中；
> 3. 执行`async1()`，输出`async1 start`，继续向下执行；
> 4. 执行`async2()`，输出`async2`，并返回了一个`promise`对象，`await`让出了线程，把返回的`promise`加入了微任务异步队列，所以`async1()`下面的代码也要等待上面完成后继续执行;
> 5. 执行 `new Promise`，输出`promise1`，然后将`resolve()`放入微任务异步队列；
> 6. 执行`console.log('script end')`，输出`script end`；
> 7. 到此同步的代码就都执行完成了，然后去微任务异步队列里去获取任务
> 8. 接下来执行`resolve`（`async2`返回的`promise`返回的），输出了`async1 end`；
> 9. 然后执行`resolve（new Promise的）`，输出了`promise2`；
> 10. 最后执行`setTimeout`，输出了`settimeout`。

在第`4`步中， `await` 这里有一个机制， 就是 `await` 的等待， 不会阻塞外部函数的执行， 而 `await` 等待的 如果是一个 `Promise` 则 `Promise` 里面的代码还是同步执行， 如果不是 `Promise` ，就会使用 `Promise.resolve` 来进行封装， 这里的 `async2` 是一个 `async` 方法， 里面的 打印会同步执行， 而 `await async2()` 后面的代码 会放到微任务队列中的第一个位置，等待外部同步代码执行完毕以后再执行。

所以我知道了`script end`为什么会优先于`async1 end`输出。

## 一、什么是Promise？我们用Promise来解决什么问题？

> Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。

我相信大家经常写这样的代码：







```stylus
// 当参数a大于10且参数fn2是一个方法时 执行fn2
function fn1(a, fn2) {
    if (a > 10 && typeof fn2 == 'function') {
        fn2()
    }
}
fn1(11, function() {
    console.log('this is a callback')
})复制代码
```



一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。

这时候我们的promise就应运而生、粉墨登场了

promise是用来解决两个问题的：

- 回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象
- promise可以支持多个并发的请求，获取并发请求中的数据
- 这个promise可以解决异步的问题，本身不能说promise是异步的



## 二、es6 promise用法大全

Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。

那就new一个







```coffeescript
let p = new Promise((resolve, reject) => {
    //做一些异步操作
    setTimeout(() => {
        console.log('执行完成');
        resolve('我是成功！！');
    }, 2000);
});复制代码
```



Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：

- resolve ：异步操作执行成功后的回调函数
- reject：异步操作执行失败后的回调函数

### then 链式操作的用法 

所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：







```arcade
p.then((data) => {
    console.log(data);
})
.then((data) => {
    console.log(data);
})
.then((data) => {
    console.log(data);
});复制代码
```





### reject的用法 :

把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。

```javascript
    let p = new Promise((resolve, reject) => {
        //做一些异步操作
      setTimeout(function(){
            var num = Math.ceil(Math.random()*10); //生成1-10的随机数
            if(num<=5){
                resolve(num);
            }
            else{
                reject('数字太大了');
            }
      }, 2000);
    });
    p.then((data) => {
            console.log('resolved',data);
        },(err) => {
            console.log('rejected',err);
        }
    ); 复制代码
```

then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e1df3ec16ee~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)或者![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

### catch的用法

我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：







```arcade
p.then((data) => {
    console.log('resolved',data);
}).catch((err) => {
    console.log('rejected',err);
});复制代码
```



效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：







```arcade
p.then((data) => {
    console.log('resolved',data);
    console.log(somedata); //此处的somedata未定义
})
.catch((err) => {
    console.log('rejected',err);
});复制代码
```



在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/1637880bdb32bee3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

 

也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能

### all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象

Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。看下面的例子：

```javascript
let Promise1 = new Promise(function(resolve, reject){})
let Promise2 = new Promise(function(resolve, reject){})
let Promise3 = new Promise(function(resolve, reject){})

let p = Promise.all([Promise1, Promise2, Promise3])

p.then(funciton(){
  // 三个都成功则成功  
}, function(){
  // 只要有失败，则失败 
})复制代码
```

 

有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？*有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。*

### race的用法：谁跑的快，以谁为准执行回调

 

race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：

```javascript
 //请求某个图片资源
    function requestImg(){
        var p = new Promise((resolve, reject) => {
            var img = new Image();
            img.onload = function(){
                resolve(img);
            }
            img.src = '图片的路径';
        });
        return p;
    }
    //延时函数，用于给请求计时
    function timeout(){
        var p = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject('图片请求超时');
            }, 5000);
        });
        return p;
    }
    Promise.race([requestImg(), timeout()]).then((data) =>{
        console.log(data);
    }).catch((err) => {
        console.log(err);
    });复制代码
```

requestImg函数会异步请求一张图片，我把地址写为"图片的路径"，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16376a95ffa3b13c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

好了，我相信大家对用法已经懂了，那么我们来手写一款自己的promise吧

## 三、根据promiseA+实现一个自己的promise

## 

### 

### 步骤一：实现成功和失败的回调方法

要实现上面代码中的功能，也是promise最基本的功能。首先，需要创建一个构造函数promise，创建一个promisel类，在使用的时候传入了一个执行器executor，executor会传入两个参数：成功(resolve)和失败(reject)。之前说过，只要成功，就不会失败，只要失败就不会成功。所以，默认状态下，在调用成功时，就返回成功态，调用失败时，返回失败态。代码如下：







```kotlin
class Promise {
    constructor (executor){
        //默认状态是等待状态
        this.status = 'panding';
        this.value = undefined;
        this.reason = undefined;
        //存放成功的回调
        this.onResolvedCallbacks = [];
        //存放失败的回调
        this.onRejectedCallbacks = [];
        let resolve = (data) => {//this指的是实例
            if(this.status === 'pending'){
                this.value = data;
                this.status = "resolved";
                this.onResolvedCallbacks.forEach(fn => fn());
            }
 
        }
        let reject = (reason) => {
            if(this.status === 'pending'){
                this.reason = reason;
                this.status = 'rejected';
                this.onRejectedCallbacks.forEach(fn => fn());
            }
        }
        try{//执行时可能会发生异常
            executor(resolve,reject);
        }catch (e){
            reject(e);//promise失败了
        }
       
    }复制代码
```



> promise A+规范规定，在有异常错误时，则执行失败函数。







```delphi
constructor (executor){
    ......      try{
        executor(resolve,reject);
      }catch(e){
        reject(e);
      }
  }复制代码
```



### 步骤二：then方法链式调用 

then方法是promise的最基本的方法，返回的是两个回调，一个成功的回调，一个失败的回调，实现过程如下：







```kotlin
    then(onFulFilled, onRejected) {
    if (this.status === 'resolved') { //成功状态的回调
      onFulFilled(this.value);
    }
    if (this.status === 'rejected') {//失败状态的回调
      onRejected(this.reason);
    }
  }复制代码
```







```coffeescript
let p = new Promise(function(){
    resolve('我是成功');
})
p.then((data) => {console.log(data);},(err) => {});
p.then((data) => {console.log(data);},(err) => {});
p.then((data) => {console.log(data);},(err) => {});复制代码
```



返回的结果是：







```
我是成功
我是成功
我是成功复制代码
```



为了实现这样的效果，则上一次的代码将要重新写过，我们可以把每次调用resolve的结果存入一个数组中，每次调用reject的结果存入一个数组。这就是**为何会在上面定义两个数组,且分别在resolve()和reject()遍历两个数组的原因**。因此，在调用resolve()或者reject()之前，我们在pending状态时，会把多次then中的结果存入数组中，则上面的代码会改变为：







```kotlin
  then(onFulFilled, onRejected) {
    if (this.status === 'resolved') {
      onFulFilled(this.value);
    }
    if (this.status === 'rejected') {
      onRejected(this.reason);
    }
    // 当前既没有完成 也没有失败
    if (this.status === 'pending') {
      // 存放成功的回调
      this.onResolvedCallbacks.push(() => {
        onFulFilled(this.value);
      });
      // 存放失败的回调
      this.onRejectedCallbacks.push(() => {
        onRejected(this.reason);
      });
    }
  }复制代码
```



> Promise A+规范中规定then方法可以链式调用

在promise中，要实现链式调用返回的结果是返回一个新的promise，第一次then中返回的结果，无论是成功或失败，都将返回到下一次then中的成功态中，但在第一次then中如果抛出异常错误，则将返回到下一次then中的失败态中

**链式调用成功时**



链式调用成功会返回值，有多种情况，根据举的例子，大致列出可能会发生的结果。因此将链式调用返回的值单独写一个方法。方法中传入四个参数，分别是p2,x,resolve,reject,p2指的是上一次返回的promise，x表示运行promise返回的结果，resolve和reject是p2的方法。则代码写为：







```reasonml
function resolvePromise(p2,x,resolve,reject){
    ....
}复制代码
```



- 返回结果不能是自己







```javascript
var p = new Promise((resovle,reject) => {
    return p;     //返回的结果不能是自己，
})复制代码
```



当返回结果是自己时，永远也不会成功或失败，因此当返回自己时，应抛出一个错误







```reasonml
function resolvePromise(p2,x,resolve,reject){
    if(px===x){
        return reject(new TypeError('自己引用自己了'));
    }
    ....
}复制代码
```



- 返回结果可能是promise







```javascript
function resolvePromise(promise2,x,resolve,reject){
    //判断x是不是promise
    //规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise 进行交互
    if(promise2 === x){//不能自己等待自己完成
        return reject(new TypeError('循环引用'));
    };
    // x是除了null以外的对象或者函数
    if(x !=null && (typeof x === 'object' || typeof x === 'function')){
        let called;//防止成功后调用失败
        try{//防止取then是出现异常  object.defineProperty
            let then = x.then;//取x的then方法 {then:{}}
            if(typeof then === 'function'){//如果then是函数就认为他是promise
                //call第一个参数是this，后面的是成功的回调和失败的回调
                then.call(x,y => {//如果Y是promise就继续递归promise
                    if(called) return;
                    called = true;
                    resolvePromise(promise2,y,resolve,reject)
                },r => { //只要失败了就失败了
                    if(called) return;
                    called = true;
                    reject(r);  
                });
            }else{//then是一个普通对象，就直接成功即可
                resolve(x);
            }
        }catch (e){
            if(called) return;
            called = true;
            reject(e)
        }
    }else{//x = 123 x就是一个普通值 作为下个then成功的参数
        resolve(x)
    }

}复制代码
```



- 返回结果可能为一个普通值，则直接  resolve(x);

- Promise一次只能调用成功或者失败

也就是当调用成功就不能再调用失败了，如果两个都调用的时候，哪个先调用就执行哪一个。代码部分还是上面那部分

个人认为，这个地方比较绕，需要慢慢的一步一步的理清楚。

根据promise A+规范原理，promise在自己的框架中，封装了一系列的内置的方法。

- 捕获错误的方法 **catch()**
- 解析全部方法 **all()**
- 竞赛 **race()**
- 生成一个成功的promise **resolve()**
- 生成一个失败的promise **reject()**

最后给大家附上全部源码，供大家仔细品读。









```javascript
function resolvePromise(promise2,x,resolve,reject){
    //判断x是不是promise
    //规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise 进行交互
    if(promise2 === x){//不能自己等待自己完成
        return reject(new TypeError('循环引用'));
    };
    // x是除了null以外的对象或者函数
    if(x !=null && (typeof x === 'object' || typeof x === 'function')){
        let called;//防止成功后调用失败
        try{//防止取then是出现异常  object.defineProperty
            let then = x.then;//取x的then方法 {then:{}}
            if(typeof then === 'function'){//如果then是函数就认为他是promise
                //call第一个参数是this，后面的是成功的回调和失败的回调
                then.call(x,y => {//如果Y是promise就继续递归promise
                    if(called) return;
                    called = true;
                    resolvePromise(promise2,y,resolve,reject)
                },r => { //只要失败了就失败了
                    if(called) return;
                    called = true;
                    reject(r);  
                });
            }else{//then是一个普通对象，就直接成功即可
                resolve(x);
            }
        }catch (e){
            if(called) return;
            called = true;
            reject(e)
        }
    }else{//x = 123 x就是一个普通值 作为下个then成功的参数
        resolve(x)
    }

}

class Promise {
    constructor (executor){
        //默认状态是等待状态
        this.status = 'panding';
        this.value = undefined;
        this.reason = undefined;
        //存放成功的回调
        this.onResolvedCallbacks = [];
        //存放失败的回调
        this.onRejectedCallbacks = [];
        let resolve = (data) => {//this指的是实例
            if(this.status === 'pending'){
                this.value = data;
                this.status = "resolved";
                this.onResolvedCallbacks.forEach(fn => fn());
            }
 
        }
        let reject = (reason) => {
            if(this.status === 'pending'){
                this.reason = reason;
                this.status = 'rejected';
                this.onRejectedCallbacks.forEach(fn => fn());
            }
        }
        try{//执行时可能会发生异常
            executor(resolve,reject);
        }catch (e){
            reject(e);//promise失败了
        }
       
    }
    then(onFuiFilled,onRejected){ 
        //防止值得穿透 
        onFuiFilled = typeof onFuiFilled === 'function' ? onFuiFilled : y => y;
        onRejected = typeof onRejected === 'function' ? onRejected :err => {throw err;}        
        let promise2;//作为下一次then方法的promise
       if(this.status === 'resolved'){
           promise2 = new Promise((resolve,reject) => {
               setTimeout(() => {
                  try{
                        //成功的逻辑 失败的逻辑
                        let x = onFuiFilled(this.value);
                        //看x是不是promise 如果是promise取他的结果 作为promise2成功的的结果
                        //如果返回一个普通值，作为promise2成功的结果
                        //resolvePromise可以解析x和promise2之间的关系
                        //在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。
                        resolvePromise(promise2,x,resolve,reject)
                  }catch(e){
                        reject(e);
                  } 
               },0)
           }); 
       } 
       if(this.status === 'rejected'){
            promise2 = new Promise((resolve,reject) => {
                setTimeout(() => {
                    try{
                        let x = onRejected(this.reason);
                        //在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。
                        resolvePromise(promise2,x,resolve,reject)
                    }catch(e){
                        reject(e);
                    }
                },0)

            });
       }
       //当前既没有完成也没有失败
       if(this.status === 'pending'){
           promise2 = new Promise((resolve,reject) => {
               //把成功的函数一个个存放到成功回调函数数组中
                this.onResolvedCallbacks.push( () =>{
                    setTimeout(() => {
                        try{
                            let x = onFuiFilled(this.value);
                            resolvePromise(promise2,x,resolve,reject);
                        }catch(e){
                            reject(e);
                        }
                    },0)
                });
                //把失败的函数一个个存放到失败回调函数数组中
                this.onRejectedCallbacks.push( ()=>{
                    setTimeout(() => {
                        try{
                            let x = onRejected(this.reason);
                            resolvePromise(promise2,x,resolve,reject)
                        }catch(e){
                            reject(e)
                        }
                    },0)
                })
           })
       }
       return promise2;//调用then后返回一个新的promise
    }
    catch (onRejected) {
        // catch 方法就是then方法没有成功的简写
        return this.then(null, onRejected);
    }
}
Promise.all = function (promises) {
    //promises是一个promise的数组
    return new Promise(function (resolve, reject) {
        let arr = []; //arr是最终返回值的结果
        let i = 0; // 表示成功了多少次
        function processData(index, data) {
            arr[index] = data;
            if (++i === promises.length) {
                resolve(arr);
            }
        }
        for (let i = 0; i < promises.length; i++) {
            promises[i].then(function (data) {
                processData(i, data)
            }, reject)
        }
    })
}
// 只要有一个promise成功了 就算成功。如果第一个失败了就失败了
Promise.race = function (promises) {
    return new Promise((resolve, reject) => {
        for (var i = 0; i < promises.length; i++) {
            promises[i].then(resolve,reject)
        }
    })
}
// 生成一个成功的promise
Promise.resolve = function(value){
    return new Promise((resolve,reject) => resolve(value);
}
// 生成一个失败的promise
Promise.reject = function(reason){
    return new Promise((resolve,reject) => reject(reason));
}
Promise.defer = Promise.deferred = function () {
    let dfd = {};
    dfd.promise = new Promise( (resolve, reject) =>  {
        dfd.resolve = resolve;
        dfd.reject = reject;
    });
    return dfd
}
module.exports = Promise;复制代码
```



关于这篇promise A+规范的总结，肯定会存在很多不足的地方，欢迎各位提出宝贵的意见或建议，也希望能帮助到你从中获得一些知识！

# Promise 中的三兄弟 .all(), .race(), .allSettled()

[![img](https://p3-passport.byteimg.com/img/user-avatar/2a91a15bf1fd08b29971dcf08a22d627~100x100.awebp)](https://juejin.cn/user/2330620350435501)

[王大冶![lv-8](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fdb11f5b5ff4d9aaf7982197d7e4082~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp)![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/07302452a7ad81cb43a173b5cd580237.svg)](https://juejin.cn/user/2330620350435501)

2019年08月14日 08:08 · 阅读 29855

> 作者：Dr. Axel Rauschmayer 译者：前端小智 来源:2ality

> **点赞再看**，微信搜索 **【大迁世界】** 关注这个没有大厂背景，但有着一股向上积极心态人。本文 `GitHub` [github.com/qq449245884…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fqq449245884%2Fxiaozhi) 上已经收录，文章的已分类，也整理了很多我的文档，和教程资料。

**大家都说简历没项目写，我就帮大家找了一个项目，还附赠[【搭建教程】](https://link.juejin.cn/?target=http%3A%2F%2Fwww.longstudy.club%2Ftuiguan%2Ft1%2Findex.html)。**

从ES6 开始，我们大都使用的是 `Promise.all()`和`Promise.race()`，`Promise.allSettled()` 提案已经到第4阶段，因此将会成为`ECMAScript 2020`的一部分。

## 1.概述

**Promise.all(promises: Iterable): Promise**

- `Promise.all(iterable)` 方法返回一个 `Promise` 实例，此实例在 `iterable` 参数内所有的 `promise` 都“完成（resolved）”或参数中不包含 `promise` 时回调完成（resolve）；如果参数中 `promise` 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 `promise` 的结果

**Promise.race(promises: Iterable): Promise**

- **Promise.race(iterable)** 方法返回一个 `promise`，一旦迭代器中的某个`promise`解决或拒绝，返回的 `promise`就会解决或拒绝。

**Promise.allSettled(promises: Iterable): Promise>**

- **Promise.allSettled()**方法返回一个`promise`，该`promise`在所有给定的`promise`已被解析或被拒绝后解析，并且每个对象都描述每个`promise`的结果。

## 回顾: Promise 状态

给定一个返回`Promise`的异步操作，以下这些是`Promise`的可能状态：

- pending: 初始状态，既不是成功，也不是失败状态。
- fulfilled: 意味着操作成功完成。
- rejected: 意味着操作失败。
- Settled： `Promise`要么被完成，要么被拒绝。`Promise`一旦达成，它的状态就不再改变。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0397a284cf043cbb87883da03832ec1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 3.什么是组合

又称部分-整体模式，将对象整合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性，它基于两种函数：

- 基元函数(简短:基元)创建原子块。
- 组合函数（简称：组合）将原子和/或复合件组合在一起以形成复合件。

对于 JS 的 Promises 来说

- 基元函数包括:`Promise.resolve()`、`Promise.reject()`
- 组合函数：`Promise.all()`, `Promise.race()`, `Promise.allSettled()`

## 4. Promise.all()

`Promise.all()`的类型签名:

- **Promise.all(promises: Iterable): Promise**

返回情况：

**完成（Fulfillment）：** 如果传入的可迭代对象为空，`Promise.all` 会同步地返回一个已完成（`resolved`）状态的`promise`。 如果所有传入的 `promise` 都变为完成状态，或者传入的可迭代对象内没有 `promise`，`Promise.all` 返回的 `promise` 异步地变为完成。 在任何情况下，`Promise.all` 返回的 `promise` 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 promise 值）。

**失败/拒绝（Rejection）：** 如果传入的 `promise` 中有一个失败（`rejected`），`Promise.all` 异步地将失败的那个结果给失败状态的回调函数，而不管其它 `promise` 是否完成。

来个例子：

```javascript
const promises = [
  Promise.resolve('a'),
  Promise.resolve('b'),
  Promise.resolve('c'),
];
Promise.all(promises)
  .then((arr) => assert.deepEqual(
    arr, ['a', 'b', 'c']
  ));
复制代码
```

如果其中的一个 promise 被拒绝，那么又是什么情况：

```javascript
const promises = [
  Promise.resolve('a'),
  Promise.resolve('b'),
  Promise.reject('ERROR'),
];
Promise.all(promises)
  .catch((err) => assert.equal(
    err, 'ERROR'
  ));
复制代码
```

下图说明`Promise.all()`是如何工作的

![这需要有数字电路的知识才能看得懂哦](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcb803d2b3744f1bb028f50ff9ca9eb1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

#### 4.1 异步 .map() 与 Promise.all()

数组转换方法，如`.map()`、`.filter()`等，用于同步计算。例如

```ini
function timesTwoSync(x) {
  return 2 * x;
}
const arr = [1, 2, 3];
const result = arr.map(timesTwoSync);
assert.deepEqual(result, [2, 4, 6]);
复制代码
```

如果`.map()`的回调是基于`Promise`的函数会发生什么？ 使用这种方式 `.map()`返回的的结果是一个`Promises`数组。

`Promises`数组不是普通代码可以使用的数据，但我们可以通过`Promise.all()`来解决这个问题：它将Promises数组转换为`Promise`，并使用一组普通值数组来实现。

```ini
function timesTwoAsync(x) {
  return new Promise(resolve => resolve(x * 2));
}
const arr = [1, 2, 3];
const promiseArr = arr.map(timesTwoAsync);
Promise.all(promiseArr)
  .then(result => {
    assert.deepEqual(result, [2, 4, 6]);
  });
复制代码
```

#### 更实际工作上关于 .map()示例

接下来，咱们使用`.map()`和`Promise.all()`从`Web`下载文件。 首先，咱们需要以下帮助函数：

```javascript
function downloadText(url) {
  return fetch(url)
    .then((response) => { // (A)
      if (!response.ok) { // (B)
        throw new Error(response.statusText);
      }
      return response.text(); // (C)
    });
}
复制代码
```

`downloadText()`使用基于`Promise`的fetch API 以字符串流的方式下载文件：

- 首先，它异步检索响应（第A行）。
- response.ok（B行）检查是否存在“找不到文件”等错误。
- 如果没有错误，使用`.text()`(第C行)以字符串的形式取回文件的内容。

在下面的示例中，咱们 下载了两个文件

```ini
const urls = [
  'http://example.com/first.txt',
  'http://example.com/second.txt',
];

const promises = urls.map(
  url => downloadText(url));

Promise.all(promises)
  .then(
    (arr) => assert.deepEqual(
      arr, ['First!', 'Second!']
    ));
复制代码
```

#### Promise.all()的一个简版实现

```ini
function all(iterable) {
  return new Promise((resolve, reject) => {
    let index = 0;
    for (const promise of iterable) {
      // Capture the current value of `index`
      const currentIndex = index;
      promise.then(
        (value) => {
          if (anErrorOccurred) return;
          result[currentIndex] = value;
          elementCount++;
          if (elementCount === result.length) {
            resolve(result);
          }
        },
        (err) => {
          if (anErrorOccurred) return;
          anErrorOccurred = true;
          reject(err);
        });
      index++;
    }
    if (index === 0) {
      resolve([]);
      return;
    }
    let elementCount = 0;
    let anErrorOccurred = false;
    const result = new Array(index);
  });
}
复制代码
```

\##5. Promise.race()

`Promise.race()`方法的定义：

**Promise.race(promises: Iterable): Promise**

**Promise.race(iterable)** 方法返回一个 `promise`，一旦迭代器中的某个`promise`解决或拒绝，返回的 `promise`就会解决或拒绝。来几个例子，瞧瞧：

```javascript
const promises = [
  new Promise((resolve, reject) =>
    setTimeout(() => resolve('result'), 100)), // (A)
  new Promise((resolve, reject) =>
    setTimeout(() => reject('ERROR'), 200)), // (B)
];
Promise.race(promises)
  .then((result) => assert.equal( // (C)
    result, 'result'));
复制代码
```

在第 `A` 行，`Promise` 是完成状态 ，所以 第 `C` 行会执行（尽管第 `B` 行被拒绝）。

如果 Promise 被拒绝首先执行，在来看看情况是嘛样的：

```javascript
const promises = [
  new Promise((resolve, reject) =>
    setTimeout(() => resolve('result'), 200)),
  new Promise((resolve, reject) =>
    setTimeout(() => reject('ERROR'), 100)),
];
Promise.race(promises)
  .then(
    (result) => assert.fail(),
    (err) => assert.equal(
      err, 'ERROR'));
复制代码
```

注意，由于 `Promse` 先被拒绝，所以 `Promise.race()` 返回的是一个被拒绝的 `Promise`

这意味着`Promise.race（[]）`的结果永远不会完成。

下图演示了`Promise.race()`的工作原理：

![这需要有数字电路的知识才能看得懂](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2da73c2ea1b54014a072f463d4643e70~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

#### Promise.race() 在 Promise 超时下的情况

在本节中，我们将使用`Promise.race()`来处理超时的 `Promise`。 以下辅助函数:

```javascript
function resolveAfter(ms, value=undefined) {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(value), ms);
  });
}
复制代码
resolveAfter()` 主要做的是在指定的时间内，返回一个状态为 `resolve` 的 `Promise`，值为为传入的 `value
```

调用上面方法：

```javascript
function timeout(timeoutInMs, promise) {
  return Promise.race([
    promise,
    resolveAfter(timeoutInMs,
      Promise.reject(new Error('Operation timed out'))),
  ]);
}
复制代码
```

`timeout()` 返回一个`Promise`，该 `Promise` 的状态取决于传入 `promise` 状态 。

其中 `timeout` 函数中的 `resolveAfter(timeoutInMs, Promise.reject(new Error('Operation timed out'))` ，通过 `resolveAfter` 定义可知，该结果返回的是一个被拒绝状态的 `Promise`。

再来看看`timeout(timeoutInMs, promise)`的运行情况。如果传入`promise`在指定的时间之前状态为完成时，`timeout` 返回结果就是一个完成状态的 `Promise`,可以通过`.then`的第一个回调参数处理返回的结果。

```ini
timeout(200, resolveAfter(100, 'Result!'))
  .then(result => assert.equal(result, 'Result!'));
复制代码
```

相反，如果是在指定的时间之后完成，刚 `timeout` 返回结果就是一个拒绝状态的 `Promise`,从而触发`catch`方法指定的回调函数。

```javascript
timeout(100, resolveAfter(2000, 'Result!'))
  .catch(err => assert.deepEqual(err, new Error('Operation timed out')));
复制代码
```

重要的是要了解“Promise 超时”的真正含义：

1. 如果传入入`Promise` 较到的得到解决，其结果就会给返回的 `Promise`。
2. 如果没有足够快得到解决，输出的 `Promise` 的状态为拒绝。

也就是说，超时只会阻止传入的Promise，影响输出 Promise（因为Promise只能解决一次）， 但它并没有阻止传入`Promise`的异步操作。

#### 5.2 Promise.race() 的一个简版实现

以下是 `Promise.race()`的一个简化实现(它不执行安全检查)

```ini
function race(iterable) {
  return new Promise((resolve, reject) => {
    for (const promise of iterable) {
      promise.then(
        (value) => {
          if (settlementOccurred) return;
          settlementOccurred = true;
          resolve(value);
        },
        (err) => {
          if (settlementOccurred) return;
          settlementOccurred = true;
          reject(err);
        });
    }
    let settlementOccurred = false;
  });
}
复制代码
```

## 6.Promise.allSettled()

`“Promise.allSettled”`这一特性是由**Jason Williams**，**Robert Pamely**和**Mathias Bynens**提出。

`promise.allsettle()`方法的定义：

- **Promise**.allSettled(promises: Iterable<**Promise**>) : **Promise**<**Array**<SettlementObject>>

它返回一个`Array`的`Promise`，其元素具有以下类型特征：

```css
type SettlementObject<T> = FulfillmentObject<T> | RejectionObject;

interface FulfillmentObject<T> {
  status: 'fulfilled';
  value: T;
}

interface RejectionObject {
  status: 'rejected';
  reason: unknown;
}
复制代码
```

`Promise.allSettled()`方法返回一个promise，该promise在所有给定的promise已被解析或被拒绝后解析，并且每个对象都描述每个promise的结果。

举例说明, 比如各位用户在页面上面同时填了3个独立的表单, 这三个表单分三个接口提交到后端, 三个接口独立, 没有顺序依赖, 这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况

在多个`promise`同时进行时咱们很快会想到使用`Promise.all`来进行包装, 但是由于`Promise.all`的短路特性, 三个提交中若前面任意一个提交失败, 则后面的表单也不会进行提交了, 这就与咱们需求不符合.

`Promise.allSettled`跟`Promise.all`类似, 其参数接受一个`Promise`的数组, 返回一个新的`Promise`, 唯一的不同在于, 其不会进行短路, 也就是说当`Promise`全部处理完成后我们可以拿到每个`Promise`的状态, 而不管其是否处理成功.

下图说明`promise.allsettle()`是如何工作的

![这需要有数字电路的知识才能看得懂哦](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a836cc5e7df41bf976ffcd8a8e7202c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

#### 6.1 Promise.allSettled() 例子

这是`Promise.allSettled()` 使用方式快速演示示例

```less
Promise.allSettled([
  Promise.resolve('a'),
  Promise.reject('b'),
])
.then(arr => assert.deepEqual(arr, [
  { status: 'fulfilled', value:  'a' },
  { status: 'rejected',  reason: 'b' },
]));
复制代码
```

#### 6.2 Promise.allSettled() 较复杂点的例子

这个示例类似于`.map()`和`Promise.all()`示例(我们从其中借用了`downloadText()`函数):我们下载多个文本文件，这些文件的`url`存储在一个数组中。但是，这一次，咱们不希望在出现错误时停止，而是希望继续执行。`Promise.allSettled()`允许咱们这样做：

```less
const urls = [  'http://example.com/exists.txt',  'http://example.com/missing.txt',];

const result = Promise.allSettled(
  urls.map(u => downloadText(u)));
result.then(
  arr => assert.deepEqual(
    arr,
    [
      {
        status: 'fulfilled',
        value: 'Hello!',
      },
      {
        status: 'rejected',
        reason: new Error('Not Found'),
      },
    ]
));
复制代码
```

#### 6.3 Promise.allSettled() 的简化实现

这是`promise.allsettle()`的简化实现(不执行安全检查)

```ini
function allSettled(iterable) {
  return new Promise((resolve, reject) => {
    function addElementToResult(i, elem) {
      result[i] = elem;
      elementCount++;
      if (elementCount === result.length) {
        resolve(result);
      }
    }

    let index = 0;
    for (const promise of iterable) {
      // Capture the current value of `index`
      const currentIndex = index;
      promise.then(
        (value) => addElementToResult(
          currentIndex, {
            status: 'fulfilled',
            value
          }),
        (reason) => addElementToResult(
          currentIndex, {
            status: 'rejected',
            reason
          }));
      index++;
    }
    if (index === 0) {
      resolve([]);
      return;
    }
    let elementCount = 0;
    const result = new Array(index);
  });
}
复制代码
```

## 7. 短路特性

`Promise.all()` 和 `romise.race()` 都具有 短路特性

- **Promise.all()**： 如果参数中 `promise` 有一个失败（rejected），此实例回调失败（reject）

**Promise.race()**：如果参数中某个`promise`解决或拒绝，返回的 promise就会解决或拒绝。

## 8.并发性和 Promise.all()

#### 8.1 顺序执行与并发执行

考虑下面的代码：

```ini
asyncFunc1()
  .then(result1 => {
    assert.equal(result1, 'one');
    return asyncFunc2();
  })
  .then(result2 => {
    assert.equal(result2, 'two');
  });
复制代码
```

使用`.then()`顺序执行基于`Promise`的函数：只有在 `asyncFunc1()`的结果被解决后才会执行`asyncFunc2()` 。

而 `Promise.all()` 是并发执行的

```ini
Promise.all([asyncFunc1(), asyncFunc2()])
  .then(arr => {
    assert.deepEqual(arr, ['one', 'two']);
  });
复制代码
```

#### 9.2 并发技巧：关注操作何时开始

确定并发异步代码的技巧:关注异步操作何时启动，而不是如何处理它们的**Promises**。

例如，下面的每个函数都同时执行`asyncFunc1()`和`asyncFunc2()`，因为它们几乎同时启动。

```scss
function concurrentAll() {
  return Promise.all([asyncFunc1(), asyncFunc2()]);
}

function concurrentThen() {
  const p1 = asyncFunc1();
  const p2 = asyncFunc2();
  return p1.then(r1 => p2.then(r2 => [r1, r2]));
}
复制代码
```

另一方面，以下两个函数依次执行`asyncFunc1()`和`asyncFunc2()`: `asyncFunc2()`仅在`asyncFunc1()`的解决之后才调用。

```scss
function sequentialThen() {
  return asyncFunc1()
    .then(r1 => asyncFunc2()
      .then(r2 => [r1, r2]));
}

function sequentialAll() {
  const p1 = asyncFunc1();
  const p2 = p1.then(() => asyncFunc2());
  return Promise.all([p1, p2]);
}
复制代码
```

#### 9.3 Promise.all() 与 Fork-Join 分治编程

`Promise.all()` 与并发模式“fork join”松散相关。重温一下咱们前面的一个例子：

```javascript
Promise.all([
    // (A) fork
    downloadText('http://example.com/first.txt'),
    downloadText('http://example.com/second.txt'),
  ])
  // (B) join
  .then(
    (arr) => assert.deepEqual(
      arr, ['First!', 'Second!']
    ));
复制代码
```

- Fork：在`A`行中，分割两个异步任务并同时执行它们。
- Join：在`B`行中，对每个小任务得到的结果进行汇总。

**代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 [Fundebug](https://link.juejin.cn/?target=https%3A%2F%2Fwww.fundebug.com%2F%3Futm_source%3Dxiaozhi)。**

## 一. 什么是Promise?

在`JavaScript`的世界中，所有代码都是单线程执行的。由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用`回调函数实现`：

```js
function requestData(url, successCallback, failtureCallback) {
  // 模拟网络请求
  setTimeout(() => {
    // 拿到请求的结果
    // url传入的是localhost, 请求成功
    if (url === "localhost") {
      // 成功
      successCallback('success')
    } else { // 否则请求失败
      // 失败
      failtureCallback("error")
    }
  }, 3000);
}

//执行请求
requestData("kobe", (res) => {
  console.log(res)
}, (err) => {
  console.log(err)
})
复制代码
```

但实际开发过程中有些情况需要多次调用服务器API，就会形成一个链式调用，比如为了完成一个功能，我们需要调用API1、API2、API3，依次按照顺序进行调用，这个时候就会出现`回调地狱`的问题，即嵌套层次深，不好维护，可读性差。这时候就需要用到`Promise`。

## 二. Promise使用方式

`Promise` 对象的`构造器（constructor）`语法如下：

```js
// 传入的这个函数, 被称之为 executor
// > resolve: 回调函数, 在成功时, 回调resolve函数
// > reject: 回调函数, 在失败时, 回调reject函数
let promise = new Promise(function(resolve, reject) { // executor });
复制代码
```

executor 最终将 `promise` 移至以下状态之一：

> executor 只能调用一个 `resolve` 或一个 `reject`。一旦状态被确定下来，Promise的状态会被`锁死`，该Promise的状态是不可更改的。 ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/278d28a58a1f4694ac5edae411d0e754~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

上方代码改写为`Promise`:

```js
// request.js
function requestData(url,) {
  // 异步请求的代码会被放入到executor中
  return new Promise((resolve, reject) => {
    // 模拟网络请求
    setTimeout(() => {
      // 拿到请求的结果
      // url传入的是localhost, 请求成功
      if (url === "localhost") {
        // 成功
        resolve(success)
      } else { // 否则请求失败
        // 失败
        reject('error')
      }
    }, 3000);
  })
}

const promise = requestData("localhost")

//then方法是Promise对象上的一个方法：它其实是放在Promise的原型上的 Promise.prototype.then
promise.then((res) => {
  console.log("请求成功:", res)
}, (err) => { 
   console.log("请求失败:", err)
})

//等价于
promise.then((res) => {
  console.log("请求成功:", res)
}).catch(err => {//catch方法也是Promise对象上的一个方法：它也是放在Promise的原型上的 Promise.prototype.catch
console.log("请求失败:", err)
})
复制代码
```

**当传入resolve不同的值的区别:**

> 情况一：如果resolve传入一个普通的值或者对象，那么这个值会作为then回调的参数；

> 情况二：如果resolve中传入的是另外一个Promise，那么这个新Promise会决定原Promise的状态；

举例：

```js
new Promise((resolve, reject) => {
  // pending -> fulfilled
  resolve(new Promise((resolve,reject)=>{
    setTimeout(()=>{resolve(111)},1000)
  }))
}).then(res => {
  console.log("res:", res) //111
}, err => {
  console.log("err:", err)
})
复制代码
```

> 情况三：如果resolve中传入的是一个对象，并且这个对象有实现then方法，那么会执行该then方法，并且根据 then方法的结果来决定Promise的状态；

举例：

```js
// 2.传入一个对象, 这个兑现有then方法
new Promise((resolve, reject) => {
  // pending -> fulfilled
  const obj = {
    then: function(resolve, reject) {
      // resolve("resolve message")
      reject("reject message")
    }
  }
  resolve(obj)
}).then(res => {
  console.log("res:", res)
}, err => {
  console.log("err:", err)//reject message
})
复制代码
```

## 三. Promise实例方法

### 1. `then`方法

当`Promise`的状态变成`fulfilled`的时候，then方法可以多次调用(同理状态变成`reject`的时候，catch也可以被多次调用） ：

```js
onst promise = new Promise((resolve, reject) => {
  resolve("hahaha")
})

promise.then(res => {
  console.log("res1:", res)
})

promise.then(res => {
  console.log("res2:", res)
})

promise.then(res => {
  console.log("res3:", res)
})
复制代码
```

`then`方法本身也是有返回值的, 它的返回值是`Promise`,我们可以进行链式调用。

```js
promise.then(res => {
  return "aaaaaa"
}).then(res => {
  console.log("res:", res) //aaaaaa
  return "bbbbbb"
})
复制代码
```

**then方法返回的Promise到底处于什么样的状态呢？**

> 当`then`方法中的回调函数本身在执行的时候，那么它处于`pending`状态；
>
> 当`then`方法中的回调函数返回一个结果时，那么它处于`fulfilled`状态，并且会将结果作为resolve的参数；
>
> 当`then`方法抛出一个异常时，那么它处于`reject`状态；

`then`传入不同值区别的同上方`resolve`相同，这边就不举例了，大家自己动手写一下。

### 2.`catch` 方法

catch方法也是会返回一个Promise对象的，所以catch方法后面可以继续调用then方法或者catch方法:

```js
const promise = new Promise((resolve, reject) => {
  reject("111111")
})

promise.then(res => {
  console.log("res:", res)
}).catch(err => {
  console.log("err:", err)//111111
  // throw new Error('hhhhhh')
  return "catch return value"
}).then(res => {
  console.log("res result:", res) //catch return value
}).catch(err => {
  console.log("err result:", err)  
})
复制代码
```

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f97d44a5b5694a8b916bc100d22fa13c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

> 提示：把上方注释的throw方法打开，方法会取下方catch部分

### 3.`finally` 方法

finally是在ES9（ES2018）中新增的一个特性：表示无论Promise对象无论变成fulfilled还是reject状态，最终都会被执行的代码。

> finally方法是不接收参数的，因为无论前面是fulfilled状态，还是reject状态，它都会执行

```js
const promise = new Promise((resolve, reject) => {
  // resolve("resolve message")
  reject("reject message")
})

promise.then(res => {
  console.log("res:", res)
}).catch(err => {
  console.log("err:", err)
}).finally(() => {
  console.log("finally code execute")
})

复制代码
```

## 四. Promise类方法

### 1.Promise.resolve

用法相当于new Promise，并且执行resolve操作：

```js
// 1.普通的值
 const promise = Promise.resolve({ name: "why" })
// 相当于
 const promise2 = new Promise((resolve, reject) => {
   resolve({ name: "why" })
 })
复制代码
```

### 2.Promise.reject

用法相当于new Promise，只是会调用reject：

```js
const promise = Promise.reject("rejected message")
//相当于
const promise2 = new Promsie((resolve, reject) => {
  reject("rejected message")
})
复制代码
```

### 3.Promise.all

作用是将多个Promise包裹在一起形成一个新的Promise,新的Promise状态由包裹的所有Promise共同决定：

> 当所有的Promise状态变成fulfilled状态时，新的Promise状态为fulfilled，并且会将所有Promise的返回值 组成一个数组；
>
> 当有一个Promise状态为reject时，新的Promise状态为reject，并且会将第一个reject的返回值作为参数;

```js
// 创建多个Promise
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(11111)
  }, 1000);
})

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(22222)
  }, 2000);
})

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(33333)
  }, 3000);
})

// 需求: 所有的Promise都变成fulfilled时, 再拿到结果
// 意外: 在拿到所有结果之前, 有一个promise变成了rejected, 那么整个promise是rejected
Promise.all([p2, p1, p3, "aaaa"]).then(res => {
  console.log(res)
}).catch(err => {
  console.log("err:", err)
})
复制代码
```

### 3.Promise.race

如果有一个Promise有了结果，我们就希望决定最终新Promise的状态，那么可以使用race方法

```js
// 只要有一个Promise变成fulfilled状态, 那么就结束
// 意外: 
Promise.race([p1, p2, p3]).then(res => {
  console.log("res:", res)
}).catch(err => {
  console.log("err:", err)
})

复制代码
```

# 后记

当然promise类远远不止上方几种方法，在ES11,ES12中新增了`Promise.allSettled`、`Promise.any`, 这边就不介绍了，大家可点击此链接自主学习

## 前言

我们知道`Promise`与`Async/await`函数都是用来解决JavaScript中的异步问题的，从最开始的回调函数处理异步，到`Promise`处理异步，到`Generator`处理异步，再到`Async/await`处理异步，每一次的技术更新都使得JavaScript处理异步的方式更加优雅，从目前来看，`Async/await`被认为是异步处理的终极解决方案，让JS的异步处理越来越像同步任务。**异步编程的最高境界，就是根本不用关心它是不是异步**。

**如果这篇文章有帮助到你，❤️关注+点赞❤️鼓励一下作者，文章公众号首发，关注 `前端南玖` 第一时间获取最新的文章～**

## 异步解决方案的发展历程

### 1.回调函数

从早期的Javascript代码来看，在ES6诞生之前，基本上所有的异步处理都是基于回调函数函数实现的，你们可能会见过下面这种代码：

```js
ajax('aaa', () => {
    // callback 函数体
    ajax('bbb', () => {
        // callback 函数体
        ajax('ccc', () => {
            // callback 函数体
        })
    })
})
复制代码
```

没错，在ES6出现之前，这种代码可以说是随处可见。它虽然解决了异步执行的问题，可随之而来的是我们常听说的**回调地狱**问题：

- 没有顺序可言：嵌套函数执行带来的是调试困难，不利于维护与阅读
- 耦合性太强：一旦某一个嵌套层级有改动，就会影响整个回调的执行

**所以，为了解决这个问题，社区最早提出和实现了`Promise`，ES6将其写进了语言标准，统一了用法。**

### 2.Promise

Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它就是为了解决回调函数产生的问题而诞生的。

有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。

所以上面那种回调函数的方式我们可以改成这样：(前提是ajax已用Promise包装)

```js
ajax('aaa').then(res=>{
  return ajax('bbb')
}).then(res=>{
  return ajax('ccc')
})
复制代码
```

通过使用`Promise`来处理异步，比以往的回调函数看起来更加清晰了，解决了回调地狱的问题，`Promise`的`then`的链式调用更能让人接受，也符合我们同步的思想。

**但Promise也有它的缺点：**

- Promise的内部错误使用`try catch`捕获不到，只能只用`then`的第二个回调或`catch`来捕获

```js
let pro
try{
    pro = new Promise((resolve,reject) => {
        throw Error('err....')
    })
}catch(err){
    console.log('catch',err) // 不会打印
}
pro.catch(err=>{
    console.log('promise',err) // 会打印
})
复制代码
```

- Promise一旦新建就会立即执行，无法取消

之前写过一篇[从如何使用到如何实现一个Promise](https://juejin.cn/post/7051364317119119396)，讲解了Promise如何使用以及内部实现原理。对Promise还不太理解的同学可以看看～

### 3.Generator

`Generator` 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。`Generator` 函数将 JavaScript 异步编程带入了一个全新的阶段。

#### 声明

与函数声明类似，不同的是`function`关键字与函数名之间有一个星号，以及函数体内部使用`yield`表达式，定义不同的内部状态（`yield`在英语里的意思就是“产出”）。

```js
function* gen(x){
 const y = yield x + 6;
 return y;
}
// yield 如果用在另外一个表达式中,要放在()里面
// 像上面如果是在=右边就不用加()
function* genOne(x){
  const y = `这是第一个 yield 执行:${yield x + 1}`;
 return y;
}
复制代码
```

#### 执行

```js
const g = gen(1);
//执行 Generator 会返回一个Object,而不是像普通函数返回return 后面的值
g.next() // { value: 7, done: false }
//调用指针的 next 方法,会从函数的头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式或return语句暂停,也就是执行yield 这一行
// 执行完成会返回一个 Object,
// value 就是执行 yield 后面的值,done 表示函数是否执行完毕
g.next() // { value: undefined, done: true }
// 因为最后一行 return y 被执行完成,所以done 为 true
复制代码
```

调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是`遍历器对象（Iterator Object）`。下一步，必须调用遍历器对象的`next`方法，使得指针移向下一个状态。

所以上面的回调函数又可以写成这样：

```js
function *fetch() {
    yield ajax('aaa')
    yield ajax('bbb')
    yield ajax('ccc')
}
let gen = fetch()
let res1 = gen.next() // { value: 'aaa', done: false }
let res2 = gen.next() // { value: 'bbb', done: false }
let res3 = gen.next() // { value: 'ccc', done: false }
let res4 = gen.next() // { value: undefined, done: true } done为true表示执行结束
复制代码
```

由于 Generator 函数返回的遍历器对象，只有调用`next`方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。`yield`表达式就是暂停标志。

遍历器对象的`next`方法的运行逻辑如下。

（1）遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。

（2）下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。

（3）如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。

（4）如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

**`yield`表达式本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。**

怎么理解这句话？我们来看下面这个例子：

```js
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
复制代码
```

由于`yield`没有返回值，所以（yield（x+1））执行后的值是`undefined`，所以在第二次执行`a.next()`是其实是执行的`2*undefined`，所以值是`NaN`，所以下面b的例子中，第二次执行`b.next()`时传入了12，它会当成第一次`b.next()`的执行返回值，所以b的例子中能够正确计算。**这里不能把next执行结果中的value值与yield返回值搞混了，它两不是一个东西**

#### yield与return的区别

相同点:

- 都能返回语句后面的那个表达式的值
- 都可以暂停函数执行

区别:

- 一个函数可以有多个 yield,但是只能有一个 return
- yield 有位置记忆功能,return 没有

### 4.Async/await

`Async/await`其实就是上面`Generator`的语法糖，`async`函数其实就相当于`funciton *`的作用，而`await`就相当与`yield`的作用。而在`async/await`机制中，自动包含了我们上述封装出来的`spawn`自动执行函数。

所以上面的回调函数又可以写的更加简洁了：

```js
async function fetch() {
  	await ajax('aaa')
    await ajax('bbb')
    await ajax('ccc')
}
// 但这是在这三个请求有相互依赖的前提下可以这么写，不然会产生性能问题，因为你每一个请求都需要等待上一次请求完成后再发起请求，如果没有相互依赖的情况下，建议让它们同时发起请求，这里可以使用Promise.all()来处理
复制代码
```

`async`函数对`Generator`函数的改进，体现在以下四点：

- 内置执行器：`async`函数执行与普通函数一样，不像`Generator`函数，需要调用`next`方法，或使用`co`模块才能真正执行
- 语意化更清晰：`async`和`await`，比起星号和`yield`，语义更清楚了。`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果。
- 适用性更广：`co`模块约定，`yield`命令后面只能是 Thunk 函数或 Promise 对象，而`async`函数的`await`命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
- 返回值是Promise：`async`函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用`then`方法指定下一步的操作。

#### async函数

async函数的返回值为Promise对象，所以它可以调用then方法

```js
async function fn() {
  return 'async'
}
fn().then(res => {
  console.log(res) // 'async'
})
复制代码
```

#### await表达式

**await** 右侧的表达式一般为 **promise** 对象, 但也可以是其它的值

1. 如果表达式是 promise 对象, await 返回的是 promise 成功的值
2. 如果表达式是其它值, 直接将此值作为 await 的返回值
3. await后面是Promise对象会阻塞后面的代码，Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果
4. 所以这就是await必须用在async的原因，async刚好返回一个Promise对象，可以异步执行阻塞

```js
function fn() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(1000)
        }, 1000);
    })
}
function fn1() { return 'nanjiu' }
async function fn2() {
    // const value = await fn() // await 右侧表达式为Promise，得到的结果就是Promise成功的value
    // const value = await '南玖'
    const value = await fn1()
    console.log('value', value)
}
fn2() // value 'nanjiu'
复制代码
```

## 异步方案比较

后三种方案都是为解决传统的回调函数而提出的，所以它们相对于回调函数的优势不言而喻。而`async/await`又是`Generator`函数的语法糖。

- Promise的内部错误使用`try catch`捕获不到，只能只用`then`的第二个回调或`catch`来捕获，而`async/await`的错误可以用`try catch`捕获
- `Promise`一旦新建就会立即执行，不会阻塞后面的代码，而`async`函数中await后面是Promise对象会阻塞后面的代码。
- `async`函数会隐式地返回一个`promise`，该`promise`的`reosolve`值就是函数return的值。
- 使用`async`函数可以让代码更加简洁，不需要像`Promise`一样需要调用`then`方法来获取返回值，不需要写匿名函数处理`Promise`的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。

## 说了这么多，顺便看个题吧～

```js
console.log('script start')
async function async1() {
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2 end')
}
async1()

setTimeout(function() {
    console.log('setTimeout')
}, 0)

new Promise(resolve => {
    console.log('Promise')
    resolve()
})
.then(function() {
    console.log('promise1')
})
.then(function() {
    console.log('promise2')
})
console.log('script end')
复制代码
```

**解析：**

打印顺序应该是：` script start -> async2 end -> Promise -> script end -> async1 end -> promise1 -> promise2 -> setTimeout`

老规矩，全局代码自上而下执行，先打印出`script start`，然后执行async1(),里面先遇到await async2(),执行async2,打印出`async2 end`，然后await后面的代码放入微任务队列，接着往下执行new Promise，打印出`Promise`,遇见了resolve，将第一个then方法放入微任务队列，接着往下执行打印出`script end`，全局代码执行完了，然后从微任务队列中取出第一个微任务执行，打印出`async1 end`,再取出第二个微任务执行，打印出`promise1`,然后这个then方法执行完了，当前Promise的状态为`fulfilled`,它也可以出发then的回调，所以第二个then这时候又被加进了微任务队列，然后再出微任务队列中取出这个微任务执行，打印出`promise2`,此时微任务队列为空，接着执行宏任务队列，打印出`setTimeout`。

**解题技巧：**

- 无论是then还是catch里的回调内容只要代码正常执行或者正常返回，则当前新的Promise实例为fulfilled状态。如果有报错或返回Promise.reject()则新的Promise实例为rejected状态。
- fulfilled状态能够触发then回调
- rejected状态能够触发catch回调
- 执行async函数，返回的是Promise对象
- await相当于Promise的then并且同一作用域下await下面的内容全部作为then中回调的内容
- 异步中先执行微任务，再执行宏任务

### 函数防抖(debounce)

> 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

看一个🌰（栗子）：

```stylus
//模拟一段ajax请求
function ajax(content) {
  console.log('ajax request ' + content)
}

let inputa = document.getElementById('unDebounce')

inputa.addEventListener('keyup', function (e) {
    ajax(e.target.value)
})
复制代码
```

看一下运行结果：



![2018-09-04 09 23 46](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/4/165a252be5c94d6b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下：

```reasonml
//模拟一段ajax请求
function ajax(content) {
  console.log('ajax request ' + content)
}

function debounce(fun, delay) {
    return function (args) {
        let that = this
        let _args = args
        clearTimeout(fun.id)
        fun.id = setTimeout(function () {
            fun.call(that, _args)
        }, delay)
    }
}
    
let inputb = document.getElementById('debounce')

let debounceAjax = debounce(ajax, 500)

inputb.addEventListener('keyup', function (e) {
        debounceAjax(e.target.value)
    })复制代码
```

看一下运行结果：



![2018-09-04 09 29 50](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/4/165a252b4b429b56~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



可以看到，我们加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。 再看一个🌰：

```reasonml
let biu = function () {
    console.log('biu biu biu',new Date().Format('HH:mm:ss'))
}

let boom = function () {
    console.log('boom boom boom',new Date().Format('HH:mm:ss'))
}


setInterval(debounce(biu,500),1000)
setInterval(debounce(boom,2000),1000)复制代码
```

看一下运行结果：



![2018-09-04 09 32 21](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/4/165a252b4b809a23~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



这个🌰就很好的解释了，如果在时间间隔内执行函数，会重新触发计时。biu会在第一次1.5s执行后，每隔1s执行一次，而boom一次也不会执行。因为它的时间间隔是2s，而执行时间是1s，所以每次都会重新触发计时

> ### 个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。

### 函数节流(throttle)

> 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

看一个🌰：

```reasonml
  function throttle(fun, delay) {
        let last, deferTimer
        return function (args) {
            let that = this
            let _args = arguments
            let now = +new Date()
            if (last && now < last + delay) {
                clearTimeout(deferTimer)
                deferTimer = setTimeout(function () {
                    last = now
                    fun.apply(that, _args)
                }, delay)
            }else {
                last = now
                fun.apply(that,_args)
            }
        }
    }

    let throttleAjax = throttle(ajax, 1000)

    let inputc = document.getElementById('throttle')
    inputc.addEventListener('keyup', function(e) {
        throttleAjax(e.target.value)
    })复制代码
```

看一下运行结果：



![2018-09-04 09 36 49](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/4/165a252b4c1a9686~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



可以看到，我们在不断输入时，ajax会按照我们设定的时间，每1s执行一次。

结合刚刚biubiubiu的🌰：

```reasonml
    let biubiu = function () {
        console.log('biu biu biu', new Date().Format('HH:mm:ss'))
    }

    setInterval(throttle(biubiu,1000),10)
复制代码
```



![2018-09-04 09 37 58](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/4/165a252b46818296~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



不管我们设定的执行时间间隔多小，总是1s内只执行一次。

> ### 个人理解 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。

# 总结

- 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。
- 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。

### 结合应用场景

- debounce 
  - search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
  - window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
- throttle 
  - 鼠标不断点击触发，mousedown(单位时间内只触发一次)
  - 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断

# 拓展

> 参考链接：[www.cnblogs.com/zichi/p/533…](https://link.juejin.cn?target=http%3A%2F%2Fwww.cnblogs.com%2Fzichi%2Fp%2F5331426.html)



![15343043539670](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/4/165a252b4c074274~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



这是高程中的经典代码：

```reasonml
    function throttle(method, context) {
        clearTimeout(method.tId);
        method.tId = setTimeout(function () {
            method.call(context);
        }, 100)
    }
复制代码
```

我们通过上面的例子知道，其实这段函数应该是debounce函数防抖，而不是函数节流，很多文章也都会拿这段代码来做例子，函数本身没错，但是命名错了。

原作者的这段话就写的很好，

> 就以 throttle 为例，某日，老师给你布置了一个作业，让你深入理解一下 throttle，第二天上课来聊聊。张三心里非常高兴，这个概念在经典书籍《JavaScript高级程序设计》中见过，打开一看，就两页，而且解释地非常清晰，看完就高兴地干别的事情去了。而李四，觉得高程三讲的有点少，而去谷歌了下其他关于 throttle 的知识点，兴奋地看到 throttle 函数的好几种写法，发现高程三只是用了最简单的方式，还有更优雅运用场景更多的写法，或许此时他已经发现和 throttle 同时出现的还有个 debounce，这是什么鬼？反正老师没说，以后再看吧，于是心满意足地玩游戏去了。而王五，和李四一样发现了 debounce，这是什么？一起了解了吧，继而发现 debounce 的用法居然和高程三中的 throttle 一样！继续挖下去，发现高程三中的 throttle 函数其实应该叫 debounce，看到最后，王五已经把 throttle 和 debounce 彻底理解了。

我们要做王五，并且争取早日产出一手知识！加油！

## 防抖（debounce）

如果用户多次频繁操作以最后一次为准，当然也可以以第一次为准，进行数据更新或者网络资源请求，以消除冗余的操作，或者减少一定的请求资源浪费。

### 示例代码

```javascript
function debounce (fn, delay = 300){
    let timer = null
    return function (...args) {
        clearTimeout(timer)
        timer = setTimeout(()=>{
            fn.call(this, ...args)
        }, delay);
    }
}
复制代码
```

### 使用

```javascript
debounce(()=> count += 1, 1000)
复制代码
```

## 节流（throttle ）

在一定时间范围内，用户触发多次只会执行一次以达到防止用户频繁操作的目的。

### 示例代码

```javascript
let timer = null
function throttle (fn, delay = 300) {
    if(timer == null){
        timer = setTimeout(() => {
            fn()

            clearTimeout(timer)
            timer = null
        }, delay);
    }
}
复制代码
```

### 使用

```javascript
throttle(()=> count += 1, 1000)
复制代码
```

# 环境说明

- vue 3
- vite

# 新封装

这里我分两个模块来讲述。一个是防抖；另一个是节流。

虽然这两个差别不是很大，但还是有区别的。上车，兄弟们。🚗🚗🚗

## 防抖（debounce）

先看常见封装内容。

### 常见封装-1

#### 代码

```javascript
function debounce (fn, delay = 300){
    let timer = null
    return function (...args) {
        if(timer != null){
            clearTimeout(timer)
            timer = null
        }
        timer = setTimeout(()=>{
            fn.call(this, ...args)
        }, delay);
    }
}
复制代码
```

#### 使用

```javascript
const addCount = debounce(()=> count.value += 1, 1000)
复制代码
```

### 常见封装-2

#### 代码

```javascript
let timer = null
function debounce (fn, delay = 1000){
    if(timer != null){
        clearTimeout(timer)
        timer = null
    }
    timer = setTimeout(fn, delay)
}
复制代码
```

#### 使用

```javascript
const addCount = () => debounce(()=> count.value += 1, 1000)
复制代码
```

### 新封装

这里我们需要借助 `vue 3` 中的 `customRef` 来实现我们的新方式。这里我就不具体写了。我直接在每行代码上面添加注释。我相信朋友你是能看懂的。🌹🌹🌹

#### 代码

```javascript
// 从 vue 中引入 customRef 和 ref
import { customRef, ref } from "vue"

// data 为创建时的数据
// delay 为防抖时间
function debounceRef (data, delay = 300){
    // 创建定时器
    let timer = null;
    // 对 delay 进行判断，如果传递的是 null 则不需要使用 防抖方案，直接返回使用 ref 创建的。
    return delay == null 
        ? 
        // 返回 ref 创建的
        ref(data)
        : 
        // customRef 中会返回两个函数参数。一个是：track 在获取数据时收集依赖的；一个是：trigger 在修改数据时进行通知派发更新的。
        customRef((track, trigger) => {
            return {
                get () {
                    // 收集依赖
                    track()
                    // 返回当前数据的值
                    return data
                },
                set (value) {
                    // 清除定时器
                    if(timer != null){
                        clearTimeout(timer)
                        timer = null
                    }
                    // 创建定时器
                    timer = setTimeout(() => {
                        // 修改数据
                        data = value;
                        // 派发更新
                        trigger()
                    }, delay)
                }
            }
        })
}
复制代码
```

#### 使用

```javascript
// 创建
const count = debounceRef(0, 300)

// 函数中使用
const addCount = () => {
  count.value += 1
}

// v-model 中使用
<input type="text" v-model="count">

复制代码
```

## 节流（throttle）

我们还是一样，先看常见封装内容。

### 常见封装-1

#### 代码

```javascript
let timer = null
function throttle (fn, delay = 300) {
    if(timer == null){
        timer = setTimeout(() => {
            fn()

            clearTimeout(timer)
            timer = null
        }, delay);
    }
}
复制代码
```

#### 使用

```javascript
const addCount = () => throttle(()=> count.value += 1, 1000)
复制代码
```

### 常见封装-2

#### 代码

```javascript
function throttle (fn, delay = 300) {
    let timer = null
    return function (...args) {
        if(timer == null){
            timer = setTimeout(() => {
                fn.call(this, ...args)
    
                clearTimeout(timer)
                timer = null
            }, delay);
        }
    }
}
复制代码
```

#### 使用

```javascript
const addCount = throttle(()=> count.value += 1, 1000)
复制代码
```

### 新封装

节流和防抖在封装和使用上大同小异。

#### 代码

```javascript
// data 为创建时的数据
// delay 为节流时间
function throttleRef (data, delay = 300){
    // 创建定时器
    let timer = null;
    // 对 delay 进行判断，如果传递的是 null 则不需要使用 节流方案，直接返回使用 ref 创建的。
    return delay == null 
        ? 
        // 返回 ref 创建的
        ref(data)
        : 
        // customRef 中会返回两个函数参数。一个是：track 在获取数据时收集依赖的；一个是：trigger 在修改数据时进行通知派发更新的。
        customRef((track, trigger) => {
            return {
                get () {
                    // 收集依赖
                    track()
                    // 返回当前数据的值
                    return data
                },
                set (value) {
                    // 判断
                    if(timer == null){
                        // 创建定时器
                        timer = setTimeout(() => {
                            // 修改数据
                            data = value;
                            // 派发更新
                            trigger()
                            // 清除定时器
                            clearTimeout(timer)
                            timer = null
                        }, delay)
                    }
                    
                }
            }
        })
}
复制代码
```

#### 使用

```javascript
// 创建
const count = debounceRef(0, 300)

// 函数中使用
const addCount = () => {
  count.value += 1
}

// v-model 中使用
<input type="text" v-model="count">

复制代码
```

# 总结

以上便是`Vue 3 中的极致防抖/节流（含常见方式防抖/节流）`这篇文章的全部内容，如有不足或朋友你有更好的方式或者其他独到的见解，欢迎评论 + 私信。

当然朋友你又学到了一招可以点赞 + 关注 + 评论哦。

希望本篇文章对正在阅读的朋友你有所帮助。

## 起源

面试官：“知道防抖和节流吗，简单地说说。”

此时我心中窃喜，这么简单，有手就行。然后就开始介绍起防抖节流的知识点。

我：“防抖是....，然后节流是....，它们的应用场景在....”

能说的东西都说到了，能覆盖的知识点都覆盖到了，结果面试官来一句：“嗯嗯好，给我手写一下防抖节流。”

这一刻我愣住了：“让我手写这两个....，我不会呀....”

最后结果可想而知。

于是乎，我便重整旗鼓，来面对这两座对我之前而言的大山 — 防抖和节流。

## 防抖

顾名思义，我们可以将防抖理解为是防止抖动。当我们在频繁地触发一个事件时，会引起不必要的性能损失，那么我们需要做的是让事件在停止触发后再触发，以此减少性能损失。

防抖就是要延迟执行，我们一直操作触发事件并且不执行，只有当停止操作后等才会执行。

**防抖函数**的作用是控制函数在一定时间内的执行次数。简单点说就是通过防抖函数让某个触发事件在 `n` 秒内只会被执行一次。

## 节流

节流是指绑定事件后，通过动作触发事件，在这段时间内，如果动作又发生，忽略该动作，一直到事件执行完后才能重新触发。通俗的说就是控制高频执行的次数。

**节流函数**的作用是在一个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。

## 应用场景

可能这样描述对刚接触防抖节流的小伙伴来说会有些不好完全理解，接下来通过分析一下它们的应用场景来深化它们的概念。

### 防抖应用场景

防抖适合多次事件一次响应的情况。

比较典型的有搜索事件，用户在不断输入值时，用防抖来节约请求资源，只有最后一次回车才能返回结果。还有按钮点击事件，为了防止用户多次重复提交也会使用防抖函数。最后就是部分的电话号码输入的验证，要等停止输入后才会进行一次验证。

### 节流应用场景

节流适合大量事件按时间做平均分配触发。

比较典型的有监听滚动或 `resize` 事件，比如是否滑到底部自动加载更多，调整窗口大小。另外还有一个就是像掘金写文章这里一样，有自动保存功能，我们一边写，它可以一边保存。剩下就比如说 `DOM` 元素拖拽，以及游戏中的刷新率都是会使用到节流函数的。

## 手写防抖节流

介绍了它们的理论基础知识和应用场景后，现在来手写一下它们吧。

```javascript
// 防抖（简单版本）
function debounce(fn, delay) {
    let timer = null;
    clearTimeout(timer); // 下次调用时会清除上次的timer， 然后重新延迟
    timer = setTimeout(function(){
        fn();
    }, delay);
} 

// 防抖（立即执行版本）
function debounce(fn, wait) {
    let timer = null
    return function () {
        let args = arguments
        let now = !timer
        timer && clearTimeout(timer)
        timer = setTimeout(() => {
            timer = null
        }, wait)
        if (now) {
            fn.apply(this, args)
        }
    }
}

// 节流（定时器版本）
function throttle(fn, wait) {
    let timer = null
    return function () {
        let context = this
        let args = arguments
        if (!timer) {
            timer = setTimeout(() => {
                timer = null
                fn.apply(context, args)
            }, wait)
        }
    }
}
复制代码
```

防抖和节流的核心就是定时器，通过配合定时器来完成防抖节流函数的手写是很常见的方式。这里附上防抖函数的两种写法以及节流函数的一种写法，都可以参考研究。

## 总结

**防抖和节流能有效减少浏览器引擎的损耗，防止出现页面堵塞卡顿现象，需要熟练掌握。** 防抖和节流学习完后，还有其他的手写题等着我，接下来慢慢去学并记录下来。

## 防抖

防抖是指在一定时间内，多次触发同一事件，只执行最后一次，或者只在开始时执行一次。防抖的应用场景比较广泛，例如在用户输入搜索关键词时，可以使用防抖来避免频繁地向服务器发送请求。

下面是一个简单的防抖实现代码：

```js
/**
 * 防抖函数
 * @param {Function} fn - 需要执行的函数
 * @param {Number} delay - 时间延迟参数
 * @return {Function} 返回一个新的函数
 */
function debounce(fn, delay) {
  // 定义一个变量来保存定时器的返回值
  let timer = null;
  // 返回一个新的函数
  return function() {
    // 保存函数执行时的参数
    const args = arguments;
    // 如果已经存在定时器，则清除之前的定时器
    if (timer) clearTimeout(timer);
    // 创建一个新的定时器
    timer = setTimeout(() => {
      // 在延迟结束后执行传入的函数，并传入之前保存的参数
      fn.apply(this, args);
    }, delay);
  }
}

复制代码
```

在这段代码中，我们定义了一个 `debounce` 函数，它接受一个函数 `fn` 和一个时间延迟参数 `delay`。返回一个新函数，在这个新函数中使用了闭包保存了原函数的 `this` 指向和 `arguments` 对象，以确保原函数在执行时能够正确地访问到它们。在延迟结束后执行原函数时，我们需要使用 `apply` 方法将保存的 `this` 指向传递给原函数，以确保它能够正确地访问到其所在的对象。

## 节流

节流是指在一定时间内，多次触发同一事件，只执行一次。节流的应用场景也比较广泛，例如在用户滚动页面时，可以使用节流来避免频繁地触发函数。

下面是一个简单的节流实现代码：

```js
/**
 * 节流函数
 * @param {Function} fn - 需要执行的函数
 * @param {Number} delay - 时间延迟参数
 * @return {Function} 返回一个新的函数
 */
function throttle(fn, delay) {
  // 定义一个变量来保存定时器的返回值
  let timer = null;
  // 返回一个新的函数
  return function() {
    // 保存函数执行时的参数
    const args = arguments;
    // 如果已经存在定时器，则直接返回
    if (timer) return;
    // 创建一个新的定时器
    //fn.apply(this, args); //在延迟前执行传入的函数，并传入之前保存的参数
    timer = setTimeout(() => {
      // 在延迟结束后执行传入的函数，并传入之前保存的参数
      fn.apply(this, args);
      // 执行完毕后将定时器变量设置为 null，以便下一次调用函数
      timer = null;
    }, delay);
  }
}
复制代码
```

在这段代码中，我们定义了一个 `throttle` 函数，它接受一个函数 `fn` 和一个时间延迟参数 `delay`。返回一个新函数，在这个新函数中使用了一个标记变量 `timer` 来判断是否需要执行原函数。在第一次调用原函数时，我们保存了其 `this` 指向和 `arguments` 对象，并且在计时器结束后执行原函数时，同样需要使用 `apply` 方法将保存的 `this` 指向传递给原函数，以确保它能够正确地访问到其所在的对象。

## 在具体功能中使用防抖和节流

防抖和节流的应用场景比较广泛，可以在很多具体功能中使用它们来提高代码的性能。例如：

- 在用户输入搜索关键词时，可以使用防抖来避免频繁地向服务器发送请求。
- 在用户滚动页面时，可以使用节流来避免频繁地触发函数。
- 在监听窗口大小改变时，可以使用节流来避免频繁地调整布局。
- 在监听鼠标移动时，可以使用节流来避免频繁地触发事件。

下面以一个搜索框的例子来演示如何在具体功能中使用防抖。

```html
<input type="text" id="search-input">
复制代码
const searchInput = document.getElementById('search-input');

function search(keyword) {
  console.log(`search for ${keyword}`);
  // 发送搜索请求
}

const debounceSearch = debounce(search, 500);

searchInput.addEventListener('input', event => {
  debounceSearch(event.target.value);
});
复制代码
```

在这个例子中，我们首先定义了一个 `search` 函数，它会接受一个关键词参数并发送搜索请求。然后，我们使用 `debounce` 函数创建了一个新函数 `debounceSearch`，它会在输入框中输入内容时被调用，避免了频繁地向服务器发送请求。最后，我们通过 `addEventListener` 方法将这个新函数绑定到输入框的 `input` 事件上，以响应用户的输入。

类似地，我们也可以在其他具体功能中使用防抖和节流来提高代码的性能。只需要根据实际情况选择合适的函数和时间延迟参数即可。

## 结语

防抖和节流是 JavaScript 中常用的性能优化方式。它们的原理和实现方法都比较简单，但却能够显著提高代码的性能。在具体功能中使用防抖和节流也比较简单，只需要根据实际情况选择合适的函数和时间延迟参数即可。希望本文对大家有所帮助。

## 一、是什么

本质上是优化高频率执行代码的一种手段

如：浏览器的 `resize`、`scroll`、`keypress`、`mousemove` 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能

为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 **防抖（debounce）**  和 **节流（throttle）**  的方式来减少调用频率

## 二. 区别以及共同点

JS 防抖与节流

|               | 共同点                 | 区别           | 应用场景    |
| ------------- | ---------------------- | -------------- | ----------- |
| 防抖 debounce | 在事件频繁被触发的时候 | 只执行最后一次 | input输入   |
| 节流 throttle | 减少事件执行的次数     | 有规律的执行   | 拖拽,Scroll |

## 三. 代码实现

**防抖方法的实现**

```js
let input = document.querySelector('input')
        input.addEventListener('keyup', debounce(function () {
            console.log(input.value, '向后台取数据');
        })
        )
        // 手写一个防抖函数来解决重复请求后台服务器的问题
        function debounce(fn) {
            let timer = null;

            return function () {
                if (timer) clearTimeout(timer)

                timer = setTimeout(() => {
                    fn.apply(this, arguments)
                    timer = null;
                }, 1000)
            }
        }
复制代码
```

**上面代码的意思是:**

找到页面中第一个` input` 元素，添加一个 `"keyup" 事件监听器`，当用户输入内容时，使用`防抖函数 debounce `来限制事件的触发频率，每次事件`最多只被触发一次`。

防抖函数`返回一个新函数`，该函数会在一定时间内（这里是 1000 毫秒）不执行，在该时间内如果再次触发了该事件，会`清除之前的计时器`并重新设置计时器。当计时器结束后，才会执行传入的函数并向后台服务器请求数据，同时将 input 元素的值作为参数进行输出。

这样可以`防止用户输入过快或者频率过高`，导致向后台服务器`发送重复的请求`。

**节流函数代码的实现**

```js
   let box = document.querySelector('.box')
        box.addEventListener('drag', throttle(function (e) {
            console.log(e.clientX);
        }))

        function throttle(fn) {
            let timer = null;
            return function () {
                if (timer) return
                timer = setTimeout(() => {
                    fn.apply(this, arguments)
                    timer = null
                }, 100)
            }
        }
复制代码
```

**上面代码的意思:** 找到页面中 class 为 `"box" `的元素，添加一个 `"drag" 鼠标拖拽` 事件监听器，当用户拖动该元素时，使用`节流函数 throttle` 来限制事件的`触发频率`，`每100毫秒触发一次事件`，并在控制台输出鼠标的 x 坐标值。其中 throttle 函数返回一个新函数，该函数在 `timer 计时器未结束时不会执行`，从而实现了`事件的节流`。

## 四. 防抖效果图展示(前后对比)

**没有加防抖函数之间** ![1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb70c4f692f3492aaecc9b286185808e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?) **加了防抖函数之后**

![1.1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfa9312951454d35be1d9caf41b51b4f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

## 节流效果图展示(前后对比)

**没有加节流函数之间** ![2.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6740e84fe8e457487eca9599fb3b575~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

**加了节流函数之后** ![2.1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e9266b43583476aa348cb954a033c8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

## 五.总结

防抖函数的作用是在用户停止触发事件后，延迟一段时间再执行函数。这样可以避免频繁地执行一些计算量大或者请求量大的函数，比如自动保存、搜索建议等。

节流函数的作用是在一定时间间隔内，只执行一次函数。这样可以保证函数的执行速度不超过设定的频率，比如滚动事件、窗口大小调整等。

性能优化是把双刃剑，有好的一面也有坏的一面。好的一面就是能提升网站性能，坏的一面就是配置麻烦，或者要遵守的规则太多。并且某些性能优化规则并不适用所有场景，需要谨慎使用，请读者带着批判性的眼光来阅读本文。

本文相关的优化建议的引用资料出处均会在建议后面给出，或者放在文末。

### 1. 减少 HTTP 请求

一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。接下来看一个具体的例子帮助理解 HTTP ：

![在这里插入图片描述](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05c1c42e60734ecd8dc7db8f4a8443ce~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

这是一个 HTTP 请求，请求的文件大小为 28.4KB。

名词解释：

- Queueing: 在请求队列中的时间。
- Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。
- Proxy negotiation: 与代理服务器连接进行协商所花费的时间。
- DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。
- Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手/重试和协商SSL。
- SSL: 完成SSL握手所花费的时间。
- Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。
- Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。
- Content Download: 接收响应数据所花费的时间。

从这个例子可以看出，真正下载数据的时间占比为 `13.05 / 204.16 = 6.39%`，文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。

参考资料：

- [understanding-resource-timing](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fchrome-devtools%2Fnetwork%2Funderstanding-resource-timing)

### 2. 使用 HTTP2

HTTP2 相比 HTTP1.1 有如下几个优点：

#### 解析速度快

服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。

#### 多路复用

HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。

在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。 多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。

#### 首部压缩

HTTP2 提供了首部压缩功能。

例如有如下两个请求：

```makefile
:authority: unpkg.zhimg.com
:method: GET
:path: /za-js-sdk@2.16.0/dist/zap.js
:scheme: https
accept: */*
accept-encoding: gzip, deflate, br
accept-language: zh-CN,zh;q=0.9
cache-control: no-cache
pragma: no-cache
referer: https://www.zhihu.com/
sec-fetch-dest: script
sec-fetch-mode: no-cors
sec-fetch-site: cross-site
user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36
复制代码
:authority: zz.bdstatic.com
:method: GET
:path: /linksubmit/push.js
:scheme: https
accept: */*
accept-encoding: gzip, deflate, br
accept-language: zh-CN,zh;q=0.9
cache-control: no-cache
pragma: no-cache
referer: https://www.zhihu.com/
sec-fetch-dest: script
sec-fetch-mode: no-cors
sec-fetch-site: cross-site
user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36
复制代码
```

从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。

HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。

下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部：

```makefile
Header1:foo
Header2:bar
Header3:bat
复制代码
```

当客户端发送请求时，它会根据首部值创建一张表：

| 索引 | 首部名称 | 值   |
| ---- | -------- | ---- |
| 62   | Header1  | foo  |
| 63   | Header2  | bar  |
| 64   | Header3  | bat  |

如果服务器收到了请求，它会照样创建一张表。 当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块：

```
62 63 64
复制代码
```

服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。

#### 优先级

HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。

#### 流量控制

由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。

#### 服务器推送

HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。

例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。

现在有很多网站已经开始使用 HTTP2 了，例如知乎：

![在这里插入图片描述](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ecd41f4c08c419ca381f8907299e928~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

其中 h2 是指 HTTP2 协议，http/1.1 则是指 HTTP1.1 协议。

参考资料：

- [HTTP2 简介](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Fhttp2%2F%3Fhl%3Dzh-cn)
- [半小时搞懂 HTTP、HTTPS和HTTP2](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwoai3c%2FFront-end-articles%2Fblob%2Fmaster%2Fhttp-https-http2.md)

### 3. 使用服务端渲染

客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。

服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。

- 优点：首屏渲染快，SEO 好。
- 缺点：配置麻烦，增加了服务器的计算压力。

下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。

#### 客户端渲染过程

1. 访问客户端渲染的网站。
2. 服务器返回一个包含了引入资源语句和 `` 的 HTML 文件。
3. 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 `new Vue()` 开始实例化并渲染页面。

#### 服务端渲染过程

1. 访问服务端渲染的网站。
2. 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。
3. 当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 `new Vue()` 开始实例化并接管页面。

从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。

**这样做的好处是什么？是更快的内容到达时间 (time-to-content)**。

假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。

这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。**这就是服务端渲染更快的原因**。

参考资料：

- [vue-ssr-demo](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwoai3c%2Fvue-ssr-demo)
- [Vue.js 服务器端渲染指南](https://link.juejin.cn?target=https%3A%2F%2Fssr.vuejs.org%2Fzh%2F)

### 4. 静态资源使用 CDN

内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。

#### CDN 原理

当用户访问一个网站时，如果没有 CDN，过程是这样的：

1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。
3. 本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。

![img](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d25d1b0091b4e00ae51789172a46d2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

如果用户访问的网站部署了 CDN，过程是这样的：

1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。
3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。
4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。
5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。
6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。
7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。

![img](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67c19972e7dd4ae0840a0f838dd6a017~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

参考资料：

- [CDN是什么？使用CDN有什么优势？](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F36514327%2Fanswer%2F193768864)
- [CDN原理简析](https://juejin.im/post/6844903873518239752)

### 5. 将 CSS 放在文件头部，JavaScript 文件放在底部

- CSS 执行会阻塞渲染，阻止 JS 执行
- JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建

如果这些 CSS、JS 标签放在 HEAD 标签里，并且需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部（不阻止 DOM 解析，但会阻塞渲染），等 HTML 解析完了再加载 JS 文件，尽早向用户呈现页面的内容。

那为什么 CSS 文件还要放在头部呢？

因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。

另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。

参考资料：

- [使用 JavaScript 添加交互](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Fcritical-rendering-path%2Fadding-interactivity-with-javascript)

### 6. 使用字体图标 iconfont 代替图片图标

字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。

#### 压缩字体文件

使用 [fontmin-webpack](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpatrickhulce%2Ffontmin-webpack) 插件对字体文件进行压缩（感谢[前端小伟](https://juejin.im/user/237150239985165)提供）。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31d80f1553444be3a0b69a70eacc963b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

参考资料：

- [fontmin-webpack](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpatrickhulce%2Ffontmin-webpack)
- [Iconfont-阿里巴巴矢量图标库](https://link.juejin.cn?target=https%3A%2F%2Fwww.iconfont.cn%2F)

### 7. 善用缓存，不重复加载相同的资源

为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。

不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？

可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。

具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用[数据摘要要算法](https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%2F3286770%3Ffromtitle%3D%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%26fromid%3D12011257)对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。

参考资料：

- [webpack + express 实现文件精确缓存](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwoai3c%2Fnode-blog%2Fblob%2Fmaster%2Fdoc%2Fnode-blog7.md)
- [webpack-缓存](https://link.juejin.cn?target=https%3A%2F%2Fwww.webpackjs.com%2Fguides%2Fcaching%2F)
- [张云龙--大公司里怎样开发和部署前端代码？](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20790576%2Fanswer%2F32602154)

### 8. 压缩文件

压缩文件可以减少文件下载时间，让用户体验性更好。

得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。

在 webpack 可以使用如下插件进行压缩：

- JavaScript：UglifyPlugin
- CSS ：MiniCssExtractPlugin
- HTML：HtmlWebpackPlugin

其实，我们还可以做得更好。那就是使用 gzip 压缩。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。

gzip 是目前最流行和最有效的压缩方法。举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。

附上 webpack 和 node 配置 gzip 的使用方法。

**下载插件**

```css
npm install compression-webpack-plugin --save-dev
npm install compression
复制代码
```

**webpack 配置**

```ini
const CompressionPlugin = require('compression-webpack-plugin');

module.exports = {
  plugins: [new CompressionPlugin()],
}
复制代码
```

**node 配置**

```php
const compression = require('compression')
// 在其他中间件前使用
app.use(compression())
复制代码
```

### 9. 图片优化

#### (1). 图片延迟加载

在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。

首先可以将图片这样设置，在页面不可见时图片不会加载：

```html
<img data-src="https://avatars0.githubusercontent.com/u/22117876?s=460&u=7bd8f32788df6988833da6bd155c3cfbebc68006&v=4">
复制代码
```

等页面可见时，使用 JS 加载图片：

```js
const img = document.querySelector('img')
img.src = img.dataset.src
复制代码
```

这样图片就加载出来了，完整的代码可以看一下参考资料。

参考资料：

- [web 前端图片懒加载实现原理](https://juejin.im/entry/6844903482164510734)

#### (2). 响应式图片

响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。

通过 `picture` 实现

```html
<picture>
	<source srcset="banner_w1000.jpg" media="(min-width: 801px)">
	<source srcset="banner_w800.jpg" media="(max-width: 800px)">
	<img src="banner_w800.jpg" alt="">
</picture>
复制代码
```

通过 `@media` 实现

```html
@media (min-width: 769px) {
	.bg {
		background-image: url(bg1080.jpg);
	}
}
@media (max-width: 768px) {
	.bg {
		background-image: url(bg768.jpg);
	}
}
复制代码
```

#### (3). 调整图片大小

例如，你有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间。

所以，我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。还有一种办法，即对大图进行延迟加载，在所有元素都加载完成后手动更改大图的 src 进行下载。

#### (4). 降低图片质量

例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。

压缩方法有两种，一是通过 webpack 插件 `image-webpack-loader`，二是通过在线网站进行压缩。

以下附上 webpack 插件 `image-webpack-loader` 的用法。

```arduino
npm i -D image-webpack-loader
复制代码
```

webpack 配置

```js
{
  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
  use:[
    {
    loader: 'url-loader',
    options: {
      limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/
      name: utils.assetsPath('img/[name].[hash:7].[ext]')
      }
    },
    /*对图片进行压缩*/
    {
      loader: 'image-webpack-loader',
      options: {
        bypassOnDebug: true,
      }
    }
  ]
}
复制代码
```

#### (5). 尽可能利用 CSS3 效果代替图片

有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。

参考资料：

- [img图片在webpack中使用](https://juejin.im/post/6844903816081457159)

#### (6). 使用 webp 格式的图片

> WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。

参考资料：

- [WebP 相对于 PNG、JPG 有什么优势？](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F27201061)

### 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码

> 懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。

#### 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载

通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。

```js
output: {
	filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].js',
    path: path.resolve(__dirname, '../dist'),
},
复制代码
```

#### 提取第三方库

由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。 这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。

```js
optimization: {
  	runtimeChunk: {
        name: 'manifest' // 将 webpack 的 runtime 代码拆分为一个单独的 chunk。
    },
    splitChunks: {
        cacheGroups: {
            vendor: {
                name: 'chunk-vendors',
                test: /[\\/]node_modules[\\/]/,
                priority: -10,
                chunks: 'initial'
            },
            common: {
                name: 'chunk-common',
                minChunks: 2,
                priority: -20,
                chunks: 'initial',
                reuseExistingChunk: true
            }
        },
    }
},
复制代码
```

- test: 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String和Function;
- priority：表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算；
- reuseExistingChunk：表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。
- minChunks（默认是1）：在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）
- chunks (默认是async) ：initial、async和all
- name(打包的chunks的名字)：字符串或者函数(函数可以根据条件自定义名字)

#### 减少 ES6 转为 ES5 的冗余代码

Babel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数，比如：

```js
class Person {}
复制代码
```

会被转换为：

```js
"use strict";

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Person = function Person() {
  _classCallCheck(this, Person);
};
复制代码
```

这里 `_classCallCheck` 就是一个 `helper` 函数，如果在很多文件里都声明了类，那么就会产生很多个这样的 `helper` 函数。

这里的 `@babel/runtime` 包就声明了所有需要用到的帮助函数，而 `@babel/plugin-transform-runtime` 的作用就是将所有需要 `helper` 函数的文件，从 `@babel/runtime包` 引进来：

```js
"use strict";

var _classCallCheck2 = require("@babel/runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var Person = function Person() {
  (0, _classCallCheck3.default)(this, Person);
};
复制代码
```

这里就没有再编译出 `helper` 函数 `classCallCheck` 了，而是直接引用了 `@babel/runtime` 中的 `helpers/classCallCheck`。

**安装**

```bash
npm i -D @babel/plugin-transform-runtime @babel/runtime
复制代码
```

**使用** 在 `.babelrc` 文件中

```perl
"plugins": [
        "@babel/plugin-transform-runtime"
]
复制代码
```

参考资料：

- [Babel 7.1介绍 transform-runtime polyfill env](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fd078b5f3036a)
- [懒加载](https://link.juejin.cn?target=http%3A%2F%2Fwebpack.docschina.org%2Fguides%2Flazy-loading%2F)
- [Vue 路由懒加载](https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fguide%2Fadvanced%2Flazy-loading.html%23%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD)
- [webpack 缓存](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fguides%2Fcaching%2F)
- [一步一步的了解webpack4的splitChunk插件](https://juejin.im/post/6844903614759043079)

### 11. 减少重绘重排

**浏览器渲染过程**

1. 解析HTML生成DOM树。
2. 解析CSS生成CSSOM规则树。
3. 解析JS，操作 DOM 树和 CSSOM 规则树。
4. 将DOM树与CSSOM规则树合并在一起生成渲染树。
5. 遍历渲染树开始布局，计算每个节点的位置大小信息。
6. 浏览器将所有图层的数据发送给GPU，GPU将图层合成并显示在屏幕上。

![在这里插入图片描述](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e927ffe33f3d4bdba64e179e9c793bb9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**重排**

当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。

**重绘**

当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排 。

重排和重绘这两个操作都是非常昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。

什么操作会导致重排？

- 添加或删除可见的 DOM 元素
- 元素位置改变
- 元素尺寸改变
- 内容改变
- 浏览器窗口尺寸改变

如何减少重排重绘？

- 用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。
- 如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。

### 12. 使用事件委托

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

```js
<ul>
  <li>苹果</li>
  <li>香蕉</li>
  <li>凤梨</li>
</ul>

// good
document.querySelector('ul').onclick = (event) => {
  const target = event.target
  if (target.nodeName === 'LI') {
    console.log(target.innerHTML)
  }
}

// bad
document.querySelectorAll('li').forEach((e) => {
  e.onclick = function() {
    console.log(this.innerHTML)
  }
}) 
复制代码
```

### 13. 注意程序的局部性

一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用最近引用过的数据项附近的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。有良好局部性的程序比局部性差的程序运行得更快。

**局部性通常有两种不同的形式：**

- 时间局部性：在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。
- 空间局部性 ：在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。

时间局部性示例

```js
function sum(arry) {
	let i, sum = 0
	let len = arry.length

	for (i = 0; i < len; i++) {
		sum += arry[i]
	}

	return sum
}
复制代码
```

在这个例子中，变量sum在每次循环迭代中被引用一次，因此，对于sum来说，具有良好的时间局部性

空间局部性示例

**具有良好空间局部性的程序**

```js
// 二维数组 
function sum1(arry, rows, cols) {
	let i, j, sum = 0

	for (i = 0; i < rows; i++) {
		for (j = 0; j < cols; j++) {
			sum += arry[i][j]
		}
	}
	return sum
}
复制代码
```

**空间局部性差的程序**

```js
// 二维数组 
function sum2(arry, rows, cols) {
	let i, j, sum = 0

	for (j = 0; j < cols; j++) {
		for (i = 0; i < rows; i++) {
			sum += arry[i][j]
		}
	}
	return sum
}
复制代码
```

看一下上面的两个空间局部性示例，像示例中从每行开始按顺序访问数组每个元素的方式，称为具有步长为1的引用模式。 如果在数组中，每隔k个元素进行访问，就称为步长为k的引用模式。 一般而言，随着步长的增加，空间局部性下降。

这两个例子有什么区别？区别在于第一个示例是按行扫描数组，每扫描完一行再去扫下一行；第二个示例是按列来扫描数组，扫完一行中的一个元素，马上就去扫下一行中的同一列元素。

数组在内存中是按照行顺序来存放的，结果就是逐行扫描数组的示例得到了步长为 1 引用模式，具有良好的空间局部性；而另一个示例步长为 rows，空间局部性极差。

#### 性能测试

运行环境：

- cpu: i5-7400
- 浏览器: chrome 70.0.3538.110

对一个长度为9000的二维数组（子数组长度也为9000）进行10次空间局部性测试，时间（毫秒）取平均值，结果如下：

所用示例为上述两个空间局部性示例

| 步长为 1 | 步长为 9000 |
| -------- | ----------- |
| 124      | 2316        |

从以上测试结果来看，步长为 1 的数组执行时间比步长为 9000 的数组快了一个数量级。

总结：

- 重复引用相同变量的程序具有良好的时间局部性
- 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好；而在内存中以大步长跳来跳去的程序空间局部性会很差

参考资料：

- [深入理解计算机系统](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F26912767%2F)

### 14. if-else 对比 switch

当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。

```js
if (color == 'blue') {

} else if (color == 'yellow') {

} else if (color == 'white') {

} else if (color == 'black') {

} else if (color == 'green') {

} else if (color == 'orange') {

} else if (color == 'pink') {

}

switch (color) {
    case 'blue':

        break
    case 'yellow':

        break
    case 'white':

        break
    case 'black':

        break
    case 'green':

        break
    case 'orange':

        break
    case 'pink':

        break
}
复制代码
```

像上面的这种情况，从可读性来说，使用 switch 是比较好的（js 的 switch 语句不是基于哈希实现，而是循环判断，所以说 if-else、switch 从性能上来说是一样的）。

### 15. 查找表

当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。

```js
switch (index) {
    case '0':
        return result0
    case '1':
        return result1
    case '2':
        return result2
    case '3':
        return result3
    case '4':
        return result4
    case '5':
        return result5
    case '6':
        return result6
    case '7':
        return result7
    case '8':
        return result8
    case '9':
        return result9
    case '10':
        return result10
    case '11':
        return result11
}
复制代码
```

可以将这个 switch 语句转换为查找表

```js
const results = [result0,result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11]

return results[index]
复制代码
```

如果条件语句不是数值而是字符串，可以用对象来建立查找表

```js
const map = {
  red: result0,
  green: result1,
}

return map[color]
复制代码
```

### 16. 避免页面卡顿

**60fps 与设备刷新率**

> 目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。 其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。

![在这里插入图片描述](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5877fb299fb94e979551481dcf79e67f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

假如你用 JavaScript 修改了 DOM，并触发样式修改，经历重排重绘最后画到屏幕上。如果这其中任意一项的执行时间过长，都会导致渲染这一帧的时间过长，平均帧率就会下降。假设这一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。

对于一些长时间运行的 JavaScript，我们可以使用定时器进行切分，延迟执行。

```js
for (let i = 0, len = arry.length; i < len; i++) {
	process(arry[i])
}
复制代码
```

假设上面的循环结构由于 process() 复杂度过高或数组元素太多，甚至两者都有，可以尝试一下切分。

```js
const todo = arry.concat()
setTimeout(function() {
	process(todo.shift())
	if (todo.length) {
		setTimeout(arguments.callee, 25)
	} else {
		callback(arry)
	}
}, 25)
复制代码
```

如果有兴趣了解更多，可以查看一下[高性能JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwoai3c%2Frecommended-books%2Fblob%2Fmaster%2F%E5%89%8D%E7%AB%AF%2F%E9%AB%98%E6%80%A7%E8%83%BDJavaScript.pdf)第 6 章和[高效前端：Web高效编程与优化实践](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F30170670%2F)第 3 章。

参考资料：

- [渲染性能](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Frendering)

### 17. 使用 requestAnimationFrame 来实现视觉变化

从第 16 点我们可以知道，大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 `requestAnimationFrame`。

```js
/**
 * If run as a requestAnimationFrame callback, this
 * will be run at the start of the frame.
 */
function updateScreen(time) {
  // Make visual updates here.
}

requestAnimationFrame(updateScreen);
复制代码
```

如果采取 `setTimeout` 或 `setInterval` 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿。

![在这里插入图片描述](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/090488e1a87540558ffdeb8fb4fd157f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

参考资料：

- [优化 JavaScript 执行](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Frendering%2Foptimize-javascript-execution%3Fhl%3Dzh-cn)

### 18. 使用 Web Workers

Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。

Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。

创建一个新的 worker 很简单，指定一个脚本的 URI 来执行 worker 线程（main.js）：

```js
var myWorker = new Worker('worker.js');
// 你可以通过postMessage() 方法和onmessage事件向worker发送消息。
first.onchange = function() {
  myWorker.postMessage([first.value,second.value]);
  console.log('Message posted to worker');
}

second.onchange = function() {
  myWorker.postMessage([first.value,second.value]);
  console.log('Message posted to worker');
}
复制代码
```

在 worker 中接收到消息后，我们可以写一个事件处理函数代码作为响应（worker.js）：

```js
onmessage = function(e) {
  console.log('Message received from main script');
  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);
  console.log('Posting message back to main script');
  postMessage(workerResult);
}
复制代码
```

onmessage处理函数在接收到消息后马上执行，代码中消息本身作为事件的data属性进行使用。这里我们简单的对这2个数字作乘法处理并再次使用postMessage()方法，将结果回传给主线程。

回到主线程，我们再次使用onmessage以响应worker回传的消息：

```js
myWorker.onmessage = function(e) {
  result.textContent = e.data;
  console.log('Message received from worker');
}
复制代码
```

在这里我们获取消息事件的data，并且将它设置为result的textContent，所以用户可以直接看到运算的结果。

不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。

参考资料：

- [Web Workers](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWeb_Workers_API%2FUsing_web_workers)

### 19. 使用位操作

JavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。

##### 取模

由于偶数的最低位为 0，奇数为 1，所以取模运算可以用位操作来代替。

```js
if (value % 2) {
	// 奇数
} else {
	// 偶数 
}
// 位操作
if (value & 1) {
	// 奇数
} else {
	// 偶数
}
复制代码
```

##### 取整

```js
~~10.12 // 10
~~10 // 10
~~'1.5' // 1
~~undefined // 0
~~null // 0
复制代码
```

##### 位掩码

```js
const a = 1
const b = 2
const c = 4
const options = a | b | c
复制代码
```

通过定义这些选项，可以用按位与操作来判断 a/b/c 是否在 options 中。

```js
// 选项 b 是否在选项中
if (b & options) {
	...
}
复制代码
```

### 20. 不要覆盖原生方法

无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。

### 21. 降低 CSS 选择器的复杂性

#### (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。

看个示例

```css
#block .text p {
	color: red;
}
复制代码
```

1. 查找所有 P 元素。
2. 查找结果 1 中的元素是否有类名为 text 的父元素
3. 查找结果 2 中的元素是否有 id 为 block 的父元素

#### (2). CSS 选择器优先级

```
内联 > ID选择器 > 类选择器 > 标签选择器
复制代码
```

根据以上两个信息可以得出结论。

1. 选择器越短越好。
2. 尽量使用高优先级的选择器，例如 ID 和类选择器。
3. 避免使用通配符 *。

最后要说一句，据我查找的资料所得，CSS 选择器没有优化的必要，因为最慢和慢快的选择器性能差别非常小。

参考资料：

- [CSS selector performance](https://link.juejin.cn?target=https%3A%2F%2Fecss.io%2Fappendix1.html)
- [Optimizing CSS: ID Selectors and Other Myths](https://link.juejin.cn?target=https%3A%2F%2Fwww.sitepoint.com%2Foptimizing-css-id-selectors-and-other-myths%2F)

### 22. 使用 flexbox 而不是较早的布局模型

在早期的 CSS 布局方式中我们能对元素实行绝对定位、相对定位或浮动定位。而现在，我们有了新的布局方式 [flexbox](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FCSS%2FCSS_Flexible_Box_Layout%2FBasic_Concepts_of_Flexbox)，它比起早期的布局方式来说有个优势，那就是性能比较好。

下面的截图显示了在 1300 个框上使用浮动的布局开销：

![在这里插入图片描述](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8171c61cb63f4e599bd8e0144371f2dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

然后我们用 flexbox 来重现这个例子：

![在这里插入图片描述](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e95eca94007949ee8f0b4f5e7306bbf0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

现在，对于相同数量的元素和相同的视觉外观，布局的时间要少得多（本例中为分别 3.5 毫秒和 14 毫秒）。

不过 flexbox 兼容性还是有点问题，不是所有浏览器都支持它，所以要谨慎使用。

各浏览器兼容性：

- Chrome 29+
- Firefox 28+
- Internet Explorer 11
- Opera 17+
- Safari 6.1+ (prefixed with -webkit-)
- Android 4.4+
- iOS 7.1+ (prefixed with -webkit-)

参考资料：

- [使用 flexbox 而不是较早的布局模型](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Frendering%2Favoid-large-complex-layouts-and-layout-thrashing%3Fhl%3Dzh-cn)

### 23. 使用 transform 和 opacity 属性更改来实现动画

在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。

![在这里插入图片描述](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/675e5328a6e34e30af51e09689368f7d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

参考资料：

- [使用 transform 和 opacity 属性更改来实现动画](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Frendering%2Fstick-to-compositor-only-properties-and-manage-layer-count%3Fhl%3Dzh-cn)

### 24. 合理使用规则，避免过度优化

性能优化主要分为两类：

1. 加载时优化
2. 运行时优化

上述 23 条建议中，属于加载时优化的是前面 10 条建议，属于运行时优化的是后面 13 条建议。通常来说，没有必要 23 条性能优化规则都用上，根据网站用户群体来做针对性的调整是最好的，节省精力，节省时间。

在解决问题之前，得先找出问题，否则无从下手。所以在做性能优化之前，最好先调查一下网站的加载性能和运行性能。

##### 检查加载性能

一个网站加载性能如何主要看白屏时间和首屏时间。

- 白屏时间：指从输入网址，到页面开始显示内容的时间。
- 首屏时间：指从输入网址，到页面完全渲染的时间。

将以下脚本放在 `` 前面就能获取白屏时间。

```html
<script>
  new Date() - performance.timing.navigationStart
  // 通过 domLoading 和 navigationStart 也可以
  performance.timing.domLoading - performance.timing.navigationStart
</script>
复制代码
```

在 `window.onload` 事件里执行 `new Date() - performance.timing.navigationStart` 即可获取首屏时间。

##### 检查运行性能

配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。

打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。performance 的具体使用方法请用搜索引擎搜索一下，毕竟篇幅有限。

通过检查加载和运行性能，相信你对网站性能已经有了大概了解。所以这时候要做的事情，就是使用上述 23 条建议尽情地去优化你的网站，加油！

参考资料：

- [performance.timing.navigationStart](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformanceTiming%2FnavigationStart)

### 一、开场白

我个人认为性能优化可以从三个方面来进行，一是代码层面的优化，二是项目打包的优化，三是项目部署的优化。

开场白切记要简短，概况一下你接下来说的内容，不要长篇大论，面试官没那么多时间听你瞎扯。

下面教大家从常见优化一一说起。另外所有优化都是有原理，希望大家能接得住面试官的深层次的考察。

### 二、代码层面的优化

#### 1、利用v-if和v-show减少初始化渲染和切换渲染的性能开销

在页面加载时，利用v-if来控制组件仅在首次使用时渲染减少初始化渲染，随后用v-show来控制组件显示隐藏减少切换渲染的性能开销。

也许上面描述不够清楚，下面用一个实例来加深印象。

iview弹窗组件大家很经常用吧，弹窗组件是用v-show来控制其显示和隐藏，那么在页面加载时，弹窗组件（包括里面的内容）是会被初始化渲染的，如果一个页面中只有一个弹窗组件，不会对性能造成影响，但是假如一个页面中有几十个弹窗组件，会不会影响到性能，大家可以做一个右键菜单去试一下。

ps: 偷偷告诉大家，element弹窗组件初次渲染时，弹窗body里面的内容不会被渲染的。

下面用代码来实现一下。

```xml
<template>
    <div>
        <Button type="primary" @click.native="add">添加</Button>
        <add v-model="add.show" v-bind="add"></add>
    </div>
</template>
<script>
export default{
    data(){
        return{
            add:{
                show:false,
                init:false
            }
        }
    },
    components:{
        add:() =>import('./add.vue')
    },
    methods:{
        add(){
            this.add.show=true;
            this.add.init=true
        }
    }
}
</script>
复制代码
<template>
    <div v-if="init">
        <Modal v-model="show" title="添加" @on-cancel="handleClose"></Modal>
    </div>
</template>
<script>
export default{
    props:{
        value:{
            type:Boolean,
            default:false
        },
        init:{
            type:Boolean,
            default:false
        }
    },
    data(){
        return{
            show:false,
        }
    },
    watch:{
        value(val){
            if(val){
                this.show = val;
            }
        }  
    },
    methods:{
        handleClose(val) {
            this.$emit('input', val);
        },
    }
}
</script>
复制代码
```

**原理：**

> `v-if`绑定值为false时，初始渲染时，**不会**渲染其条件块。

> `v-if`绑定值，在true和false之间切换时，**会**销毁和重新渲染其条件块。

> `v-show`绑定值不管为true还是为false，初始渲染时，总是**会**渲染其条件块。

> `v-show`绑定值，在true和false之间切换时，**不会**销毁和重新渲染其条件块，只是用`display:none`样式来控制其显示隐藏。

#### 2、computed、watch、methods区分使用场景

对于有些需求，computed、watch、methods都可以实现，但是还是要区分一下使用场景。用错场景虽然功能实现了但是影响了性能。

- ```
  computed
  ```

  ： 

  - 一个数据受多个数据影响的。
  - 该数据要经过性能开销比较大的计算，如它需要遍历一个巨大的数组并做大量的计算才能得到，这时就可以利用`computed`的缓存特性，只有它计算时依赖的数据发现变化时才会重新计算，否则直接返回缓存值。

- ```
  watch
  ```

  ： 

  - 一个数据影响多个数据的。
  - 当数据变化时，需要执行异步或开销较大的操作时。如果数据变化时请求一个接口。

- ```
  methods
  ```

  ： 

  - 希望数据是实时更新，不需要缓存。

#### 3、提前处理好数据解决v-if和v-for必须同级的问题

因为当Vue处理指令时，`v-for`比`v-if`具有更高的优先级，意味着`v-if` 将分别重复运行于每个`v-for`循环中。

可以在computed中提前把要`v-for`的数据中`v-if`的数据项给过滤处理了。

```xml
//userList.vue
<template>
    <div>
        <div v-for="item in userList" :key="item.id" v-if="item.age > 18">{{ item.name }}</div>
    </div>
</template>
复制代码
//userList.vue
<template>
    <div>
        <div v-for="item in userComputedList" :key="item.id">{{ item.name }}</div>
    </div>
</template>
export default {
    computed:{
        userComputedList:function(){
            return this.userList.filter(function (item) {
                return item.age > 18
            })
        }
    }
}
复制代码
```

也许面试官还会为什么`v-for`比`v-if`具有更高的优先级？这个问题已经涉及到原理层次，如果这个也会回答，会给面试加分不少。

上面说到 “`v-if`将分别重复运行于每个`v-for`循环中”，这个过程只有在渲染页面时才有，而Vue最终是通过render函数来渲染页面的，先把组件编译生成的render打印出来。

```xml
//home.vue
<script>
import userList from './userList'
console.log(userList.render)
</script>
复制代码
```

打印出来的内容如下所示

```javascript
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    _vm._l(_vm.userList, function(item) {
      return item.age > 18
        ? _c("div", { key: item.id }, [_vm._v(_vm._s(item.name))])
        : _vm._e()
    }),
    0
  )
}
var staticRenderFns = []
render._withStripped = true
export { render, staticRenderFns }
复制代码
```

其中`_l`方法是`v-for`指令通过`genFor`函数生成的renderList方法，`item.age > 18? `是`v-if`指令通过`genIf`函数生成的三元运算符的代码，`_v`方法是createTextVNode方法用来创建文本节点，`_e`方式是createEmptyVNode方法用来创建空节点。到这里是不是已经很清楚，`v-if`运行在每个`v-for`中。

归根到底还是在生成render函数中，导致`v-for`比`v-if`具有更高的优先级，我们去render函数的生成过程中看一下。

Vue提供了2个版本，一个是Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 vue-loader 事先把模板编译成 render函数。

这里不研究vue-loader，所以用Runtime + Compiler来研究，也是用CDN引入Vue.js，此时Vue的入口在*src/platforms/web/entry-runtime-with-compiler.js*中。

```ini
const vm = new Vue({
    render: h => h(App)
}).$mount('#app')
复制代码
```

Vue实例是通过`$mount`挂载到DOM上。在入口文件中寻找`$mount`方法，在其方法中再找`render`字段，发现以下代码

```arduino
const { render, staticRenderFns } = compileToFunctions(template, {
    outputSourceRange: process.env.NODE_ENV !== 'production',
    shouldDecodeNewlines,
    shouldDecodeNewlinesForHref,
    delimiters: options.delimiters,
    comments: options.comments
}, this)
options.render = render
options.staticRenderFns = staticRenderFns
复制代码
```

说明render函数是通过compileToFunctions方法生成，再去寻找compileToFunctions方法在哪里。

compileToFunctions方法在*src/platforms/web/compiler/index.js*中定义。

```arduino
const { compile, compileToFunctions } = createCompiler(baseOptions)
export { compile, compileToFunctions }
复制代码
```

compileToFunctions方法又是createCompiler方法生成的，继续寻找createCompiler方法。

createCompiler方法在*src/compiler/index.js*中定义。

```scss
export const createCompiler = createCompilerCreator(
    function baseCompile(template,options) {
        const ast = parse(template.trim(), options)
        if (options.optimize !== false) {
            optimize(ast, options)
        }
        const code = generate(ast, options)
        return {
            ast,
            render: code.render,
            staticRenderFns: code.staticRenderFns
        }
})
复制代码
```

在上面代码中可以看到，render是code中的render，而code是generate方法生成的。

在这里额外提一下ast是什么，就是由tempalte生成的语法书，在执行generate方法前执行以下几个逻辑

- 解析模板字符串生成 ast `const ast = parse(template.trim(), options)`。
- 优化语法树 `optimize(ast, options)`。
- 生成render函数代码`const code = generate(ast, options)`。

继续寻找generate方法，其在*src/compiler/codegen/index.js*中定义。

```arduino
export function generate (ast,options){
    const state = new CodegenState(options)
    const code = ast ? genElement(ast, state) : '_c("div")'
    return {
        render: `with(this){return ${code}}`,
        staticRenderFns: state.staticRenderFns
    }
}
复制代码
```

发现code是genElement方法生成的，继续寻找genElement方法，其实这里已经解决根本原因了，给出几行关键代码。

```scss
export function genElement(el,state){
    if(){
    //...
    }else if (el.for && !el.forProcessed) {
        return genFor(el, state)
    } else if (el.if && !el.ifProcessed) {
        return genIf(el, state)
    } 
}
复制代码
```

由上述代码可以看出，el.for就是`v-for`，el.if就是`v-if`，el.for先于el.if判断执行，所以`v-for`比`v-if`具有更高的优先级。

另外在genFor方法最后面会继续调用genElement方法，形成一级一级往下执行。

```javascript
return `${altHelper || '_l'}((${exp}),` +
    `function(${alias}${iterator1}${iterator2}){` +
    `return ${(altGen || genElement)(el, state)}` +
'})'
复制代码
```

> 把寻找原因的整个思路都写出来，就是让小伙伴在看面试题时不要死记硬背，要去理解，可以按照上面的思路，自己去阅读源码找一下原因。毕竟阅读源码能力也是可以为面试加分的。

#### 4、给v-for循环项加上key提高diff计算速度

一旦你给面试官讲了此项优化，你要做好被面试官深入提问的准备如以下两个问题。

- 为什么加key会提高diff计算速度。

  经过旧头新头、旧尾新尾、旧头新尾、旧尾新头四次交叉比对后，都没有匹配到值得比对的节点，这时如果新节点有key的话。可以通过map直接获得值得对比的旧节点的下标，如果没有key的话，就要通过循环旧节点数组用sameVnode方法判断新节点和该旧节点是否值得比较，值得就返回该旧节点的下标。显然通过map比通过循环数组的计算速度来的快。

- 什么是diff计算。

  对于渲染watcher触发时会执行`vm._update(vm._render(), hydrating)`，在`vm._undata`方法中会调用`vm.__patch__`，而`vm.__patch__`指向patch方法，diff计算是指在调用patch方法开始，用sameVnode方法判断节点是否值得比较，若不值得直接新节点替换旧节点后结束。值得对比进入patchVnode方法，分别处理一下几种情况，若新旧节点都有文本节点，新节点下的文本节点直接替换旧节点下的文本节点，如果新节点有子节点，旧节点没有子节点，那么直接把新节点查到旧节点的父级中，如果新节点没有子节点，旧节点有子节点，那么旧节点的父级下的子节点都删了。如果新旧节点都有子节点，进入updateChildren方法，通过旧头新头、旧尾新尾、旧头新尾、旧尾新头四次交叉比对，如果值得对比再进入patchVnode方法，如果都不值得对比，有key用map获得值得对比的旧节点，没有key通过循环旧节点获得值得对比的旧节点。当新节点都对比完，旧节点还没对比完，将还没对比完的旧节点删掉。当旧节点都对比完，新节点还没对比完，将新节点添加到最后一个对比过的新节点后面，完成diff计算。

这两个问题是可以连续提问，一旦你答出第一个问题，可能会被继续深入提问第二个问题。

以下是详细过程，面试中也不可能表述那么详细。主要是提供给大家理解用。

首先介绍一下什么diff计算，diff计算就是对比新旧虚拟DOM（virtual DOM），virtual DOM是将真实的DOM的数据抽取出来，以对象的形式模拟树形结构，再说简白一点，diff计算就是对两个对象进行对比。

在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2434e64f4e114b66a506229959e54c5e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 先上步骤图，可以先看图，再看文字介绍 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3855e292967441f3b9d28e3cb6e341c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f6a50d6a3614a4ca366a138684f8bb3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) ![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/213b5ca1a7fb4a089b13c8734d6bd522~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) ![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4c54942bc1f4ce8b71892e299979b52~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) ![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/472639c8f3394f4994afcc9ad626f0ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5169774f27f349e58974aeead903b7ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 每次对比的逻辑大概如下所示

- 1、在patch方法内，用sameVnode判断新旧节点是否值得比较。
- 2、如果不值得比较，直接在旧节点的父级中添加新节点，然后删除旧节点，退出对比。
- 3、如果值得比较，调用patchVnode方法。
- 4、如果新旧节点是否完全相等，如果是，退出对比。
- 5、如果不是，找到对应的真实DOM，记为el。
- 6、如果新旧节点都有文本节点并且不相等，那么将el的文本节点设置为新节点的文本节点，退出对比。
- 7、如果新节点有子节点，旧节点没有子节点，则将新节点的子节点生成真实DOM后添加到el中，退出对比。
- 8、如果新节点没有子节点，旧节点有子节点，则删除el的子节点，退出对比。
- 9、如果新节点和旧节点都有子节点，则开始对比它们的子节点，用的是updateChildren方法。
- 10、将旧节点的子节点记为`oldCh`是个数组,其头部用`oldCh[oldStartIdx]`获取记为`oldStartVnode`，`oldStartIdx`初始为0。其尾部用`oldCh[oldEndIdx]`获取记为`oldEndVnode`，`oldEndIdx`初始为`oldCh.length - 1`。
- 11、将旧节点的子节点记为`newCh`是个数组,其头部用`newCh[newStartIdx]`获取记为`newStartVnode`，`newStartIdx`初始为0。其尾部用`newCh[newEndIdx]`获取记为`newEndVnode`，`newEndIdx`初始为`newCh.length - 1`。
- 12、将旧子节点的头部和新子节点的头部，简称旧头和新头用sameVnode判断是否值得比较。
- 13、如果值得比较，调用patchVnode方法，重新执行第3步。同时用`oldCh[++oldStartIdx]`重新获取旧子节点头部，用`newCh[++newStartIdx]`重新获取新子节点头部。
- 14、如果不值得比较，将旧子节点的尾部和新子节点的尾部，简称旧尾和新尾用sameVnode判断是否值得比较。
- 15、如果值得比较，调用patchVnode方法，重新执行第3步。同时用`oldCh[--oldEndIdx]`重新获取旧子节点尾部，重新用`newCh[--newEndIdx]`获取新子节点尾部。
- 16、如果不值得比较，将旧子节点的头部和新子节点的尾部，简称旧头和新尾用sameVnode判断是否值得比较。
- 17、如果值得比较，调用patchVnode方法，重新执行第3步。同时将旧子节点的头部`oldStartVnode`对应的真实DOM移动到旧子节点的尾部`oldEndVnode`对应的真实DOM后面。同时用`oldCh[++oldStartIdx]`重新获取旧子节点头部，用`newCh[--newEndIdx]`重新获取新子节点尾部。
- 18、如果不值得比较，将旧子节点的尾部和新子节点的头部，简称旧尾和新头用sameVnode判断是否值得比较。
- 19、如果值得比较，调用patchVnode方法，重新执行第3步。同时将旧子节点的尾部`oldEndVnode`对应的真实DOM移动到旧子节点的头部`oldStartVnode`对应的真实DOM后面。同时用`oldCh[--oldEndIdx]`重新获取旧子节点尾部，用`newCh[++newStartIdx]`重新获取新子节点头部。
- 20、如果不值得比较，如果旧子节点有key，可以用createKeyToOldIdx方法获得以旧子节点的key为健，其下标为值的map结构,记为`oldKeyToIdx`。
- 21、如果新子节点的头部`newStartVnode`有key属性，直接通过`oldKeyToIdx[newStartVnode.key]`获取对应的下标`idxInOld`。
- 22、如果新子节点的头部`newStartVnode`没有key属性，要用过findIdxInOld方法，找到值得对比的旧子节点对应的下标`idxInOld`。
- 23、经过查找。如果`idxInOld`不存在。则调用createElm方法直接生成`newStartVnode`对应的真实DOM插入`oldStartVnode`对应真实DOM前面。
- 24、如果`idxInOld`存在，则把用通过`oldCh[idxInOld]`获取到Vnode记为`vnodeToMove`和`newStartVnode`用sameVnode判断是否值得比较。
- 25、如果值得比较，调用patchVnode方法，重新执行第3步。同时执行`oldCh[idxInOld] = undefined`，免得被重复比较。同时将`vnodeToMove`对应的真实DOM移动到旧子节点的头部`oldStartVnode`对应的真实DOM前面。
- 26、如果不值得比较，则调用createElm方法直接生成`newStartVnode`对应的真实DOM插入`oldStartVnode`对应真实DOM前面。
- 27、用`newCh[++newStartIdx]`重新获取新子节点头部
- 28、如果满足`oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx`继续执行步骤9。
- 29、如果`oldStartIdx > oldEndIdx`，说明所有旧子节点已经都比对完了，还剩下未比对的新子节点都调用createElm方法生成对应的真实DOM，插到`newCh[newEndIdx + 1]`对应的真实DOM后面。
- 30、如果`newStartIdx > newEndIdx`，说明所有新子节点都比较完，那么还剩下的旧子节点都删除掉。

#### 5、利用v-once处理只会渲染一次的元素或组件

只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。

例如某个页面是合同范文，里面大部分内容从服务端获取且是固定不变，只有姓名、产品、金额等内容会变动。这时就可以把`v-once`添加到那些包裹固定内容的元素上，当生成新的合同可以跳过那些固定内容，只重新渲染姓名、产品、金额等内容即可。

和`v-if`一起使用时，`v-once`不生效。在`v-for`循环内的元素或组件上使用，必须加上key。

讲到此优化，要防止面试官问你`v-once`怎么实现只渲染一次元素或组件？

说到渲染应该和`render`函数有关，那要去生成`render`函数的地方去寻找答案。

在*src/compiler/codegen/index.js*中，找到genElement方法

```scss
else if (el.once && !el.onceProcessed) {若设置v-once，则调用genOnce()函数
    return genOnce(el, state)
 } 
复制代码
```

再看genOnce方法

```javascript
function genOnce(el, state){
    el.onceProcessed = true
    if (el.if && !el.ifProcessed) {//如果有定义了v-if指令
        //...
    } else if (el.staticInFor) {//如果是在v-for下面的元素或组件上
        //...
        return `_o(${genElement(el, state)},${state.onceId++},${key})`
    } else {
        return genStatic(el, state)
    }
}
复制代码
```

如果有定义`v-if`指令，如果`v-if`指令的值不存在，最后还是会调用genStatic方法。再看genStatic方法

```javascript
function genStatic(el, state) {
	//...
    state.staticRenderFns.push(`with(this){return ${genElement(el, state)}}`)
    return `_m(${state.staticRenderFns.length - 1}${el.staticInFor ? ',true' : ''})`
}
复制代码
```

其中_m方法就是*src\core\instance\render-helpers\render-static.js*中的renderStatic方法，这个方法就是`v-once`实现只渲染一次元素或组件的关键所在。

```kotlin
function renderStatic(index,isInFor){
    const cached = this._staticTrees || (this._staticTrees = [])
    let tree = cached[index]
    if (tree && !isInFor) {
        return tree
    }
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy,null,this)
 	return tree
}
复制代码
```

其中`cached`是带`v-once`的元素或组件渲染生成的虚拟DOM节点的缓存，如果某个虚拟DOM节点的缓存存在，且虚拟DOM节点不是在`v-for`中直接返回该虚拟DOM节点缓存，如果该虚拟DOM节点没有缓存，则调用`genStatic`方法中存在`staticRenderFns`数组中的渲染函数，渲染出虚拟DOM节点且存在`cached`，以便下次不用重新渲染直接返回该虚拟DOM节点，并同时调用`markOnce`方法在该虚拟DOM节点上加上`isOnce`标志，值为`true`。

如果有定义`v-for`，最终会调用`_o(${genElement(el, state)},${state.onceId++},${key})`,其中`_o`方法就是*src\core\instance\render-helpers\render-static.js*中的markOnce方法，其作用是在生成的虚拟DOM节点上加上`isOnce`标志，为true代表该虚拟DOM节点是静态节点，当 patch 时，会判断`vnode.isOnce`是否为`true`，为`true`时，直接返回旧节点，不进行比对，相当实现渲染一次。

#### 6、利用Object.freeze()冻结不需要响应式变化的数据

```!
Vue初始化过程中，会把data传入observe函数中进行数据劫持，把data中的数据都转换成响应式的。
复制代码
```

在observe函数内部调用defineReactive函数处理数据，配置getter/setter属性，转成响应式，如果使用`Object.freeze()`将data中某些数据冻结了，也就是将其configurable属性（可配置）设置为false。

defineReactive函数中有段代码，检测数据上某个key对应的值的configurable属性是否为false，若是就直接返回，若不是继续配置getter/setter属性。

```vbnet
export function defineReactive(obj,key,val,customSetter,shallow){
    //...
    const property = Object.getOwnPropertyDescriptor(obj, key)//获取obj[key]的属性
    if (property && property.configurable === false) {
        return
    }
    //...
}
复制代码
```

在项目中如果遇到不需要响应式变化的数据，可以用`Object.freeze()`把该数据冻结了，可以跳过初始化时数据劫持的步骤，大大提高初次渲染速度。

#### 7、提前过滤掉非必须数据，优化data选项中的数据结构

Vue初始化时，会将选项data传入observe函数中进行数据劫持，

```javascript
initData(vm){
    let data = vm.$options.data
    //...
    observe(data, true)
}
复制代码
```

在observe函数会调用

```scss
observe(value,asRootData){
   //...
   ob = new Observer(value);
}
复制代码
```

在Observer原型中defineReactive函数处理数据，配置getter/setter属性，转成响应式

```ini
walk (obj) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
        defineReactive(obj, keys[i])
    }
}
复制代码
```

defineReactive函数中,会将数据的值再次传入observe函数中

```scss
export function defineReactive(obj,key,val,customSetter,shallow){
    //...
    if (arguments.length === 2) {
        val = obj[key]
    }
    let childOb = observe(val);
    //...
}
复制代码
```

observe函数中有段代码，将数据传入，Observer类中。

```javascript
export function observe(value,asRootData){
  //...
  ob = new Observer(value)
  //...
  return ob
}
复制代码
```

以上构成了一个递归调用。

接收服务端传来的数据，都会有一些渲染页面时用不到的数据。服务端的惯例，宁可多传也不会少传。

所以要先把服务端传来的数据中那些渲染页面用不到的数据先过滤掉。然后再赋值到data选项中。可以避免去劫持那些非渲染页面需要的数据，减少循环和递归调用，从而提高渲染速度。

#### 8、避免在v-for循环中读取data中数组类型的数据

```vbnet
export function defineReactive(obj,key,val,customSetter,shallow){
    const dep = new Dep()
    const property = Object.getOwnPropertyDescriptor(obj, key)
    const getter = property && property.get;
    const setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
        val = obj[key]
    }
    let childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
        const value = getter ? getter.call(obj) : val
        if (Dep.target) {
            dep.depend()
            if (childOb) {
                childOb.dep.depend()
                if (Array.isArray(value)) {
                    dependArray(value)
                }
            }
        }
        return value
    }
    })
}
function dependArray (value: Array<any>) {
    for (let e, i = 0, l = value.length; i < l; i++) {
        e = value[i]
        e && e.__ob__ && e.__ob__.dep.depend()
        if (Array.isArray(e)) {
            dependArray(e)
        }
    }
}
export function observe (value, asRootData){
  	if (!isObject(value) || value instanceof VNode) {
    	return
  	}
  	//...
}
复制代码
```

为什么要避免在v-for循环中读取data中数组类型的数据，因为在数据劫持中会调用defineReactive函数中。由于 getter是函数，并且引用了 `dep`、`childOb`，形成了闭包，所以 `dep`、`childOb` 一直存在于内存（每个数据的getter函数）中，`dep`是每个数据的依赖收集容器，`childOb`是经过响应式处理后的数据。

在渲染视图、使用watch监听、使用计算属性过程中，读取数据，都会对`Dep.target`进行赋值，其值为Watcher（依赖），例如在渲染视图过程中读取数据时，`Dep.target`为renderWatcher。

接着先调用`dep.depend()`给自身收集依赖，如果val（自身的值）不是对象，则`childOb`为false。如果val（自身的值）是对象，用`childOb.dep.depend()`收集依赖，若value（自身的值）是数组用`dependArray(value)`递归每一项来收集依赖。

为什么要避免在v-for循环中读取data中数组类型的数据，其原因就是**若value（自身的值）是数组用`dependArray(value)`递归每一项来收集依赖**

举个简单的栗子，表格中每行有两个输入框，分别可以输入驾驶员和电话，代码这么实现。

```xml
<template>
    <div class="g-table-content">
        <el-table :data="tableData">
            <el-table-column prop="carno" label="车牌号"></el-table-column>
            <el-table-column prop="cartype" label="车型"></el-table-column>
            <el-table-column label="驾驶员">
                <template slot-scope="{row,column,$index}">
                    <el-input v-model="driverList[$index].name"></el-input>
                </template>
            </el-table-column>
            <el-table-column label="电话">
                <template slot-scope="{row,column,$index}">
                    <el-input v-model="driverList[$index].phone"></el-input>
                </template>
            </el-table-column>
        </el-table>
    </div>
</template>
复制代码
```

假设表格有500条数据，那么读取driverList共500次，每次都读取driverList都会进入`dependArray(value)`中，总共要循环500*500=25万次，若有分页，每次切换页码，都会至少循环25万次。

如果我们在从服务获取到数据后，做了如下预处理，在赋值给`this.tableData`，会是怎么样？

```ini
res.data.forEach(item =>{
    item.name='';
    item.phone='';
})
复制代码
```

模板这样实现

```xml
<template>
    <div class="g-table-content">
        <el-table :data="tableData">
            <el-table-column prop="carno" label="车牌号"></el-table-column>
            <el-table-column prop="cartype" label="车型"></el-table-column>
            <el-table-column label="驾驶员">
                <template slot-scope="{row}">
                    <el-input v-model="row.name"></el-input>
                </template>
            </el-table-column>
            <el-table-column label="电话">
                <template slot-scope="{row,column,$index}">
                    <el-input v-model="row.phone"></el-input>
                </template>
            </el-table-column>
        </el-table>
    </div>
</template>
复制代码
```

也可以实现需求，渲染过程中求值时也不会进入`dependArray(value)`中,也不会造成25万次的不必要的循环。大大提高了性能。

#### 9、防抖和节流

防抖和节流是针对用户操作的优化。首先来了解一下防抖和节流的概念。

- 防抖：触发事件后规定时间内事件只会执行一次。简单来说就是防止手抖，短时间操作了好多次。
- 节流：事件在规定时间内只执行一次。
- 应用场景： 节流不管事件有没有触发还是频繁触发，在规定时间内一定会只执行一次事件，而防抖是在规定时间内事件被触发，且是最后一次被触发才执行一次事件。假如事件需要定时执行，但是其他操作也会让事件执行，这种场景可以用节流。假如事件不需要定时执行，需被触发才执行，且短时间内不能执行多次，这种场景可以用防抖。

在用Vue Cli脚手架搭建的Vue项目中，可以通过引用Lodash工具库里面的debounce防抖函数和throttle节流函数。

```javascript
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
export default{
	methods:{
    	a: debounce(function (){
        	//...
        },200,{
            'leading': false,
            'trailing': true
        }),
        b: throttle(function (){
        	//...
        },200,{
            'leading': false,
            'trailing': true
        })
    }
}
复制代码
```

- `debounce(func, [wait=0], [options={}])` 创建一个防抖函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。返回一个防抖函数debounceFn，`debounce.cancel`取消防抖，`debounce.flush` 立即调用该func。
  - `options.leading`为true时，func在延迟开始前调用。
  - `options.trailing`为true时，func在延迟开始结束后调用。
  - `options.maxWait`设置func 允许被延迟的最大值。
- `throttle(func, [wait=0], [options={}])` 创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。 返回一个节流函数throttleFn，`throttleFn.cancel`取消节流，`throttleFn.flush` 立即调用该func。
  - `options.leading`为true时，func在节流开始前调用。
  - `options.trailing`为true时，func在节流结束后调用。
  - `leading`和`trailing`都为true，func在wait期间多次调用。

#### 10、图片大小优化和懒加载

关于图片大小的优化，可以用image-webpack-loader进行压缩图片，在webpack插件中配置，具体可以看本文中这点。

关于图片懒加载，可以用vue-lazyload插件实现。

执行命令`npm install vue-lazyload --save`安装vue-lazyload插件。在main.js中引入配置

```go
import VueLazyload from 'vue-lazyload';
Vue.use(VueLazyload, {
  preLoad: 1.3,//预载高度比例
  error: 'dist/error.png',//加载失败显示图片
  loading: 'dist/loading.gif',//加载过程中显示图片
  attempt: 1,//尝试次数
})
复制代码
```

在项目中使用

```ini
<img v-lazy="/static/img/1.png">
复制代码
```

#### 11、利用挂载节点会被替换的特性优化白屏问题

```javascript
import Vue from 'vue'
import App from './App.vue'
new Vue({
    render: h => h(App)
}).$mount('#app')
复制代码
```

> Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。

也就是说渲染时，会直接用render渲染出来的内容替换``。

Vue项目有个缺点，首次渲染会有一段时间的白屏原因是首次渲染时需要加载一堆资源，如js、css、图片。很多优化策略，最终目的是提高这些资源的加载速度。但是如果遇上网络慢的情况，无论优化到极致还是需要一定加载时间，这时就会出现白屏现象。

首先加载是index.html页面，其是没有内容，就会出现白屏。如果``里面有内容，就不会出现白屏。所以我们可以在``里添加首屏的静态页面。等真正的首屏加载出来后就会把``这块结构都替换掉，给人一种视觉上的误差，就不会产生白屏。

#### 11、组件库的按需引入

组件库按需引入的方法，一般文档都会介绍。

如element UI库，用babel-plugin-component插件实现按需引入。

执行命令`npm install babel-plugin-component --save-dev`，安装插件。

在根目录下.babelrc.js文件中按如下配置

```lua
{
  "presets": [["es2015", { "modules": false }]],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ]
  ]
}
复制代码
```

其中`libraryName`为组件库的名称，`styleLibraryName`为组件库打包后样式存放的文件夹名称。 在main.js中就可以按需引入。

```javascript
import Vue from 'vue';
import { Button, Select } from 'element-ui';
Vue.use(Button)
Vue.use(Select)
复制代码
```

其实babel-plugin-component插件是element用babel-plugin-import插件改造后特定给element UI使用。一般的组件库还是babel-plugin-import插件实现按需引入。

执行命令`npm install babel-plugin-import --save-dev`，安装插件。

在根目录下.babelrc.js文件中按如下配置

```json
{
  "plugins": [
    ["import", {
      "libraryName": "vant",
      "libraryDirectory": "es",
      "style": true
    }]
  ]
}
复制代码
```

其中`libraryName`为组件库的名称，`libraryDirectory`表示从库的package.json的main入口文件或者module入口文件所在文件夹名称，否则默认为lib。

在介绍`style`选项配置之前。先看一下Vant 组件库打包后生成文件的结构和内容。 ![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42990946918c4045b7d74ddba8eec282~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

index.js文件内容如下所示

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/defb215cea674b0ba2ae8a67888d870d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

less.js文件内容如下所示

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/553ce8c0e6a7401589f8c8f2e968c33d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

`style`为true时，会按需在项目中引入对应style文件中的index.js。

`style`为css时，会按需在项目中引入对应style文件中的less.js。

`style`为Function，babel-plugin-import将自动导入文件路径等于函数返回值的文件。这对于组件库开发人员很有用。 可以看我另一篇文章[Vue CLI3搭建组件库并实现按需引入实战操作](https://juejin.cn/post/6844904000655998984#heading-28)。

### 三、项目打包的优化

在说这个之前，先要明确什么是打包。通俗来说，就是把一个项目打包成一个个js文件、css文件等资源，最后在index.html文件中引入，大家可以看一下项目中dist文件夹中的index.html。

如下图,红框中就是一个项目通过打包出来的资源。其实说优化，就是优化这些资源。那么要怎么优化这些资源呢？ ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41e9c6bd76de45c4abd710c7e4654459~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 在早期没有Webpack时，这些资源都是开发者按照团队规范来处理和引入。并通过优化来实现最快的、最合理从服务器下载这些资源。这时期的优化主要体现在:

- js、css代码按需引入。
- js、css代码公用代码提取。
- js、css代码的最小化压缩。
- 图片资源的压缩。

现在项目是用Webpack打包的，可以通过配置Webpack来优化。

如果你的Vue项目是用Vue Cli3搭建起来，可以在根目录新建一个*vue.config.js*文件，在这个文件中配置Webpack来优化这些资源。

优化还是提现在上面四点。下面总结了5个优化手段，其中两个手段虽然在生产环境已经是默认优化的，但是还是要了解一下。

优化自然要前后对比，先安装插件webpack-bundle-analyzer，可以帮助你可视化的分析打包后的各个资源的大小。

```css
npm install webpack-bundle-analyzer --save-dev
复制代码
```

在*vue.config.js*中引入这插件

```ini
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
module.exports={
    configureWebpack:config =>{
        return {
            plugins:[
                new BundleAnalyzerPlugin()
            ]
        }
    }
}
复制代码
```

执行命令`npm run build`，会在浏览器打开一份打包分析图，如下图所示。 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbebd7b867534f6f947bc626b6725960~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 1、利用import()异步引入组件实现按需引入

说起`import()`，我们自然会想到路由懒加载，所谓的懒加载就是用`import()`异步引入组件。

在网上随便一搜，懒加载还可以通过`resolve =>require(['需要加载组件的地址'],resolve)`来实现。

```javascript
component: () =>import('views/home.vue'),
component: resolve =>require(['views/home.vue'],resolve)
复制代码
```

但是用`resolve =>require(['需要加载组件的地址'],resolve)`来异步引入组件，通过Webpack4打包后，发现所有组件的代码被打包成一个js文件这和预期的不符，预期应该是每个组件的代码都被打包成对应的js文件，加载组件时会对应加载js文件，这才是懒加载。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d260f74249948e980c212e26b2503a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

用`import()`来异步引入组件后，执行命令`npm run build`后，看一下打包分析图。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2469067189f9414890c8d2b66fc0c57b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

对比后发现，原来一个1.42MB的js文件不见了，被拆分成许多如32.55KB、31.69KB的js小文件。这些js小文件只有在对应的组件加载时才会加载，这才是懒加载。

或许你看这些js文件名会感到混乱，不能和项目中的组件一一对上，现在教你一个小技巧。[webpackChunkName](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fapi%2Fmodule-methods%2F%23magic-comments)：chunk文件的名称。[request]表示实际解析的文件名。

```javascript
function load(component) {
    return () => import(/* webpackChunkName: "[request]" */ `views/${component}`)
}
复制代码
```

执行命令`npm run build`，看一下打包分析图。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19ff6bb406cc4b24ad68218fb56dbb91~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 如图中红框的js文件是views/flow_card_manage/flow_card_list/index.vue这个组件打包出来的。

在浏览器上打开项目，用F12抓包看一下，搜一下`flow_card_manage-flow_card_list.67de1ef8.js`这个文件。在首页时，还没加载到这个路由组件时。这个js文件是有被加载，只是预取（prefetch）一下，没有返回内容的。目的是告诉浏览器，空闲的时候给我加载这个js文件。 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b65fb0b253dd4091ae5dacfa2de8e512~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/669a7734e900429a81005d5d9b4de352~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 直到真正加载这个路由组件时，这个js文件再次被加载，如果浏览器已经加载好了直接返回内容，如果浏览器还没加载好，就去服务器请求这个js文件，再返回内容。这样就是懒加载，按需加载。 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/090ca9ab658c4a00abc861782e9cd11e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) **原理：** 可以看一下我的另一篇文章[🚩四年前端带你理解路由懒加载的原理](https://juejin.cn/post/6844904180285456398)

#### 2、利用externals提取第三方依赖并用CDN引入

从打包分析图中可以发现chunk-vendors.js和chunk-80f6b79a.js这两个文件还是很大。这两个文件内有element-ui、jquery、xlsx等第三方依赖的资源。 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a0853dff9994f8f8987c4ac0d5035ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8e14d6f560c46789437ab7839e7b6a3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

在Webpack中的`externals`配置选项，可避免将第三方依赖打包，而是在项目运行时从外部获取第三方依赖。

具体操作可以看一下我的另一篇文章[Webpack之externals用法详解](https://juejin.cn/post/6844904190083350542)。

执行命令`npm run build`，看一下打包分析图。 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d59b4dafd304e92af593ee72a4de5f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) chunk-vendors.js和chunk-80f6b79a.js的文件大小和之前相比，有大幅度的减小。

> 用externals提取第三方依赖时，需切记中庸之道。虽然我们的最终目的是减少http请求资源大小，但是过犹不及，提取的过细将会增加http请求数量。

#### 3、利用SplitChunks插件提取公共js代码和分割js代码

用Webpack打包后，还是有很多资源被重复打包到各个js文件，可以用SplitChunks插件进一步优化，减少打包生成文件的总体大小。

另外CDN是第三方，具有不稳定性，万一CDN突然挂了，系统也就崩了，有一定的风险。也可以用SplitChunks插件实现`externals`配置的效果，第三方依赖还是在自己服务器上，减少风险。

具体操作可以看一下我的另一篇文章[Webpack之SplitChunks插件用法详解](https://juejin.cn/post/6844904198023168013)

#### 4、利用MiniCssExtractPlugin插件提取css样式

在用Vue Cli3搭建的Vue项目中是用`css.extract`来控制MiniCssExtractPlugin插件是否启用，虽然在生产环境中，`css.extract`默认是为`true`，也就是说MiniCssExtractPlugin插件是启用的。但是还是要熟悉一下MiniCssExtractPlugin插件的用法，以防面试官细问。

具体操作可以看一下我的另一篇文章[Webpack之MiniCssExtractPlugin插件用法详解](https://juejin.cn/post/6850418117500715015)。

#### 5、利用OptimizeCssnanoPlugin插件压缩和去重css样式文件

在用Vue Cli3搭建的Vue项目中默认是使用OptimizeCssnanoPlugin插件来压缩和去重css样式文件，

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01b2a9b813f444ed8893d377854fa9fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这里来讲一下怎么使用这款插件。 先安装OptimizeCssnanoPlugin插件

```css
cnpm install --save-dev @intervolga/optimize-cssnano-plugin
复制代码
```

在*vue.config.js*中这么配置

```javascript
const OptimizeCssnanoPlugin = require('@intervolga/optimize-cssnano-plugin');
module.exports={
    configureWebpack:config =>{
        return {
            plugins:[
                new OptimizeCssnanoPlugin({
                    sourceMap: false,
                    cssnanoOptions: {
                        preset: [
                            'default',
                            {
                              mergeLonghand: false,
                              cssDeclarationSorter: false
                            }
                        ]
                    },
                }),
            ]
        }
    }
}
复制代码
```

其中cssnanoOptions的配置可以看[这里](https://link.juejin.cn?target=https%3A%2F%2Fcssnano.co%2Fguides%2Foptimisations)。

`mergeLonghand:false`,表示关闭如margin，padding和border类似css样式属性合并。

```css
.box {
    margin-top: 10px;
    margin-right: 20px;
    margin-bottom: 10px;
    margin-left: 20px;
}
//压缩后
.box {
    margin: 10px 20px;
}
复制代码
```

`cssDeclarationSorter:false`，表示关闭根据CSS的属性名称对CSS进行排序。

```css
body {
   animation: none;
   color: #C55;
   border: 0;
}
//压缩后
body {
   animation: none;
   border: 0;
   color: #C55;
}
复制代码
```

#### 6、开启optimization.minimize来压缩js代码

`optimization.minimize`选项有两个值`true`和`false`，为`true`开启压缩js代码，为`false`关闭压缩js代码。

在生产环境中默认为`true`，在开发环境中默认为`false`。

如果你在开发环境不需要用debug调试代码，可以也设置为`true`来压缩js代码，提高页面加载速度。

在*vue.config.js*中这么配置

```arduino
module.exports={
    configureWebpack:config =>{
        return {
            optimization:{
                minimize: true
            }
        }
    }
}
复制代码
```

在Vue Cli3中默认用TerserPlugin插件来压缩js代码，其中配置已经是最优了。

如果想用其它插件来压缩js代码，可以在`optimization.minimizer`选项中添加，其值为数组。

用chainWebpack来添加，其中WebpackPlugin为插件名称，args为插件参数。

```ini
const WebpackPlugin = require(插件名称)
module.exports = {
    chainWebpack: config =>{
        config.optimization
            .minimizer(name)
            .use(WebpackPlugin, args)
    },
}
复制代码
```

#### 7、利用image-webpack-loader进行压缩图片

用Vue Cli3搭建的Vue项目中，图片是没进行压缩就直接用url-loader和file-loader处理。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c1cd91b0644744910f533943dfa361~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

优化一下用image-webpack-loader进行压缩图片后再给url-loader和file-loader处理。

在Vue Cli3已经配置了对图片处理的loader，要对其进行修改，具体方法可以看我另一篇文章[Webpack之loader配置详解](https://juejin.cn/post/6847902222873788430#heading-17)。

先安装image-webpack-loader

```arduino
cnpm install image-webpack-loader --save-dev
复制代码
```

然后在*vue.config.js*中这么配置

```arduino
module.exports = {
    chainWebpack: config =>{
        config.module
            .rule('images')
            .use('imageWebpackLoader')
            .loader('image-webpack-loader')
    },
}
复制代码
```

添加image-webpack-loader前，打包后 homeBg.png 图片 如下所示 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e45a80d6b544a09aaac542ecdea6961~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

添加image-webpack-loader后，打包后 homeBg.png 图片 如下所示 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c2d22c308d14358a63ea396eb5a0239~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

可以看到图片大小从251KB减少到110KB，优化效果明显。

[image-webpack-loader](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fimage-webpack-loader)支持压缩PNG，JPEG，GIF，SVG和WEBP图片，下面介绍一下其常用的参数。

- bypassOnDebug `ture/false`，默认为`false`，为`true`时禁用压缩图片，在[webpack@1.x](https://link.juejin.cn?target=mailto%3Awebpack%401.x)中使用。

- disable `ture/false`，默认为`false`，为`true`时禁用压缩图片，在[webpack@2.x](https://link.juejin.cn?target=mailto%3Awebpack%402.x)及更高版本中使用。 可以在开发环境中禁用压缩图片，使其编译速度更快。

  ```arduino
  module.exports = {
      chainWebpack: config =>{
          config.module
              .rule('images')
              .use('imageWebpackLoader')
              .loader('image-webpack-loader')
              .options({
                  disable: process.env.NODE_ENV === 'development',
              })
      },
  }
  复制代码
  ```

- mozjpeg：  控制压缩JPEG图像的配置，默认启用。参数值为对象，常用的子参数有：

  - quality 压缩质量，范围0（最差）至100（最完美）。

- optipng：控制压缩PNG图像的配置，默认启用。参数值为对象，常用的子参数有：

  - OptimizationLevel 优化级别，在0和7之间选择一个优化级别，数值越高，压缩质量越好，但是速度越慢，默认为3。

- pngquant：控制压缩PNG图像的配置，默认启用。参数值为对象，常用的子参数有：

  - speed 压缩速度，在1到11，数值越高，压缩速度越快，默认值为4。值为10时质量降低5％，但比默认速度快8倍。
  - quality 压缩质量，值为数组，如`[0 , 1]`，最小值是0（最差）和最大值是1（完美）。

- gifsicle：控制压缩GIF图像的配置，默认启用。参数值为对象，常用的子参数有: -OptimizationLevel 优化级别，在1和3之间选择一个优化级别，优化级别确定完成多少优化；较高的水平需要更长的时间，但可能会有更好的效果。

- webp： 将JPG和PNG图像压缩为WEBP，默认不启用，需要配置后才启用。启用后，可以将JPG和PNG图像压缩输出大小更小的图片，但比用mozjpeg、optipng、pngquant压缩更耗时，会影响编译打包速度，需自己取舍。

  参数值为对象，常用的子参数有

  - quality 品质因数，在0和之间100设置，默认为75，值越高品质越好。
  - lossless 是否无损压缩，默认为false，为true时开启无损压缩。
  - nearLossless 使用额外的有损预处理步骤进行无损编码，其品质因数介于0（最大预处理）和100（等于lossless）之间。

```php
module.exports = {
    chainWebpack: config =>{
        config.module
            .rule('images')
            .use('imageWebpackLoader')
            .loader('image-webpack-loader')
            .options({
                disable: process.env.NODE_ENV === 'development',
                mozjpeg:{
                    quality:75
                },
                optipng:{
                    OptimizationLevel:3
                },
                pngquant:{
                    speed:4,
                    quality:[0.2,0.5]
                },
                gifsicle:{
                    OptimizationLevel:1
                },
                webp:{
                    quality:75,
                    lossless:true,
                    nearLossless:75
                }
            })
    },
}
复制代码
```

### 四、项目部署的优化

这里只讲一个比较常见和简单的优化手段，gzip压缩。其实还有其他优化手段，涉及到服务端，如果面试官深究会其反作用。

#### 1、识别gzip压缩是否开启

这个很简单，只要看响应头部（Response headers）中 有没有`Content-Encoding: gzip`这个属性即可，有代表有开启gzip压缩。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d251ee56f34c42fca4027794c7138062~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 2、在Nginx上开启gzip压缩

在nginx/conf/nginx.conf中配置

```ini
http {
    gzip  on;
    gzip_min_length 1k;
    gzip_comp_level 5;
    gzip_types application/javascript image/png image/gif image/jpeg text/css text/plain;
    gzip_buffers 4 4k;
    gzip_http_version 1.1;
    gzip_vary on;
}
复制代码
```

- `gzip`：on | off ，默认为off，on为开启gzip，off为关闭gzip。
- `gzip_min_length`：number，压缩起点，文件大于多少才进行压缩，单位默认为字节，也可用k表示千字节。
- `gzip_comp_level`：压缩级别，1-9，数字越大，压缩后的大小越小，也越占用CPU，花费时间越长。
- `gzip_types`：需要进行压缩的文件类型。类型去Response headers中看Content-Type属性。
- `gzip_buffers`：number size，设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 例如 4 4k代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。如原始数据大小为17K，则申请 （17/4）*4 = 17k内存。
- `gzip_http_version`：设置gzip压缩针对的HTTP协议版本以上。
- `gzip_vary`：on | off，是否在http header中添加Vary:Accept-Encoding，on表示添加。Vary:Accept-Encoding告诉代理服务器缓存两种版本的资源：压缩和非压缩，避免一个浏览器不支持压缩资源，而先请求了服务器，服务器缓存了非压缩的资源，然后一个浏览器支持压缩资源，再去请求了服务器，结果得到非压缩资源，但是又去解压它，结果会出错。所以建议设置为on。

开启gzip压缩前 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f23b7e864eb84b1b9e02126abe053680~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 开启gzip压缩后

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c65180c285d436eb39856d97ef72f02~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

对比一下，优化效果非常明显。自己也可以在本地尝试一下，怎么用Nginx部署Vue项目可以看我[这篇文章](https://juejin.cn/post/6844903974697435150)。

#### 3、在Webpack上开启gzip压缩

利用CompressionWebpack插件来实现gzip压缩。

首先安装CompressionWebpack插件

```css
npm install compression-webpack-plugin --save-dev
复制代码
```

然后在*vue.config.js*中这么配置

```ini
const CompressionPlugin = require('compression-webpack-plugin');
module.exports = {
    configureWebpack: config =>{
        return {
            plugins: [
                new CompressionPlugin()
            ],
        }
    }
}
复制代码
```

执行`npm run build`命令后，打开*dist*文件，会发现多出很多名字相同的文件，只是其中一个文件后缀为`.gz`，这就是用gzip压缩后的文件。 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52c0d290451147229d0bb6d81eb9f671~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 4、Nginx和Webpack压缩的区别

- 不管Nginx还是Webpack压缩，在Nginx中都要开启gzip压缩，不然浏览器加载还是未压缩的资源。

  还可以在Nginx加上`gzip_static on;`的配置。`gzip_static`启用后， 浏览器请求资源时，Nginx会先检查是否存该资源名称且后缀为`.gz`的文件，如果有则直接返回该gz文件内容，可以避免Nginx对该资源再进行gzip压缩，浪费服务器的CPU。

- 用Nginx压缩会占用服务器的CPU，浏览器每次请求资源，Nginx会对该资源实时压缩，压缩完毕后才会返回该资源，如果资源很大的话，还是压缩级别设置很高，都会导致返回资源的时间过长，造成不好的用户体验。

- 用Webpack会使打包时间变长。但是用CompressionPlugin插件压缩，会有缓存，可以相对减少打包时间。

- 建议Nginx和Webpack压缩都开启压缩，且在Nginx加上`gzip_static on;`的配置，减少服务器的CPU的使用，当然还是要根据项目的情况实际选择。

#### 5、CompressionPlugin插件的参数详细详解

- ```
  test
  ```

  ：String|RegExp|Array<String|RegExp>，

  资源的名称

  符合条件的才会被压缩，默认为undefined，即全部符合，例如只要压缩js文件 

  ```css
  plugins: [
      new CompressionPlugin({
          test: /\.js(\?.*)?$/i,
      })
  ],
  复制代码
  ```

- `include`：String|RegExp|Array<String|RegExp>，**资源的名称**符合条件的才会被压缩，默认为undefined，是在`test`参数的范围内在进行筛选，满足`test`参数的条件，且满足`include`参数的条件的资源才会被压缩。

- `exclude`：String|RegExp|Array<String|RegExp>，压缩时排除**资源的名称**符合条件的资源，默认为undefined，是在`test`参数的范围内在进行排除，满足`test`参数的条件，不满足`exclude`参数的条件的资源才会被压缩。

- `algorithm`：压缩算法/功能，默认gzip，一般不做更改。

- ```
  compressionOptions
  ```

  ，对

  ```
  algorithm
  ```

  参数所选用的压缩功能的参数设置，一般用来设置压缩级别，1-9，数字越大，压缩后的大小越小，也越占用CPU，花费时间也越长。 

  ```css
  plugins: [
      new CompressionPlugin({
          compressionOptions: { level: 1 },
      })
  ],
  复制代码
  ```

- `threshold`：Number，设置被压缩资源的最小大小，单位为字节。默认为0。

- `minRatio`：Number，设置压缩比率，压缩比率 = 压缩后的资源的大小/压缩后的资源，小于压缩比率的资源才会被压缩。和`threshold`参数是‘与’的关系。

- `filename`：类型：String|Function，设置压缩资源后的名称，默认值：[path].gz[query]， [file]被替换为原始资产文件名。 [path]替换为原始资产的路径。 [dir]替换为原始资产的目录。 [name]被替换为原始资产的文件名。 [ext]替换为原始资产的扩展名。 [query]被查询替换。 下面用函数把各类的值都打印出来。

```javascript
 new CompressionPlugin({
    filename(info) {
        console.log(info)
        return `${info.path}.gz${info.query}`;
    },
})
复制代码
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b24d3455d8364959bf7468a89b628207~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

- `deleteOriginalAssets`：Boolean，默认为`false`，为`true`时删除原始资源文件。不建议设置。
- `cache`：Boolean|String，默认为`true`，为`true`时，启用文件缓存。缓存目录的默认路径：*node_modules/.cache/compression-webpack-plugin*。值为String时。启用文件缓存并设置缓存目录的路径。

```arduino
new CompressionPlugin({
      cache: 'path/to/cache',
}),
```



# 0 前言

在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。**其中提高网页反应速度的一个方式就是使用缓存**。缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。

一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。

所以，缓存技术是无数WEB开发从业人员在工作过程中不可避免的一大问题。**在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度**。了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。

# 1 WEB缓存体系

在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，**每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟**，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。所以，我们首先看下各层的缓存都有哪些技术，都缓存哪些数据，从整体上，对WEB的缓存技术进行了解，如下图所示：



![WEB各层缓存技术体系](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74ced1550cb8~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



本篇文章重点讲的就是上面红色框部分缓存内容。

# 2 认识浏览器缓存

当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。

> 这些被浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）。

那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：



![浏览器缓存示例](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74ced0854320~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分size有具体数值，然而还有一部分请求，比如图片、css和js等文件并没有显示文件大小，而是显示了 `from dis cache` 或者 `from memory cache` 字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。

浏览器启用缓存至少有两点显而易见的好处：**（1）减少页面加载时间；（2）减少服务器负载；**

**浏览器是否使用缓存、缓存多久，是由服务器控制的**。准确来说，当浏览器请求一个网页（或者其他资源）时，**服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息**。下面看下，HTTP报文中与缓存相关的首部字段：

1. **通用首部字段**（就是请求报文和响应报文都能用上的字段）

   

   ![通用首部字段](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74ced137bcc2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

2. **请求首部字段**

   

   ![请求首部字段](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74ced09f1146~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

3. **响应首部字段**

   

   ![响应首部字段](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74ced1676641~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

4. **实体首部字段**

   

   ![实体首部字段](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74cedc1725cf~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

# 3 浏览器缓存机制

根据上面四种类型的首部字段不同使用策略，**浏览器中缓存可分为强缓存和协商缓存**：

> 1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，**强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器**。比如：某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；
>
> 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，**通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存**，如果协商缓存命中，服务器会将这个请求返回，**但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源**，于是浏览器就又会从自己的缓存中去加载这个资源；
>
> 3）强缓存与协商缓存的共同点是：**如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据**；区别是：**强缓存不发请求到服务器，协商缓存会发请求到服务器**。
>
> 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

## 3.1 强缓存：Expires&Cache-Control

当浏览器对某个资源的请求命中了强缓存时，**返回的HTTP状态为200**，在chrome的开发者工具的network里面 **size会显示为from cache**，比如：京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的：



![命中强缓存](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74cef1897f96~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



> **强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期**。

**Expires是HTTP 1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示**，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，包含了Expires头标签的文件，就说明浏览器对于该文件缓存具有非常大的控制权。

例如，一个文件的Expires值是2020年的1月1日，那么就代表，在2020年1月1日之前，浏览器都可以直接使用该文件的本地缓存文件，而不必去服务器再次请求该文件，哪怕服务器文件发生了变化。

所以，**Expires是优化中最理想的情况，因为它根本不会产生请求**，所以后端也就无需考虑查询快慢。它的缓存原理，如下：

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Expires的header，如：

   

   ![response的header加上Expires](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74cf04b04c8a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；

3. 浏览器再请求这个资源时，**先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较**，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；

4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新；

Expires是较老的强缓存管理header，**由于它是服务器返回的一个绝对时间**，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，**比如：随意修改下客户端时间，就能影响缓存命中的结果**。所以在HTTP 1.1的时候，提出了一个新的header，**就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示**，如：Cache-Control:max-age=315360000，它的缓存原理是：

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header，如：

   

   ![response的header加上Cache-Control](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74cf19190d29~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；

3. 浏览器再请求这个资源时，**先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期**，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；

4. 如果缓存没有命中，浏览器直接从服务器加载资源时，**Cache-Control Header在重新加载的时候会被更新**；

**Cache-Control描述的是一个相对时间**，在进行缓存命中的时候，**都是利用客户端时间进行判断**，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。

这两个header可以只启用一个，也可以同时启用，**当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires**：



![Cache-Control优先级高于Expires](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74cf18869548~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



此外，还可以为 Cache-Control 指定 `public` 或 `private` 标记。**如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源**。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。**对于 public，则允许所有服务器缓存该资源**。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），**Cache-Control 默认设为 public 是合理的**。

## 3.2 协商缓存：Last-Modified&Etag

当浏览器对某个资源的请求没有命中强缓存，**就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串**，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：



![命中协商缓存](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74cf1570ab4b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



查看单个请求的Response Header，**也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的**，而不是服务器最新的资源：



![命中协商缓存 304 Not Modified](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d0451f2563~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



> **协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的**。

**【Last-Modified，If-Modified-Since】的控制缓存的原理，如下**：

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，**在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间**：

   

   ![response的header加上Last-Modified](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d0480c1ca9~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

2. 浏览器再次跟服务器请求这个资源时，**在request的header上加上If-Modified-Since的header**，这个header的值就是上一次请求时返回的Last-Modified的值：

   

   ![request的header上加上If-Modified-Since](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d05d4fbf77~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

3. 服务器再次收到资源请求时，**根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化**，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。**当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header**，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：

   

   ![服务器响应304 Not Modified](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d05d37cc80~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

4. 浏览器收到304的响应后，就会从缓存中加载资源。

5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，**Last-Modified Header在重新加载的时候会被更新**，下次请求时，**If-Modified-Since会启用上次返回的Last-Modified值**。

【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，**在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况**，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。**所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】**。它们的缓存管理的方式是：

1. 浏览器第一次跟服务器请求一个资源，**服务器在返回这个资源的同时，在response的header加上ETag的header**，这个header是服务器根据当前请求的资源生成的一个唯一标识，**这个唯一标识是一个字符串，只要资源有变化这个串就不同**，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：

   

   ![在response的header加上ETag](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d0e587fdf5~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

2. 浏览器再次跟服务器请求这个资源时，**在request的header上加上If-None-Match的header**，这个header的值就是上一次请求时返回的ETag的值：

   

   ![在request的header上加上If-None-Match](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d05d5f4171~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

3. 服务器再次收到资源请求时，**根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag**，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，**由于ETag重新生成过，response header中还会把这个ETag返回**，即使这个ETag跟之前的没有变化：

   

   ![由于ETag重新生成过，response header中还会把这个ETag返回](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d0e5592563~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

   

4. 浏览器收到304的响应后，就会从缓存中加载资源。

Etag和Last-Modified非常相似，都是用来判断一个参数，从而决定是否启用缓存。**但是ETag相对于Last-Modified也有其优势，可以更加准确的判断文件内容是否被修改**，从而在实际操作中实用程度也更高。

协商缓存跟强缓存不一样，强缓存不发请求到服务器，**所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器**，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:



![同时开启Etag和Last-Modified](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d0e536d23e~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。

【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：

> **分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败**；
>
> **分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）**；

比如，京东页面的资源请求，返回的repsonse header就只有Last-Modified，没有ETag：



![repsonse header只开启Last-Modified](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d0e57befb2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



协商缓存需要配合强缓存使用，上面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，**因为如果不启用强缓存的话，协商缓存根本没有意义**。

# 4 缓存判断流程

如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。其浏览器判断缓存的详细流程图，如下：



![浏览器缓存判断流程](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/8/165b74d0e55dda0b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



# 5 其他参考资料

1. [浅谈Web缓存](https://link.juejin.cn?target=http%3A%2F%2Fwww.alloyteam.com%2F2016%2F03%2Fdiscussion-on-web-caching)
2. [浅谈浏览器http的缓存机制](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fvajoy%2Fp%2F5341664.html)



在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。那么下面我们就来看看服务器端缓存的原理。

 



# 缓存分类 

web 缓存分为很多种，比如数据库缓存、代理服务器缓存、还有我们熟悉的 CDN 缓存，以及浏览器缓存。对于太多文字的阅读其实我是拒绝的，于是就画了个图来解释下。

浏览器通过代理服务器向源服务器发起请求的原理如下图，

[![图片1](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8715.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/图片15.png)

浏览器先向代理服务器发起 Web 请求，再将请求转发到源服务器。它属于共享缓存，所以很多地方都可以使用其缓存资源，因此对于节省流量有很大作用。

浏览器缓存是将文件保存在客户端，在同一个会话过程中会检查缓存的副本是否足够新，在后退网页时，访问过的资源可以从浏览器缓存中拿出使用。通过减少服务器处理请求的数量，用户将获得更快的体验

下面我就来着重讲下传说中的浏览器缓存。

 

# 浏览器缓存 

页面的缓存状态是由 header 决定的，header 的参数有四种：

一、**Cache-Control**：

  1、**max-age**（单位为 s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了。

我们来找个资源看下。比如 shang.qq.com 上的 css 资源，max-age=2592000，也就是说缓存有效期为 2592000 秒（也就是 30 天）。于是在 30 天内都会使用这个版本的资源，即使服务器上的资源发生了变化，浏览器也不会得到通知。max-age 会覆盖掉 Expires，后面会有讨论。

[![图片2](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8722.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/图片22.png)

 

  2、**s-maxage**（单位为 s）同 max-age，只用于共享缓存（比如 CDN 缓存）。

比如，当 s-maxage=60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不会进行请求。也就是说 max-age 用于普通缓存，而 s-maxage 用于代理缓存。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。

  3、**public** 指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定 public 还是 private，则默认为 public。

[![9](http://www.alloyteam.com/wp-content/uploads/2016/03/9.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/9.png)

  4、**private** 响应只作为私有的缓存（见下图），不能在用户间共享。如果要求 HTTP 认证，响应会自动设置为 private。

[![10](http://www.alloyteam.com/wp-content/uploads/2016/03/10.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/10.png)

  5、**no-cache** 指定不缓存响应，表明资源不进行缓存，比如，

[![图片3](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8733.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/图片33.png)

但是设置了 no-cache 之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置 no-cache 防止缓存还是不够保险，还可以加上 private 指令，将过期时间设为过去的时间。

  6、**no-store** 绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存啦～每次请求资源都要从服务器重新获取。

  7、**must-revalidate** 指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。

二、**Expires**

​    缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用。但在上面我们提到过，cache-control 的优先级更高。 Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

[![11](http://www.alloyteam.com/wp-content/uploads/2016/03/11.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/11.png)

三、**Last-modified** 

​    服务器端文件的最后修改时间，需要和 cache-control 共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送 If-Modified-Since 报头，询问 Last-Modified 时间点之后资源是否被修改过。如果没有修改，则返回码为 304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为 200，资源为服务器最新资源。

如下图，最后修改时间为 2014 年 12 月 19 日星期五 2 点 50 分 47 秒

[![图片4](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8741.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/图片41.png)

四、**ETag**

​     根据实体内容生成一段 hash 字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下：

[![12](http://www.alloyteam.com/wp-content/uploads/2016/03/12.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/12.png)

使用 ETag 可以解决 Last-modified 存在的一些问题：

  a、某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 

  b、如果资源修改非常频繁，在秒以下的时间内进行修改，而 Last-modified 只能精确到秒 

  c、一些资源的最后修改时间改变了，但是内容没改变，使用 ETag 就认为资源还是没有修改的。

 

# 使用缓存流程 

还是用图说话，下面是我所总结的从浏览器请求到展示资源的过程：

[![图片6](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8761.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/图片61.png)

 

 



# cache-control 指令使用 

说了那么多 cache-control 的指令，那么如何选择使用哪些指令呢？我还是不说话==

[![图片5](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8751.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/图片51.png)

 

**额外的**

除了开头提到的那么多缓存方式以外，还有一种我们都熟悉的缓存方式，LocalStorage 和 sessionStorage（好像是两种 23333）。

LocalStorage 是一种本地存储的公共资源，域名下很多应用共享这份资源会有风险；LocalStorage 是以页面域名划分的，如果有多个等价域名之间的 LocalStorage 不互通，则会造成缓存多份浪费。

LocalStorage 在 PC 上的兼容性不太好，而且当网络速度快、协商缓存响应快时使用 localStorage 的速度比不上 304。并且不能缓存 css 文件。而移动端由于网速慢，使用 localStorage 要快于 304。

 

在 html 中加载一个 png 图，首次加载的时候时间如下图，

[![图片7](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8771.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/图片71.png)

然而将图片使用了 LocalStorage 存储后，再次刷新后加载时间为 0。

[![图片8](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8781.png)](http://www.alloyteam.com/wp-content/uploads/2016/03/图片81.png)

而相对 LocalStorage 来说，SessionStorage 的数据只存储到特定的会话中，不属于持久化的存储，所以关闭浏览器会清除数据。和 localstorage 具有相同的方法。

 

在前端开发中缓存是必不可少的，那么使用怎样的缓存方式更高效、让我们项目的性能更优，还是需要我们仔细斟酌。

针对浏览器的http缓存的分析也算是老生常谈了，每隔一段时间就会冒出一篇不错的文章，其原理也是各大公司面试时几乎必考的问题。

之所以还写一篇这样的文章，是因为近期都在搞新技术，想“回归”下基础，也希望尽量总结的更详尽些。

那么你是否还需要阅读本篇文章呢？可以试着回答下面这个问题：

我们在访问百度首页的时候，会发现不管怎么刷新页面，静态资源基本都是返回 200*（from cache）*：

![img](https://images2015.cnblogs.com/blog/561179/201603/561179-20160331162129410-1428753698.gif)

随便点开一个静态资源是酱的：

![img](https://images2015.cnblogs.com/blog/561179/201603/561179-20160331162506613-1409729874.png)

哎哟有Response报头数据呢，看来服务器也正常返回了etag什么鬼的应有尽有，那状态200不是应该对应的非缓存状态么？要from cache的话不是应该返回304才合理么？

难道是度娘的服务器故障了吗？

如果你知道答案，那就可以忽略本文了。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**http报文中与缓存相关的首部字段**

我们先来瞅一眼[RFC2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)规定的47种http报文首部字段中与缓存相关的字段，事先了解一下能让咱在心里有个底：

**1. 通用首部字段**（就是请求报文和响应报文都能用上的字段）

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161150504-1030837643.png)

**2. 请求首部字段**

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161240301-2050921595.png)

**3. 响应首部字段**

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161311394-1246877214.png)

**4. 实体首部字段**

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401171410441-767100632.png)

后续大体也会依次介绍它们。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**场景模拟**

为方便模拟各种缓存效果，我们建个非常简单的场景。

**1. 页面文件**

我们建个非常简单的html页面，上面只有一个本地样式文件和图片：

[![复制代码](http://images.cnblogs.com/cnblogs_com/vajoy/558869/o_copybutton.png)](javascript:void(0);)

```
<!DOCTYPE html>
<html>
<head>
<title>缓存测试</title>
<link rel="stylesheet" href="css/reset.css">
</head>
<body>
<h1>哥只是一个标题</h1>
<p><img src="img/dog.jpg" /></p>
</body>
</html>
```

[![复制代码](http://images.cnblogs.com/cnblogs_com/vajoy/558869/o_copybutton.png)](javascript:void(0);)

**2. 首部字段修改**

有时候一些浏览器会自行给请求首部加上一些字段*（如chrome使用F5会强制加上“\*cache-control:max-age=0\*”）*,会覆盖掉一些字段*（比如pragma）*的功能；另外有时候我们希望服务器能多/少返回一些响应字段。

这种情况我们就希望可以手动来修改请求或响应报文上的内容了。那么如何实现呢？这里我们使用[Fiddler](http://www.telerik.com/fiddler)来完成任务。

在Fiddler中我们可以通过“bpu XXX”指令来拦截指定请求，然后手动修改请求内容再发给服务器、修改响应内容再发给客户端。

以我们的example为例，页面文件走nginx通过 http://localhost/ 可直接访问，所以我们直接执行“bpu localhost”拦截所有地址中带有该字样的请求：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160402211104644-1077762209.gif)

点击被拦截的请求，可以在右栏直接修改报文内容（上半区域是请求报文，下半区域是响应报文），点击黄色的“Break on Response”按钮可以执行下一步（把请求发给服务器），点击绿色的按钮“Run to Completion”可以直接完成整个请求过程：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160402211444629-1768756452.gif)

通过这个方法我们可以很轻松地模拟出各种http缓存场景。

**3. 浏览器的强制策略**

如上述，当下大多数浏览器在点击刷新按钮或按F5时会自行加上“Cache-Control:max-age=0”请求字段，所以我们先约定成俗——后文提及的“刷新”多指的是选中url地址栏并按回车键*（这样不会被强行加上Cache-Control）*。

事实上有的浏览器还有一些更奇怪的行为，在后续我们回答文章开头问题的时候会提到。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**石器时代的缓存方式**

在 http1.0 时代，给客户端设定缓存方式可通过两个字段——“Pragma”和“Expires”来规范。虽然这两个字段早可抛弃，但为了做http协议的向下兼容，你还是可以看到很多网站依旧会带上这两个字段。

**1. Pragma**

当该字段值为“no-cache”的时候*（事实上现在RFC中也仅标明该可选值）*，会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。

Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上这段meta元标签（而且可能还得[做些hack放到body后面去](https://support.microsoft.com/zh-cn/kb/222064)）：

```
<meta http-equiv="Pragma" content="no-cache">
```

它告诉浏览器每次请求页面时都不要读缓存，都得往服务器发一次请求才行。

BUT!!! 事实上这种禁用缓存的形式用处很有限：

\1. 仅有IE才能识别这段meta标签含义，其它主流浏览器仅能识别“Cache-Control: no-store”的meta标签*（见[出处](http://securityevaluators.com/knowledge/case_studies/caching/)）*。
\2. 在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求*（仅限页面，页面上的资源则不受影响）*。

做了测试后发现也的确如此，这种客户端定义Pragma的形式基本没起到多少作用。

不过如果是在响应报文上加上该字段就不一样了：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160402224024176-1110075362.png)

如上图红框部分是再次刷新页面时生成的请求，这说明禁用缓存生效，预计浏览器在收到服务器的Pragma字段后会对资源进行标记，禁用其缓存行为，进而后续每次刷新页面均能重新发出请求而不走缓存。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**2. Expires**

有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http1.0而言，Expires就是做这件事的首部字段。

Expires的值对应一个GMT*（格林尼治时间）*，比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。

在客户端我们同样可以使用meta标签来知会IE*（也仅有IE能识别）*页面*（同样也只对页面有效，对页面上的资源无效）*缓存时间：

```
<meta http-equiv="expires" content="mon, 18 apr 2016 14:30:00 GMT">
```

如果希望在IE下页面不走缓存，希望每次刷新页面都能发新请求，那么可以把“content”里的值写为“-1”或“0”。

注意的是该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段。

如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160403120337051-1989638817.png)

在上图里，缓存时间设置为一个已过期的时间点*（见红框）*，则刷新页面将重新发送请求*（见蓝框）*。

那么如果Pragma和Expires一起上阵的话，听谁的？我们试一试就知道了：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160403122006566-1603115184.png)

我们通过Pragma禁用缓存，又给Expires定义一个还未到期的时间*（红框）*，刷新页面时发现均发起了新请求*（蓝框）*，这意味着Pragma字段的优先级会更高。

BUT，响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，如果客户端上的时间跟服务器上的时间不一致*（特别是用户修改了自己电脑的系统时间）*，那缓存时间可能就没啥意义了。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**Cache-Control**

针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间，若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准。

Cache-Control也是一个通用首部字段，这意味着它能分别在请求报文和响应报文中使用。在RFC中规范了 Cache-Control 的格式为：

```
"Cache-Control" ":" cache-directive
```

作为请求首部时，cache-directive 的可选值有：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160403173213113-100043029.png)

作为响应首部时，cache-directive 的可选值有：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160403181549941-1360231582.png)

我们依旧可以在HTML页面加上meta标签来给请求报头加上 Cache-Control 字段：

另外 Cache-Control 允许自由组合可选值，例如：

```
Cache-Control: max-age=3600, must-revalidate
```

它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。

当然这种组合的方式也会有些限制，比如 no-cache 就不能和 max-age、min-fresh、max-stale 一起搭配使用。

组合的形式还能做一些浏览器行为不一致的兼容处理。例如在IE我们可以使用 no-cache 来防止点击“后退”按钮时页面资源从缓存加载，但在 Firefox 中，需要使用 no-store 才能防止历史回退时浏览器不从缓存中去读取数据，故我们在响应报头加上如下组合值即可做兼容处理：

```
Cache-Control: no-cache, no-store
```

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**缓存校验字段**

上述的首部字段均能让客户端决定是否向服务器发送请求，比如设置的缓存时间未过期，那么自然直接从本地缓存取数据即可（在chrome下表现为200 from cache），若缓存时间过期了或资源不该直接走缓存，则会发请求到服务器去。

我们现在要说的问题是，如果客户端向服务器发了请求，那么是否意味着一定要读取回该资源的整个实体内容呢？

我们试着这么想——客户端上某个资源保存的缓存时间过期了，但这时候其实服务器并没有更新过这个资源，如果这个资源数据量很大，客户端要求服务器再把这个东西重新发一遍过来，是否非常浪费带宽和时间呢？

答案是肯定的，那么是否有办法让服务器知道客户端现在存有的缓存文件，其实跟自己所有的文件是一致的，然后直接告诉客户端说“这东西你直接用缓存里的就可以了，我这边没更新过呢，就不再传一次过去了”。

为了让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，Http1.1新增了几个首部字段来做这件事情。

**1. Last-Modified**

服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。

客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可。

至于传递标记起来的最终修改时间的请求报文首部字段一共有两个：

**⑴ If-Modified-Since: Last-Modified-value**

```
示例为  If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT
```

该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。

当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。

***\*⑵\** If-Unmodified-Since: Last-Modified-value**

告诉服务器，若Last-Modified没有匹配上*（资源在服务端的最后更新时间改变了）*，则应当返回412(Precondition Failed) 状态码给客户端。

当遇到下面情况时，If-Unmodified-Since 字段会被忽略：

```
1. Last-Modified值对上了（资源在服务端没有新的修改）；
2. 服务端需返回2XX和412之外的状态码；
3. 传来的指定日期不合法
```

Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端*（即使客户端缓存里有个一模一样的资源）*。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**2. ETag**

为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了 ETag 实体首部字段。

服务器会通过某种算法，给资源计算得出一个唯一标志符*（比如md5标志）*，在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。

客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。

如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源*（当然也包括了新的ETag）*发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。

那么客户端是如何把标记在资源上的 ETag 传去给服务器的呢？请求报文中有两个首部字段可以带上 ETag 值：

**⑴ If-None-Match: ETag-value**

```
示例为  If-None-Match: "56fcccc8-1699"
```

告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送304 和响应报头即可。

当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值。

**⑵ If-Match: ETag-value**

告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。

If-Match 的一个应用场景是，客户端走PUT方法向服务端请求上传/更替资源，这时候可以通过 If-Match 传递资源的ETag。

 

需要注意的是，如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上计算ETag唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的ETag却不一样。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。

在较新的 nginx 上默认是同时开启了这两个功能的：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160404021556078-697982021.gif)

上图的前三条请求是原始请求，接着的三条请求是刷新页面后的新请求，在发新请求之前我们修改了 reset.css 文件，所以它的 Last-Modified 和 ETag 均发生了改变，服务器因此返回了新的文件给客户端*（状态值为200）*。

而 dog.jpg 我们没有做修改，其Last-Modified 和 ETag在服务端是保持不变的，故服务器直接返回了304状态码让客户端直接使用缓存的 dog.jpg 即可，没有把实体内容返回给客户端*（因为没必要）*。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**缓存实践**

当我们在一个项目上做http缓存的应用时，我们还是会把上述提及的大多数首部字段均使用上，例如使用 Expires 来兼容旧的浏览器，使用 Cache-Control 来更精准地利用缓存，然后开启 ETag 跟 Last-Modified 功能进一步复用缓存减少流量。

那么这里会有一个小问题——Expires 和 Cache-Control 的值应设置为多少合适呢？

答案是不会有过于精准的值，均需要进行按需评估。

例如页面链接的请求常规是无须做长时间缓存的，从而保证回退到页面时能重新发出请求，百度首页是用的 Cache-Control:private，腾讯首页则是设定了60秒的缓存，即 Cache-Control:max-age=60。

而静态资源部分，特别是图片资源，通常会设定一个较长的缓存时间，而且这个时间最好是可以在客户端灵活修改的。以腾讯的某张图片为例：

```
http://i.gtimg.cn/vipstyle/vipportal/v4/img/common/logo.png?max_age=2592000
```

客户端可以通过给图片加上“max_age”的参数来定义服务器返回的缓存时间：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160404115556000-838597877.png)

当然这需要有一个前提——静态资源能确保长时间不做改动。如果一个脚本文件响应给客户端并做了长时间的缓存，而服务端在近期修改了该文件的话，缓存了此脚本的客户端将无法及时获得新的数据。

解决该困扰的办法也简单——把服务侧ETag的那一套也搬到前端来用——页面的静态资源以版本形式发布，常用的方法是在文件名或参数带上一串md5或时间标记符：

```
https://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26
http://tb1.bdstatic.com/tb/_/tbean_safe_ajax_94e7ca2.js
http://img1.gtimg.com/ninja/2/2016/04/ninja145972803357449.jpg
```

如果文件被修改了，才更改其标记符内容，这样能确保客户端能及时从服务器收取到新修改的文件。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**关于开头的问题**

现在回过头来看文章开头的问题，可能会觉得答案很容易回答出来。

百度首页的资源在刷新后实际没有发送任何请求，因为 Cache-Control 定义的缓存时间段还没到期。在Chrome中即使没发送请求，但只要从本地的缓存中取，都会在Network面板显示一条状态为200且注明“from cache”的伪请求，其Response内容只是上一次回包留下的数据。

然而这并不是问题的全部答案，我们前面提到过，在Chrome中如果点击“刷新”按钮，Chrome会强制给所有资源加上“Cache-Control: max-age=0”的请求首部并向服务器发送验证请求的，而在文章开头的动图中，我们的确点击了“刷新”按钮，却不见浏览器发去新请求*（并返回304）*。

关于这个问题其实在组内跟小伙伴们讨论过，通过Fiddler抓包发现，如果关闭Chrome的开发者面板再点击“刷新”按钮，浏览器是会按预期发送验证请求且接收返回的304响应的，另外这个奇怪的情况在不同的网站甚至不同的电脑下出现频率都不一致，所以暂时将其归咎于浏览器的怪异反应。

那么有这么一个问题——是否有办法在浏览器点击“刷新”按钮的时候不让浏览器去发新的验证请求呢？

办法还是有的，就是不怎么实用——在页面加载完毕后通过脚本动态地添加资源：

[![复制代码](http://images.cnblogs.com/cnblogs_com/vajoy/558869/o_copybutton.png)](javascript:void(0);)

```
$(window).load(function() {
      var bg='http://img.infinitynewtab.com/wallpaper/100.jpg';
      setTimeout(function() {  //setTimeout是必须的
       $('#bgOut').css('background-image', 'url('+bg+')');
      },0);
});
```

[![复制代码](http://images.cnblogs.com/cnblogs_com/vajoy/558869/o_copybutton.png)](javascript:void(0);)

出处来自[知乎](https://www.zhihu.com/question/28725359/answer/41960936)，更具体的解释可以去看看。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**其它相关的首部字段**

事实上较常用和重要的缓存相关字段我们都介绍完了，这里顺带讲讲几个跟缓存有关系，但没那么主要的响应首部字段。

**1. Vary**

“vary”本身是“变化”的意思，而在http报文中更趋于是“vary from”*（与。。。不同）*的含义，它表示服务端会以什么基准字段来区分、筛选缓存版本。

我们先考虑这么一个问题——在服务端有着这么一个地址，如果是IE用户则返回针对IE开发的内容，否则返回另一个主流浏览器版本的内容。这很简单，服务端获取到请求的 User-Agent 字段做处理即可。但是用户请求的是代理服务器而非原服务器，且代理服务器如果直接把缓存的IE版本资源发给了非IE的客户端，这就出问题了。

因此 Vary 便是着手处理该问题的首部字段，我们可以在响应报文加上：

```
Vary: User-Agent
```

便能知会代理服务器需要以 User-Agent 这个请求首部字段来区别缓存版本，防止传递给客户端的缓存不正确。

Vary 也接受条件组合的形式：

```
Vary: User-Agent, Accept-Encoding
```

这意味着服务器应以 User-Agent 和 Accept-Encoding 两个请求首部字段来区分缓存版本。

![img](https://images.cnblogs.com/cnblogs_com/vajoy/558869/o_div.jpg)

**2. Date 和 Age**

HTTP并没有提供某种方法来帮用户区分其收到的资源是否命中了代理服务器的缓存，但在客户端我们可以通过计算响应报文中的 Date 和 Age 字段来得到答案。

Date 理所当然是原服务器发送该资源响应报文的时间（GMT格式），如果你发现 Date 的时间与“当前时间”差别较大，或者连续F5刷新发现 Date 的值都没变化，则说明你当前请求是命中了代理服务器的缓存。

上述的“当前时间”自然是相对于原服务器而言的时间，那么如何获悉原服务器的当前时间呢？

常规从页面地址请求的响应报文中可获得，以博客园首页为例：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160404150618953-1983755602.png)

每次你刷新页面，浏览器都会重新发出这条url的请求，你会发现其 Date 值是不断变化的，这说明该链接没有命中缓存，都是从原服务器返回过来的数据。

因此我们可以拿页面上其它静态资源请求回包中的 Date 与其进行对比，若静态资源的 Date 早于原服务端时间，则说明命中了代理服务器缓存。

通常还满足这么个条件：

```
静态资源Age + 静态资源Date = 原服务端Date
```

这里的 Age 也是响应报文中的首部字段，它表示该文件在代理服务器中存在的时间*（秒）*，如文件被修改或替换，Age会重新由0开始累计。

我们在上面那张博客园首页报文截图的同个场景下，看看某个文件（jQuery.js）命中代理服务器缓存的回包数据：

![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160404150719593-444457092.png)

会发现它满足我们上述的规则：

```
//return true
new Date('Mon, 04 Apr 2016 07:03:17 GMT')/1000 == new Date('Sat, 19 Dec 2015 01:29:14 GMT')/1000 + 9264843
```

不过这条规则也不一定准确，特别是当原服务器经常修改系统时间的情况下。

## 1.重要性

当我们面试的时候，前端性能优化方面算是必考的知识点，但是工作中我们又很少会重点的对项目进行前端优化，它真的不重要吗？

如果我们可以将后端响应时间缩短一半，整体响应时间只能减少5%~10%。而如果关注前端性能，同样是将其响应时间减少一半，则整体响应时间可以减少40%~45%。

改进前端通常只需要较少的时间和资源，减少后端延迟会带来很大的改动。

只有10%~20%的最终用户响应时间花在了下载HTML文档上，其余的80%~90%时间花在了下载页面中的所有组件上。

## 2.定位

### 2.1 技术上的选择

在前端日常开发中，技术上的选择是非常重要的。为什么要讲这个呢？因为现象频发。

前端工程化严重的当下，轻量化的框架慢慢被遗忘掉了。并不是所有的业务场景都适合使用工程化框架，react/vue 并不轻量。

> 复杂的框架是为了解决复杂的业务

如果研发h5、PC展示等场景简单的业务时候，javascript原生 配合一些轻量化插件更适合。

多页面应用也并不都是缺点。根据业务不同而选择不一样的技术是非常重要的，是每个前端都应该反思的事情。

这方面是导致卡顿的关键问题。

### 2.2 NetWork

我们的老朋友NetWork想必前端同学都很熟悉。我们先来看一下network面板

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87dbcd5fcd6c46b6b8b153f570e183ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

从面板上我们可以看出一些信息：

- 请求资源size
- 请求资源时长
- 请求资源数量
- 接口响应时长
- 接口发起数量
- 接口报文size
- 接口响应状态
- 瀑布图

**瀑布图**是什么呢？

瀑布图就是上方图片后面的**waterfall**纵列

瀑布图是一个级联图, 展示了浏览器如何加载资源并渲染成网页. 图中的每一行都是一次单独的浏览器请求. 这个图越长, 说明加载网页过程中所发的请求越多. 每一行的宽度, 代表浏览器发出请求并下载该资源的过程中所耗费的时间。它的侧重点在于分析网路链路

瀑布图颜色说明：

- **DNS Lookup** [深绿色] - 在浏览器和服务器进行通信之前, 必须经过DNS查询, 将域名转换成IP地址. 在这个阶段, 你可以处理的东西很少. 但幸运的是, 并非所有的请求都需要经过这一阶段.
- **Initial Connection** [橙色] - 在浏览器发送请求之前, 必须建立TCP连接. 这个过程仅仅发生在瀑布图中的开头几行, 否则这就是个性能问题(后边细说).
- SSL/TLS Negotiation [紫色] - 如果你的页面是通过SSL/TLS这类安全协议加载资源, 这段时间就是浏览器建立安全连接的过程. 目前Google将HTTPS作为其 搜索排名因素 之一, SSL/TLS 协商的使用变得越来越普遍了.
- **Time To First Byte (TTFB)** [绿色] - TTFB 是浏览器请求发送到服务器的时间+服务器处理请求时间+响应报文的第一字节到达浏览器的时间. 我们用这个指标来判断你的web服务器是否性能不够, 或者说你是否需要使用CDN.
- **Downloading (蓝色)** - 这是浏览器用来下载资源所用的时间. 这段时间越长, 说明资源越大. 理想情况下, 你可以通过控制资源的大小来控制这段时间的长度.

那么除了瀑布图的长度外，我们如何才能判断一个瀑布图的状态是**健康**的呢？

- 首先, 减少所有资源的加载时间. 亦即减小瀑布图的宽度. 瀑布图越窄, 网站的访问速度越快.
- 其次, 减少请求数量 也就是降低瀑布图的高度. 瀑布图越矮越好.
- 最后, 通过优化资源请求顺序来加快渲染时间. 从图上看, 就是将绿色的"开始渲染"线向左移. 这条线向左移动的越远越好.

这样，我们就可以从network的角度去排查“慢”的问题。

### 2.3 webpack-bundle-analyzer

项目构建后生成的bundle包是压缩后的。webpack-bundle-analyzer是一款包分析工具。

我们先来看一下它能带来的效果。如下图：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9917c642fa5a4045839b4d0af2c299b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

从上图来看，我们的bundle包被解析的一览无余。其中模块面积占的越大说明在bundle包中size越大。就值得注意了，重点优化一下。

它能够排查出来的信息有

- 显示包中所有打入的模块
- 显示模块size 及 gzip后的size

排查包中的模块情形是非常有必要的，通过webpack-bundle-analyzer来排查出一些无用的模块，过大的模块。然后进行优化。以减少我们的bundle包size，减少加载时长。

安装

```csharp
# NPM 
npm install --save-dev webpack-bundle-analyzer
# Yarn 
yarn add -D webpack-bundle-analyzer
复制代码
复制代码
```

使用(as a Webpack-Plugin)

```ini
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
 
module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
复制代码
复制代码
```

然后构建包完毕后会自动弹出一个窗口展示上图信息。

### 2.4 Performance

chrome自带的performance模块。先附上一个官网文档传送门：[Performance](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fchrome-devtools%2Fevaluate-performance%2F%3Futm_source%3Ddevtools)

可以检测很多方面的数据，多数情况的性能排查上用的比较多。如果想要深入了解的同学建议去看一下官方文档。

接下来我们来说一下在performance面板中如何排差“慢”的问题，它给我们提供了哪些信息呢。先附上一张performance的面板图片。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3027b177f77f49e3866eeecedefaa70b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

从上图中可以分析出一些指标

- FCP/LCP 时间是否过长？
- 请求并发情况 是否并发频繁？
- 请求发起顺序 请求发起顺序是否不对？
- javascript执行情况 javascript执行是否过慢？

这些指标就是我们需要重点关注的，当然performance的功能并不止于此。

先记住如何获取到这些指标，后面来一一进行解析优化。

### 2.5 性能监视器

首先打开F12，随后按快捷键 Ctrl + Shift + P，然后输入性能监视器/monitor。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0eb7de07f7e24bf281a1ecb7767f7f91~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

数据非常直观，浏览网页的时候可以打开，以供参考。

### 2.6 JavaScript性能剖析器

首先打开F12，随后按快捷键 Ctrl + Shift + P，然后输入性能剖析器/profiler。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f639b2cea40d4146bf5da141abdc3dca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

我们点击开始后浏览我们的网页，就会出现一份性能剖析报告。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c254a83dcd4f447c8889aa8347552b26~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

### 2.7 Recorder

这是一个很棒的功能，Recorder顾名思义---记录员，他可以记录下用户和网页的交互(意念艾特了下公司的交互)。

首先打开F12，随后按快捷键 Ctrl + Shift + P，然后输入Recorder。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07564a7ffc9342da8c38132238b3a0d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

点击开始，然后输入本次操作名称： 掘金黑色的枫主页交互梳理。

然后我们就可以到处点点看，就会记录下我们的操作。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90eff186e25d4b03a6c6b8bc9fc08c7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

点击结束之后可以结束录制，我们可以回访我们的操作，还可以对我们的操作进行分析。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/709b8212d7a9445ba6e779d711a43bf1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

分析中包括了屏幕截图，内存，网页指标，妥妥的精工利器。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7a81b01114447ebad8434cdc2b82c3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

从这里我们会了解到很多，比如事件日志，我们可以知道我们触发操作后都发生了什么。

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3d87b39658740d2bdcf4d088b421495~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

而调用树，我们可以知道异步任务，定时器，动画帧，垃圾回收等的执行。

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ce0943327684a8e8a1c8bdfe93baddd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

**Recorder**确实对我们网页分析有很大的帮助。

### 2.8 PerformanceNavigationTiming

获取各个阶段的响应时间，我们所要用到的接口是**PerformanceNavigationTiming**接口。

**PerformanceNavigationTiming** 提供了用于存储和检索有关浏览器文档事件的指标的方法和属性。 例如，此接口可用于确定加载或卸载文档需要多少时间。

```javascript
function showNavigationDetails() {
  const [entry] = performance.getEntriesByType("navigation");
  console.table(entry.toJSON());
}
复制代码
```

使用这个函数，我们就可以获取各个阶段的响应时间，如图：

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aaeb84f30b24d7bafec2747e4ee46aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**参数说明**

navigationStart 加载起始时间
 redirectStart 重定向开始时间（如果发生了HTTP重定向，每次重定向都和当前文档同域的话，就返回开始重定向的fetchStart的值。其他情况，则返回0）
 redirectEnd 重定向结束时间（如果发生了HTTP重定向，每次重定向都和当前文档同域的话，就返回最后一次重定向接受完数据的时间。其他情况则返回0）
 fetchStart 浏览器发起资源请求时，如果有缓存，则返回读取缓存的开始时间
 domainLookupStart 查询DNS的开始时间。如果请求没有发起DNS请求，如keep-alive，缓存等，则返回fetchStart
 domainLookupEnd 查询DNS的结束时间。如果没有发起DNS请求，同上
 connectStart 开始建立TCP请求的时间。如果请求是keep-alive，缓存等，则返回domainLookupEnd
 (secureConnectionStart) 如果在进行TLS或SSL，则返回握手时间
 connectEnd 完成TCP链接的时间。如果是keep-alive，缓存等，同connectStart
 requestStart 发起请求的时间
 responseStart 服务器开始响应的时间
 domLoading 从图中看是开始渲染dom的时间，具体未知
 domInteractive 未知
 domContentLoadedEventStart 开始触发DomContentLoadedEvent事件的时间
 domContentLoadedEventEnd DomContentLoadedEvent事件结束的时间
 domComplete 从图中看是dom渲染完成时间，具体未知
 loadEventStart 触发load的时间，如没有则返回0
 loadEventEnd load事件执行完的时间，如没有则返回0
 unloadEventStart unload事件触发的时间
 unloadEventEnd unload事件执行完的时间

**关于我们的Web性能，我们会用到的时间参数：**

DNS解析时间： domainLookupEnd - domainLookupStart
 TCP建立连接时间： connectEnd - connectStart
 白屏时间： responseStart - navigationStart
 dom渲染完成时间： domContentLoadedEventEnd - navigationStart
 页面onload时间： loadEventEnd - navigationStart

根据这些时间参数，我们就可以判断哪一阶段对性能有影响。

### 2.9 抓包

有一些业务状况是没有上述的一些调试工具该怎么办呢？我们可以利用抓包工具进行对页面信息对抓取，上述我们通过chrome工具排查出来的指标，也可以通过抓包工具进行抓取。

这里我推荐一款抓包工具[charles](https://link.juejin.cn?target=https%3A%2F%2Fwww.charlesproxy.com%2F)。

### 2.10 性能测试工具

2.7.1 Pingdom

2.7.2 Load Impact

2.7.3 WebPage Test

2.7.4 Octa Gate Site Timer

2.7.5 Free Speed Test

## 3.优化

前端的优化种类繁多，主要包含三个方面的优化：网络优化（对加载时所消耗的网络资源优化），代码优化（资源加载完后，脚本解释执行的速度），框架优化（选择性能较好的框架，比如[benchmark](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fstefankrause.net%2Fjs-frameworks-benchmark8%2Ftable.html)）。

### 3.1 tree shaking

中文（摇树），webpack构建优化中重要一环。摇树用于清除我们项目中的一些无用代码，它依赖于ES中的模块语法。

比如日常使用lodash的时候

```javascript
import _ from 'lodash'
复制代码
复制代码
```

如果如上引用lodash库，在构建包的时候是会把整个lodash包打入到我们的bundle包中的。

```javascript
import _isEmpty from 'lodash/isEmpty';
复制代码
复制代码
```

如果如上引用lodash库，在构建包的时候只会把isEmpty这个方法抽离出来再打入到我们的bundle包中。

这样的化就会大大减少我们包的size。所以在日常引用第三方库的时候，需要注意导入的方式。

如何开启摇树

在webpack4.x 中默认对tree-shaking进行了支持。 在webpack2.x 中使用tree-shaking：[传送门](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F28725181)

### 3.2 split chunks

中文（分包）

在没配置任何东西的情况下，webpack 4 就智能的帮你做了代码分包。入口文件依赖的文件都被打包进了main.js，那些大于 30kb 的第三方包，如：echarts、xlsx、dropzone等都被单独打包成了一个个独立 bundle。

其它被我们设置了异步加载的页面或者组件变成了一个个chunk，也就是被打包成独立的bundle。

它内置的代码分割策略是这样的：

- 新的 chunk 是否被共享或者是来自 node_modules 的模块
- 新的 chunk 体积在压缩之前是否大于 30kb
- 按需加载 chunk 的并发请求数量小于等于 5 个
- 页面初始加载时的并发请求数量小于等于 3 个

大家可以根据自己的项目环境来更改配置。配置代码如下：

```php
splitChunks({
  cacheGroups: {
    vendors: {
      name: `chunk-vendors`,
      test: /[\\/]node_modules[\\/]/,
      priority: -10,
      chunks: 'initial',
    },
    dll: {
      name: `chunk-dll`,
      test: /[\\/]bizcharts|[\\/]\@antv[\\/]data-set/,
      priority: 15,
      chunks: 'all',
      reuseExistingChunk: true
    },
    common: {
      name: `chunk-common`,
      minChunks: 2,
      priority: -20,
      chunks: 'all',
      reuseExistingChunk: true
    },
  }
})
复制代码
复制代码
```

没有使用webpack4.x版本的项目，依然可以通过**按需加载**的形式进行分包，使得我们的包分散开，提升加载性能。

按需加载也是以前分包的重要手段之一

这里推荐一篇非常好的文章：[webpack如何使用按需加载](https://juejin.im/post/6844903718387875847)

### 3.3 拆包

与3.2的分包不同。大家可能没发现，上面2.3的bundle包解析中有个有趣的现象，上面项目的技术栈是react，但是bundle包中并没有react、react-dom、react-router等。

因为把这些插件“拆”开了。并没有一起打在bundle中。而是放在了CDN上。下面我举一个例子来解释一下。

假设：原本bundle包为2M，一次请求拉取。拆分为 bundle（1M） + react桶（CDN）（1M） 两次请求并发拉取。

从这个角度来看，1+1的模式拉取资源更快。

换一个角度来说，全量部署项目的情况，每次部署bundle包都将重新拉取。比较浪费资源。react桶的方式可以命中强缓存，这样的化，就算全量部署也只需要重新拉取左侧1M的bundle包即可，节省了服务器资源。优化了加载速度。

注意：在本地开发过程中，react等资源建议不要引入CDN，开发过程中刷新频繁，会增加CDN服务其压力，走本地就好。

### 3.4 gzip

服务端配置gzip压缩后可大大缩减资源大小。

Nginx配置方式

```ini
http {
  gzip on;
  gzip_buffers 32 4K;
  gzip_comp_level 6;
  gzip_min_length 100;
  gzip_types application/javascript text/css text/xml;
  gzip_disable "MSIE [1-6]\.";
  gzip_vary on;
}
复制代码
复制代码
```

配置完成后在response header中可以查看。 ![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47900b771d2449628ad7a5f83f95d64c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 3.5 图片压缩

开发中比较重要的一个环节，我司自己的图床工具是自带压缩功能的，压缩后直接上传到CDN上。

如果公司没有图床工具，我们该如何压缩图片呢？我推荐几种我常用的方式

- [智图压缩](https://link.juejin.cn?target=https%3A%2F%2Fzhitu.isux.us%2F) (百度很难搜到官网了，免费、批量、好用)
- [tinypng](https://link.juejin.cn?target=https%3A%2F%2Ftinypng.com%2F)(免费、批量、速度块)
- fireworks工具压缩像素点和尺寸 (自己动手，掌握尺度)
- 找UI压缩后发给你

图片压缩是常用的手法，因为设备像素点的关系，UI给予的图片一般都是 x2，x4的，所以压缩就非常有必要。

### 3.6 图片分割

如果页面中有一张效果图，比如真机渲染图，UI手拿着刀不让你压缩。这时候不妨考虑一下分割图片。

建议单张土图片的大小不要超过100k，我们在分割完图片后，通过布局再拼接在一起。可以图片加载效率。

这里注意一点，分割后的每张图片一定要给height，否则网速慢的情况下样式会塌陷。

### 3.7 sprite

南方叫精灵图，北方叫雪碧图。这个现象就很有趣。

在网站中有很多小图片的时候，一定要把这些小图片合并为一张大的图片，然后通过background分割到需要展示的图片。

这样的好处是什么呢？先来普及一个规则

浏览器请求资源的时候，同源域名请求资源的时候有最大并发限制，chrome为6个，就比如你的页面上有10个相同CDN域名小图片，那么需要发起10次请求去拉取，分两次并发。第一次并发请求回来后，发起第二次并发。

如果你把10个小图片合并为一张大图片的画，那么只用一次请求即可拉取下来10个小图片的资源。减少服务器压力，减少并发，减少请求次数。

附上一个sprite的例子。

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f42fbdef05c34d5ca1c1a3e3b0515ec5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 3.8 CDN

中文（内容分发网络），服务器是中心化的，CDN是“去中心化的”。

在项目中有很多东西都是放在CDN上的，比如：静态文件，音频，视频，js资源，图片。那么为什么用CDN会让资源加载变快呢？

举个简单的例子：

> 以前买火车票大家都只能去火车站买，后来我们买火车票就可以在楼下的火车票代售点买了。

你细品。

所以静态资源度建议放在CDN上，可以加快资源加载的速度。

### 3.9 懒加载

懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种非常好的优化网页性能的方式。

当可视区域没有滚到资源需要加载的地方时候，可视区域外的资源就不会加载。

可以减少服务器负载，常适用于图片很多，页面较长的业务场景中。

如何使用懒加载呢？

- [图片懒加载](https://juejin.im/post/6844903688390049800)
- [layzr.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcallmecavs%2Flayzr.js)

### 3.10 iconfont

中文（字体图表），现在比较流行的一种用法。使用字体图表有几种好处

- 矢量
- 轻量
- 易修改
- 不占用图片资源请求。

就像上面说的雪碧图，如果都用字体图标来替换的画，一次请求都免了，可以直接打到bundle包中。

使用前提是UI给点力，设计趋向于字体图标，提前给好资源，建立好字体图标库。

### 3.11 逻辑后移

逻辑后移是一种比较常见的优化手段。用一个打开文章网站的操作来举个例子。

没有逻辑后移处理的请求顺序是这个样子的

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46f8e43dbe2345af85aa232e59a79fc1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

页面的展示主体是文章展示，如果文章展示的请求靠后了，那么渲染文章出来的时间必然靠后，因为有可能因为请求阻塞等情况，影响请求响应情况，如果超过一次并发的情况的话，会更加的慢。如图的这种情况也是在我们项目中发生过的。

很明显我们应该把主体“请求文章”接口前移，把一些非主体的请求逻辑后移。这样的话可以尽快的把主体渲染出来，就会快很多。

优化后的顺序是这个样子的。

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d161a61ec94d42ed9b48cf3b00eb12fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

在平常的开发中建议时常注意逻辑后移的情况，突出主体逻辑。可以极大的提升用户体验。

### 3.12 算法复杂度

在数据量大的应用场景中，需要着重注意算法复杂度问题。

在这个方面可以参考[Javascript算法之复杂度分析](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fffbb25380904)这篇文章。

如上面Performance解析出的Javascript执行指标上，可以推测出来你的code执行效率如何，如果执行时间过长就要考虑一下是否要优化一下复杂度了。

> 在时间换空间，空间换时间的选择上，要根据业务场景来进行取舍。

### 3.13 组件渲染

拿react举例，组件分割方面不要太深。需要控制组件的渲染，尤其是深层组件的render。

老生常谈的话题，我们可以一些方式来优化组件渲染

- 声明周期控制 - 比如react的shouldComponentUpdate来控制组件渲染。
- 官网提供的api- PureComponent
- 控制注入组件的参数
- 分配组件唯一key

没有必要的渲染是对性能的极大浪费。

### 3.14 node middleware

中文（node 中间件）

中间件主要是指封装所有Http请求细节处理的方法。一次Http请求通常包含很多工作，如记录日志、ip过滤、查询字符串、请求体解析、Cookie处理、权限验证、参数验证、异常处理等，但对于Web应用而言，并不希望接触到这么多细节性的处理，因此引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节，让我们能够关注在业务的开发上，以达到提升开发效率的目的。

使用node middleware合并请求。减少请求次数。这种方式也是非常实用的。

### 3.15 web worker

Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

合理实用web worker可以优化复杂计算任务。这里直接抛阮一峰的入门文章：[传送门](https://link.juejin.cn?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2018%2F07%2Fweb-worker.html)

### 3.16 缓存

缓存的原理就是更快读写的存储介质+减少IO+减少CPU计算=性能优化。而性能优化的第一定律就是：优先考虑使用缓存。

缓存的主要手段有：浏览器缓存、CDN、反向代理、本地缓存、分布式缓存、数据库缓存。

### 3.17 GPU渲染

每个网页或多或少都涉及到一些CSS动画，通常简单的动画对于性能的影响微乎其微，然而如果涉及到稍显复杂的动画，不当的处理方式会使性能问题变得十分突出。

像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持GPU加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启。

虽然我们可能不想对元素应用3D变换，可我们一样可以开启3D引擎。例如我们可以用`transform: translateZ(0)` 来开启GPU加速 。

只对我们需要实现动画效果的元素应用以上方法，如果仅仅为了开启硬件加速而随便乱用，那是不合理的。

### 3.18 Ajax可缓存

Ajax在发送的数据成功后，为了提高页面的响应速度和用户体验，会把请求的URL和返回的响应结果保存在缓存内，当下一次调用Ajax发送相同的请求（URL和参数完全相同）时，它就会直接从缓存中拿数据。

在进行Ajax请求的时候，可以选择尽量使用get方法，这样可以使用客户端的缓存，提高请求速度。

### 3.19 Resource Hints

Resource Hints(资源预加载)是非常好的一种性能优化方法，可以大大降低页面加载时间，给用户更加流畅的用户体验。

现代浏览器使用大量预测优化技术来预测用户行为和意图，这些技术有预连接、资源与获取、资源预渲染等。

Resource Hints 的思路有如下两个：

- 当前将要获取资源的列表
- 通过当前页面或应用的状态、用户历史行为或 session 预测用户行为及必需的资源

实现Resource Hints的方法有很多种，可分为基于 link 标签的 DNS-prefetch、subresource、preload、 prefetch、preconnect、prerender，和本地存储 localStorage。

### 3.20 SSR

渲染过程在服务器端完成，最终的渲染结果 HTML 页面通过 HTTP 协议发送给客户端，又被认为是‘同构'或‘通用'，如果你的项目有大量的detail页面，相互特别频繁，建议选择服务端渲染。

服务端渲染(SSR)除了SEO还有很多时候用作首屏优化，加快首屏速度，提高用户体验。但是对服务器有要求，网络传输数据量大，占用部分服务器运算资源。

Vue的Nuxt.js和React的next.js都是服务端渲染的方法。

### 3.21 UNPKG

UNPKG是一个提供npm包进行CDN加速的站点，因此，可以将一些比较固定了依赖写入html模版中，从而提高网页的性能。首先，需要将这些依赖声明为external，以便webpack打包时不从node_modules中加载这些资源，配置如下：

```css
externals: { 'react': 'React' }
复制代码
```

其次，你需要将所依赖的资源写在html模版中，这一步需要用到[html-webpack-plugin](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Fjantimon%2Fhtml-webpack-plugin)。下面是一段示例：

```javascript
<% if (htmlWebpackPlugin.options.node_env === 'development') { %>
  <script src="https://unpkg.com/react@16.7.0/umd/react.development.js"></script>
<% } else { %>
  <script src="https://unpkg.com/react@16.7.0/umd/react.production.min.js"></script>
<% } %>
复制代码
```

这段代码需要注入node_env，以便在开发的时候能够获得更友好的错误提示。也可以选择一些比较自动的库，来帮助我们完成这个过程，比如[webpack-cdn-plugin](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-cdn-plugin)，或者[dynamic-cdn-webpack-plugin](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Fmastilver%2Fdynamic-cdn-webpack-plugin)。

### 3.22 域名发散与收敛

浏览器有并发限制，是为了防止DDoS攻击。

> 分布式拒绝服务攻击DDoS是一种基于DoS的特殊形式的拒绝服务攻击，是一种分布的、协同的大规模攻击方式。单一的DoS攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。与DoS攻击由单台主机发起攻击相比较，分布式拒绝服务攻击DDoS是借助数百、甚至数千台被入侵后安装了攻击进程的主机同时发起的集团行为。

域名收敛：就是将静态资源放在一个域名下，减少DNS解析的开销。

域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。

域名发散是PC端为了利用浏览器的多线程并行下载能力。

而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。

手机端页面加载数和域名分散数的关系：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f5683d781c345d9af5a5f5e20211080~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3b29010536b48a0a6637afca21c38a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

现在，各大浏览器都已经提升了资源的下载数，所以，域名分散的必要性也就没这么大了. 可以从上表看出，在2个域名分散条件下，网页的加载速度提升较大，而第三个以后就比较慢了。 所以， 一般来说，域名分散的数量最好在3以下。

这个方法是通过增加域名来解除并发限制，那有没有方法不用增加域名来解除并发限制呢？

**SPDY。**

### 3.23 SPYD

SPDY是google主导的一种新型通信方式.主要的特点就是多路复用. 他的目的就是致力于取消max connections 上限. 不过由于推广时间短，全世界使用的网页数都比较少. 但，据chromium统计，使用了SPDY网页速率 差不多提升了 [28%~64%](https://link.juejin.cn?target=http%3A%2F%2Fwww.chromium.org%2Fspdy%2Fspdy-whitepaper) 左右. 所以,说SPDY的出现，可以让域名发散的存在变的毫无价值.

SPDY 协议能够完成多路复用的加密全双工通道，显著提高非wifi环境下的网络体验。

那SPDY具体的优势在哪里.

- 解决了HTTP只能 One request per connection. 当连接完成后，可以实现并行下载多个资源文件
- 服务器推的技术, 和SSE的理念类似，不过更靠底层。直接可以实现无需用户等待，直接后台发资源(感觉就像写APP了，有木有)
- 请求头的复用. 当你前几次的请求头内容没多大变化的时候，就会省去几个相同的,实现Header Compression
- 数据压缩: 在HTTP1.1 有 Content-Encoding: gzip, Transfer-Encoding: chunked. 来显式表明开启文本压缩。
- 强制使用SSL传输协议: Google 认为 Web 将来的发展方向一定是安全的网络链接，所有请求 SSL 加密后，信息传输更加安全。

那如何开启SPDY呢? 使用nginx的用户，可以下载一个[ngx_http_spdy_module](https://link.juejin.cn?target=http%3A%2F%2Fnginx.org%2Fen%2Fdocs%2Fhttp%2Fngx_http_spdy_module.html) 的模块. 使用apache的用户，可以下载一个 [mod_spdy module](https://link.juejin.cn?target=http%3A%2F%2Fgoogledevelopers.blogspot.jp%2F2014%2F06%2Fmodspdy-is-now-apache-project.html) 的模块.

## 4.总结

还有一些比较常用的优化方法我没有列举出来，例如将样式表放在顶部，将脚本放在底部，减少重绘，按需加载，模块化等。方法很多，对症下药才是关键。



作者：黑色的枫
链接：https://juejin.cn/post/6904517485349830670
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 背景

> 领导：这个怎么一直在loading，打开这么长时间
> 我：初次加载就是有些慢，你看这里有提示性文字
> 领导：这体验太差了，想办法优化一下
> 我：这项目太大了，近两百个页面的系统……
> 后端同学：那淘宝，阿里云那页面不比咱们这个系统页面多?
> 领导：(领导瞥了我一眼)
> 我：好的，领导（嘴上笑嘻嘻心里MMP）

![WechatIMG159.jpeg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b175ef5dbb214b3ba04d1c9165248615~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?) ~~**以上内容为了节目效果，纯属虚构，本次优化完全是出于对技术的热爱以及工作的热忱**~~

下面我们对项目进行优化，先剧透一下结果，以基础的Vue Cli3的项目为例：

| 优化项       | 优化前 | 优化后 |
| ------------ | ------ | ------ |
| 首屏加载时间 | 30s+   | 2.5s   |
| 打包后的大小 | 28.9M  | 1M     |

```
根据常规的操作思路，我们从以下几个方面考虑优化：
```

## WEBPACK

### `sourceMap`

生产环境下关闭`productionSourceMap`、`css sourceMap`，因为这两个东西是映射源文件的两个配置，作用是用来断点调试用的，所以生产环境根本不需要做这样的映射。

```js
    // vue.config.js
    const isProduction = process.env.NODE_ENV === 'production'
    // 判断是否是生产环境
    module.exports = {
        productionSourceMap: !isProduction, //关闭生产环境下的SourceMap映射文件
        css: {
            sourceMap: !isProduction, // css sourceMap 配置
            loaderOptions: {
                ...
            }
        },
        ...
    }
复制代码
```

### webpack-bundle-analyzer

```
webpack-bundle-analyzer`是webpack包分析的神器插件，安装 `webpack-bundle-analyzer` 插件，打包后会生产一个本地服务，清楚的展示打包文件的包含关系和大小，所以我们废话不多，直接`npm install webpack-bundle-analyzer -D
    // vue.config.js
    module.exports = {     
       chainWebpack: (config) => {
            // 分析打包大小
            if (process.env.npm_config_report) {
              config.plugin('webpack-bundle-analyzer')
                .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin)
                .end();
            }
       }
    }
    
    // package.json
    {
      "name": "name",
      "version": "0.0.1",
      "scripts": {
        "report": "set npm_config_report=true && vue-cli-service build",
      },
      ...
     }

复制代码
```

接下来直接跑 `npm run report`, 浏览器在打包的同时会输出下面一个依赖包关系的报告：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dfa670854724633a2b4feeec7ed3482~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0d8e136afe4486b98b364c6c24d51da~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/834e97d5e5b2425a8a7b055f5fd88e76~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?) 打开对应的dist一看，好家伙，dist文件28.9M，着实有点儿大，喝口水压压惊，继续骚操作

### externals

根据分析报告，直观的看到node_modules里面有几个比较大的包，我们处理一下，比如echarts、element-ui、lodash、mock等，而externals可以用来**防止**将某些 `import` 的包(package)**打包**到 bundle 中，而是在运行时(runtime)再去从外部获取这些*扩展依赖(external dependencies)*

```JavaScript
    // vue.config.js
    ....
    chainWebpack: (config) => {
        ....
        //忽略的打包文件
        config.externals({
          'vue': 'Vue',
          'vue-router': 'VueRouter',
          'vuex': 'Vuex',
          'axios': 'axios',
          'element-ui': 'ELEMENT',
          'echarts': 'echarts',
          'lodash': 'lodash',
          'mock': 'mock'
        });
        ....
    }
复制代码
```

### 拆包

一个入口app.js好几兆，这加载起来多费劲，怪不得刚才领导打开系统的时候那么慢

```js
// vue.config.js
....
chainWebpack: (config) => {
    ...
    config.optimization && config.optimization.splitChunks({
        // 拆包配置 
        chunks: 'all', //三选一："initial" 初始化，"all"(默认就是all)，"async"（动态加载） 
        minSize: 30000, // 形成一个新代码块最小的体积,只有 >= minSize 的bundle会被拆分出来 30000
        maxSize: 0, //拆分之前最大的数值，默认为0，即不做限制
        minChunks: 1, //引入次数，如果为2 那么一个资源最少被引用两次才可以被拆分出来
        maxAsyncRequests: 5, // 按需加载的最大并行请求数
        maxInitialRequests: 3, // 一个入口最大并行请求数
        automaticNameDelimiter: '~', // 文件名的连接符
        name: true,
        cacheGroups: {
        // node_modules模块包
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          name: 'chunk-vendors',
          // name(module) {
          //   const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1];
          //   return `chunk.${packageName.replace('@', '')}`;
          // },
          chunks: 'all',
          priority: -10,
        },
        // UI库单独拆包
        elementUI: {
          name: 'chunk-elementUI',
          priority: 20, //  the weight needs to be larger than libs and app or it will be packaged into libs or app
          test: /[\\/]node_modules[\\/]_?element-ui(.*)/
        },
        // 共享模块
        common: {
          name: 'chunk-common',
          minChunks: 2,
          maxSize: 1024, //拆分之前最大的数值，默认为0，即不做限制
          priority: -20,
          reuseExistingChunk: true
        }
        }
    });
    ...
}
...
复制代码
```

### 压缩js和css

如果你使用的是 webpack v5 或更高版本，是开箱机带的功能，但是你的webpack是5以下或则希望自定义配置，那么需要安装 `terser-webpack-plugin`。如果使用 webpack v4，则必须安装 `terser-webpack-plugin` v4 的版本。

```JavaScript
// vue.config.js
const TerserJSPlugin = require('terser-webpack-plugin');
....
chainWebpack: (config) => {
    // 开启js、css压缩
    config.plugin('TerserJSPlugin')
      .use(new TerserJSPlugin({
        terserOptions: {
          output: {
            comments: false // 去掉注释
          },
          warnings: false,
          compress: {
            // eslint-disable-next-line camelcase
            drop_console: true,
            // eslint-disable-next-line camelcase
            drop_debugger: true,
            // pure_funcs: ['console.log'] // 移除console
          }
        }
      }));
}
复制代码
```

### 图片压缩

安装图片压缩的loader[image-webpack-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fimage-webpack-loader) 直接终端`npm install image-webpack-loader -D`

```bash
// vue.config.js
...
module.exports = {
    ...
    chainWebpack: config => {
        config.module 
            .rule('images')
              .use('image-webpack-loader') 
                  .loader('image-webpack-loader') 
                  .options({ 
                      bypassOnDebug: true, // webpack  'debug' 模式下不执行
                  }) 
              .end() 
            .end()

    }
    ...
}

复制代码
```

### 开启Gzip压缩

```JavaScript
// 打包压缩静态文件插件
const CompressionWebpackPlugin = require("compression-webpack-plugin")
...
module.exports = {
    ...
    chainWebpack: config => {
        //生产环境开启js/css压缩
        if (isProduction) {
            config.plugin('CompressionWebpackPlugin').use(new CompressionWebpackPlugin({
                test: /\.(js)$/, // 匹配文件名
                threshold: 10240, // 对超过10k的数据压缩
                minRatio: 0.8,
                deleteOriginalAssets: true // 删除源文件
            }))
        }
    }
    ...
}
复制代码
```

对用服务端Nginx配置

```bash
# nginx前端静态资源配置  // data/docker/nginx/conf.d 
server { 
    listen 8080; 
    server_name _;
    gzip_static on; // 开启gzip压缩
    client_max_body_size 500m; 
    root /data/****/web/dist; 
    index index.html; 
    location ^~ /api { 
        proxy_pass http://***.**.**.***:8080/; 
        proxy_set_header Host ***.**.**.***; 
        proxy_set_header X-Real-IP $remote_addr; 
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
    } 
}


复制代码
```

### 增加cache-loader

由于项目庞大，之前打包时间就很长，打包时间的大部分都在`npm install`和各种`loader`的执行上，如果不用每次打包都从0开始执行的话会快很多。首先可以在`loader`之前加上`cache-loader`，这样这个`loader`执行过一次后的数据会缓存在`node_modules/.cache`目录下，下次再打包就会利用缓存。

```bash
// vue.config.js
...
module.exports = {
    ...
    config.module
          .rule('images')
            // 给 image-webpack-loader 加上缓存来加快编译
            .use('cache-loader')
              .before('url-loader')
              .loader('cache-loader')
              .options({
                cacheDirectory: path.join(__dirname, 'node_modules/.cache/image-webpack-loader'),
              })
    ...
}
复制代码
注意：只有执行时间很长的loader才适合用缓存，因为读写文件也是有开销的，滥用反而会导致变慢
```

## CDN

对于项目用到的静态资源，比如图片，静态资源库，我们直接把文件给甩到CDN上

```html
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.10/vue.min.js" charset="utf-8"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/vuex/3.1.1/vuex.min.js" charset="utf-8"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/vue-router/3.0.1/vue-router.min.js" charset="utf-8"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/axios/0.17.1/axios.min.js" charset="utf-8"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.3/index.min.js" charset="utf-8"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/echarts/5.1.2/echarts.min.js" charset="utf-8"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min.js" charset="utf-8"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/Mock.js/1.0.1-beta3/mock-min.js" charset="utf-8"></script>
复制代码
```

## 按需加载

我们引用某一些第三方使用少量功能的时候，可以选择按需加载，举个例子： 比如引用lodash的时候，如果想要按需加载，可以考虑使用[webpack-lodash-plugin](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flodash%2Flodash-webpack-plugin%23readme)和[babel-plugin-lodash](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flodash%2Fbabel-plugin-lodash)，按需加载可以节省近1M的空间大小

```JavaScript
    // 使用前，需要手动引入指定的模块
    const isElement = require('lodash/isElement');
    const debounce = require('lodash/debounce');

    // 使用后，放心引入
    import { isElement, debounce } from 'lodash'
复制代码
```

## 缓存

我们每次打包，跟上次相比，改变的东西总是相对很小的一部分，不变的东西没必要每次都重新打包，那么我们也可以考虑利用包的缓存，来缩短构建的时间

```JavaScript
module.exports = {
  ...
  configureWebpack: (config) => {
    config.cache = {
      type: "filesystem",
      allowCollectingMemory: true,
      buildDependencies: {
        config: [__filename],
      },
      name: `${process.env.NODE_ENV || "development"}-cache`,
    };
  }
  ...
}
复制代码
```

另外，我们可以利用浏览器缓存，以及服务器缓存，Redis缓存，去加速我们的系统响应速度，比如配合后端同学利用强缓存或者协商缓存，合理的对客户端请求进行缓存，但是要注意的是，在服务器对web资源代理的时候，对入口的html.index 一定不要做缓存，因为每次更新这个入口依赖的一些js和css都会根据hash指纹有修改，有缓存的话就会造成每次发布用户都要清空浏览器缓存加载才能看到最新的内容

```bash
# nginx前端静态资源配置  // data/docker/nginx/conf.d 
server { 
    listen 8080; 
    server_name _;
    gzip_static on; // 开启gzip压缩
    client_max_body_size 500m; 
    root /data/****/web/dist; 
    index index.html; 
    location ^~ /api { 
        proxy_pass http://***.**.**.***:8080/; 
        proxy_set_header Host ***.**.**.***; 
        proxy_set_header X-Real-IP $remote_addr; 
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
    } 
    location = /index.html {
        add_header Cache-Control "no-cache,no-store";
    }
}

复制代码
```

## 其他一些优化

其实多数项目的性能问题有很多是平时写代码时一些不注意或者是赶项目懒得费劲，一点一点积累的，时间长了就越难进行优化，逐渐形成让人头疼或者难以维护的硬骨头。平时我们一般都应该注意：

- 路由、图片懒加载，第三方按需加载
- tabs 懒加载（切换到对应tab时再渲染）
- keep-alive缓存页面，增加访问速度
- 如果列表纯粹是显示数据，不会有改变，数据就不需要响应式，可以使用Object.freeze方法进行冻结
- 子组件中有一些比较耗时的就单独分割成为一个组件，自己做自己的渲染，不会影响其他的组件
- ……

## 结语

再来回顾一下优化前后的对比

| 优化项       | 优化前 | 优化后 |
| ------------ | ------ | ------ |
| 首屏加载时间 | 30s+   | 2.5s   |
| 打包后的大小 | 28.9M  | 1M     |

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95dceb5b6d0547ee8a5f617112d04739~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f936404c03243e5898ab0dc7a1ac739~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/692acd6501a64d6ea1c0b8cb0f5048dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)



# 源码解读

经过上一篇文章的学习，相信关于 `响应式原理` 源码阅读的入口位置大家都已经知道了，就是初始化过程中处理数据响应式这一步，即调用 `initState` 方法，在 `/src/core/instance/init.js` 文件中。

## initState

> /src/core/instance/state.js

```javascript
/**
 * 两件事：
 *   数据响应式的入口：分别处理 props、methods、data、computed、watch
 *   优先级：props、methods、data、computed 对象中的属性不能出现重复，优先级和列出顺序一致
 *         其中 computed 中的 key 不能和 props、data 中的 key 重复，methods 不影响
 */
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  // 处理 props 对象，为 props 对象的每个属性设置响应式，并将其代理到 vm 实例上
  if (opts.props) initProps(vm, opts.props)
  // 处理 methos 对象，校验每个属性的值是否为函数、和 props 属性比对进行判重处理，最后得到 vm[key] = methods[key]
  if (opts.methods) initMethods(vm, opts.methods)
  /**
   * 做了三件事
   *   1、判重处理，data 对象上的属性不能和 props、methods 对象上的属性相同
   *   2、代理 data 对象上的属性到 vm 实例
   *   3、为 data 对象的上数据设置响应式 
   */
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  /**
   * 三件事：
   *   1、为 computed[key] 创建 watcher 实例，默认是懒执行
   *   2、代理 computed[key] 到 vm 实例
   *   3、判重，computed 中的 key 不能和 data、props 中的属性重复
   */
  if (opts.computed) initComputed(vm, opts.computed)
  /**
   * 三件事：
   *   1、处理 watch 对象
   *   2、为 每个 watch.key 创建 watcher 实例，key 和 watcher 实例可能是 一对多 的关系
   *   3、如果设置了 immediate，则立即执行 回调函数
   */
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
    
  /**
   * 其实到这里也能看出，computed 和 watch 在本质是没有区别的，都是通过 watcher 去实现的响应式
   * 非要说有区别，那也只是在使用方式上的区别，简单来说：
   *   1、watch：适用于当数据变化时执行异步或者开销较大的操作时使用，即需要长时间等待的操作可以放在 watch 中
   *   2、computed：其中可以使用异步方法，但是没有任何意义。所以 computed 更适合做一些同步计算
   */
}

复制代码
```

## initProps

> src/core/instance/state.js

```javascript
// 处理 props 对象，为 props 对象的每个属性设置响应式，并将其代理到 vm 实例上
function initProps (vm: Component, propsOptions: Object) {
  const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  // 缓存 props 的每个 key，性能优化
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false)
  }
  // 遍历 props 对象
  for (const key in propsOptions) {
    // 缓存 key
    keys.push(key)
    // 获取 props[key] 的默认值
    const value = validateProp(key, propsOptions, propsData, vm)
    // 为 props 的每个 key 是设置数据响应式
    defineReactive(props, key, value)
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      // 代理 key 到 vm 对象上
      proxy(vm, `_props`, key)
    }
  }
  toggleObserving(true)
}

复制代码
```

## proxy

> /src/core/instance/state.js

```javascript
// 设置代理，将 key 代理到 target 上
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

复制代码
```

## initMethods

> /src/core/instance/state.js

```javascript
/**
 * 做了以下三件事，其实最关键的就是第三件事情
 *   1、校验 methoss[key]，必须是一个函数
 *   2、判重
 *         methods 中的 key 不能和 props 中的 key 相同
 *         methos 中的 key 与 Vue 实例上已有的方法重叠，一般是一些内置方法，比如以 $ 和 _ 开头的方法
 *   3、将 methods[key] 放到 vm 实例上，得到 vm[key] = methods[key]
 */
function initMethods (vm: Component, methods: Object) {
  // 获取 props 配置项
  const props = vm.$options.props
  // 遍历 methods 对象
  for (const key in methods) {
    if (process.env.NODE_ENV !== 'production') {
      if (typeof methods[key] !== 'function') {
        warn(
          `Method "${key}" has type "${typeof methods[key]}" in the component definition. ` +
          `Did you reference the function correctly?`,
          vm
        )
      }
      if (props && hasOwn(props, key)) {
        warn(
          `Method "${key}" has already been defined as a prop.`,
          vm
        )
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          `Method "${key}" conflicts with an existing Vue instance method. ` +
          `Avoid defining component methods that start with _ or $.`
        )
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm)
  }
}

复制代码
```

## initData

> src/core/instance/state.js

```javascript
/**
 * 做了三件事
 *   1、判重处理，data 对象上的属性不能和 props、methods 对象上的属性相同
 *   2、代理 data 对象上的属性到 vm 实例
 *   3、为 data 对象的上数据设置响应式 
 */
function initData (vm: Component) {
  // 得到 data 对象
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  /**
   * 两件事
   *   1、判重处理，data 对象上的属性不能和 props、methods 对象上的属性相同
   *   2、代理 data 对象上的属性到 vm 实例
   */
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
  // 为 data 对象上的数据设置响应式
  observe(data, true /* asRootData */)
}

export function getData (data: Function, vm: Component): any {
  // #7573 disable dep collection when invoking data getters
  pushTarget()
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, `data()`)
    return {}
  } finally {
    popTarget()
  }
}

复制代码
```

## initComputed

> /src/core/instance/state.js

```javascript
const computedWatcherOptions = { lazy: true }

/**
 * 三件事：
 *   1、为 computed[key] 创建 watcher 实例，默认是懒执行
 *   2、代理 computed[key] 到 vm 实例
 *   3、判重，computed 中的 key 不能和 data、props 中的属性重复
 * @param {*} computed = {
 *   key1: function() { return xx },
 *   key2: {
 *     get: function() { return xx },
 *     set: function(val) {}
 *   }
 * }
 */
function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()

  // 遍历 computed 对象
  for (const key in computed) {
    // 获取 key 对应的值，即 getter 函数
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        `Getter is missing for computed property "${key}".`,
        vm
      )
    }

    if (!isSSR) {
      // 为 computed 属性创建 watcher 实例
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        // 配置项，computed 默认是懒执行
        computedWatcherOptions
      )
    }

    if (!(key in vm)) {
      // 代理 computed 对象中的属性到 vm 实例
      // 这样就可以使用 vm.computedKey 访问计算属性了
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      // 非生产环境有一个判重处理，computed 对象中的属性不能和 data、props 中的属性相同
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      }
    }
  }
}

/**
 * 代理 computed 对象中的 key 到 target（vm）上
 */
export function defineComputed (
  target: any,
  key: string,
  userDef: Object | Function
) {
  const shouldCache = !isServerRendering()
  // 构造属性描述符(get、set)
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef)
    sharedPropertyDefinition.set = noop
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop
    sharedPropertyDefinition.set = userDef.set || noop
  }
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        `Computed property "${key}" was assigned to but it has no setter.`,
        this
      )
    }
  }
  // 拦截对 target.key 的访问和设置
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

/**
 * @returns 返回一个函数，这个函数在访问 vm.computedProperty 时会被执行，然后返回执行结果
 */
function createComputedGetter (key) {
  // computed 属性值会缓存的原理也是在这里结合 watcher.dirty、watcher.evalaute、watcher.update 实现的
  return function computedGetter () {
    // 得到当前 key 对应的 watcher
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      // 计算 key 对应的值，通过执行 computed.key 的回调函数来得到
      // watcher.dirty 属性就是大家常说的 computed 计算结果会缓存的原理
      // <template>
      //   <div>{{ computedProperty }}</div>
      //   <div>{{ computedProperty }}</div>
      // </template>
      // 像这种情况下，在页面的一次渲染中，两个 dom 中的 computedProperty 只有第一个
      // 会执行 computed.computedProperty 的回调函数计算实际的值，
      // 即执行 watcher.evalaute，而第二个就不走计算过程了，
      // 因为上一次执行 watcher.evalute 时把 watcher.dirty 置为了 false，
      // 待页面更新后，wathcer.update 方法会将 watcher.dirty 重新置为 true，
      // 供下次页面更新时重新计算 computed.key 的结果
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}

/**
 * 功能同 createComputedGetter 一样
 */
function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

复制代码
```

## initWatch

> /src/core/instance/state.js

```javascript
/**
 * 处理 watch 对象的入口，做了两件事：
 *   1、遍历 watch 对象
 *   2、调用 createWatcher 函数
 * @param {*} watch = {
 *   'key1': function(val, oldVal) {},
 *   'key2': 'this.methodName',
 *   'key3': {
 *     handler: function(val, oldVal) {},
 *     deep: true
 *   },
 *   'key4': [
 *     'this.methodNanme',
 *     function handler1() {},
 *     {
 *       handler: function() {},
 *       immediate: true
 *     }
 *   ],
 *   'key.key5' { ... }
 * }
 */
function initWatch (vm: Component, watch: Object) {
  // 遍历 watch 对象
  for (const key in watch) {
    const handler = watch[key]
    if (Array.isArray(handler)) {
      // handler 为数组，遍历数组，获取其中的每一项，然后调用 createWatcher
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}

/**
 * 两件事：
 *   1、兼容性处理，保证 handler 肯定是一个函数
 *   2、调用 $watch 
 * @returns 
 */
function createWatcher (
  vm: Component,
  expOrFn: string | Function,
  handler: any,
  options?: Object
) {
  // 如果 handler 为对象，则获取其中的 handler 选项的值
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  // 如果 hander 为字符串，则说明是一个 methods 方法，获取 vm[handler]
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  return vm.$watch(expOrFn, handler, options)
}

/**
 * 创建 watcher，返回 unwatch，共完成如下 5 件事：
 *   1、兼容性处理，保证最后 new Watcher 时的 cb 为函数
 *   2、标示用户 watcher
 *   3、创建 watcher 实例
 *   4、如果设置了 immediate，则立即执行一次 cb
 *   5、返回 unwatch
 * @param {*} expOrFn key
 * @param {*} cb 回调函数
 * @param {*} options 配置项，用户直接调用 this.$watch 时可能会传递一个 配置项
 * @returns 返回 unwatch 函数，用于取消 watch 监听
 */
Vue.prototype.$watch = function (
  expOrFn: string | Function,
  cb: any,
  options?: Object
): Function {
  const vm: Component = this
  // 兼容性处理，因为用户调用 vm.$watch 时设置的 cb 可能是对象
  if (isPlainObject(cb)) {
    return createWatcher(vm, expOrFn, cb, options)
  }
  // options.user 表示用户 watcher，还有渲染 watcher，即 updateComponent 方法中实例化的 watcher
  options = options || {}
  options.user = true
  // 创建 watcher
  const watcher = new Watcher(vm, expOrFn, cb, options)
  // 如果用户设置了 immediate 为 true，则立即执行一次回调函数
  if (options.immediate) {
    try {
      cb.call(vm, watcher.value)
    } catch (error) {
      handleError(error, vm, `callback for immediate watcher "${watcher.expression}"`)
    }
  }
  // 返回一个 unwatch 函数，用于解除监听
  return function unwatchFn () {
    watcher.teardown()
  }
}
复制代码
```

## observe

> /src/core/observer/index.js

```javascript
/**
 * 响应式处理的真正入口
 * 为对象创建观察者实例，如果对象已经被观察过，则返回已有的观察者实例，否则创建新的观察者实例
 * @param {*} value 对象 => {}
 */
export function observe (value: any, asRootData: ?boolean): Observer | void {
  // 非对象和 VNode 实例不做响应式处理
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    // 如果 value 对象上存在 __ob__ 属性，则表示已经做过观察了，直接返回 __ob__ 属性
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    // 创建观察者实例
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}

复制代码
```

## Observer

> /src/core/observer/index.js

```javascript
/**
 * 观察者类，会被附加到每个被观察的对象上，value.__ob__ = this
 * 而对象的各个属性则会被转换成 getter/setter，并收集依赖和通知更新
 */
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    // 实例话一个 dep
    this.dep = new Dep()
    this.vmCount = 0
    // 在 value 对象上设置 __ob__ 属性
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      /**
       * value 为数组
       * hasProto = '__proto__' in {}
       * 用于判断对象是否存在 __proto__ 属性，通过 obj.__proto__ 可以访问对象的原型链
       * 但由于 __proto__ 不是标准属性，所以有些浏览器不支持，比如 IE6-10，Opera10.1
       * 为什么要判断，是因为一会儿要通过 __proto__ 操作数据的原型链
       * 覆盖数组默认的七个原型方法，以实现数组响应式
       */
      if (hasProto) {
        // 有 __proto__
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      // value 为对象，为对象的每个属性（包括嵌套对象）设置响应式
      this.walk(value)
    }
  }

  /**
   * 遍历对象上的每个 key，为每个 key 设置响应式
   * 仅当值为对象时才会走这里
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  /**
   * 遍历数组，为数组的每一项设置观察，处理数组元素为对象的情况
   */
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}

复制代码
```

## defineReactive

> /src/core/observer/index.js

```javascript
/**
 * 拦截 obj[key] 的读取和设置操作：
 *   1、在第一次读取时收集依赖，比如执行 render 函数生成虚拟 DOM 时会有读取操作
 *   2、在更新时设置新值并通知依赖更新
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // 实例化 dep，一个 key 一个 dep
  const dep = new Dep()

  // 获取 obj[key] 的属性描述符，发现它是不可配置对象的话直接 return
  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  // 记录 getter 和 setter，获取 val 值
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  // 递归调用，处理 val 即 obj[key] 的值为对象的情况，保证对象中的所有 key 都被观察
  let childOb = !shallow && observe(val)
  // 响应式核心
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    // get 拦截对 obj[key] 的读取操作
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      /**
       * Dep.target 为 Dep 类的一个静态属性，值为 watcher，在实例化 Watcher 时会被设置
       * 实例化 Watcher 时会执行 new Watcher 时传递的回调函数（computed 除外，因为它懒执行）
       * 而回调函数中如果有 vm.key 的读取行为，则会触发这里的 读取 拦截，进行依赖收集
       * 回调函数执行完以后又会将 Dep.target 设置为 null，避免这里重复收集依赖
       */
      if (Dep.target) {
        // 依赖收集，在 dep 中添加 watcher，也在 watcher 中添加 dep
        dep.depend()
        // childOb 表示对象中嵌套对象的观察者对象，如果存在也对其进行依赖收集
        if (childOb) {
          // 这就是 this.key.chidlKey 被更新时能触发响应式更新的原因
          childOb.dep.depend()
          // 如果是 obj[key] 是 数组，则触发数组响应式
          if (Array.isArray(value)) {
            // 为数组项为对象的项添加依赖
            dependArray(value)
          }
        }
      }
      return value
    },
    // set 拦截对 obj[key] 的设置操作
    set: function reactiveSetter (newVal) {
      // 旧的 obj[key]
      const value = getter ? getter.call(obj) : val
      // 如果新老值一样，则直接 return，不跟新更不触发响应式更新过程
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      // setter 不存在说明该属性是一个只读属性，直接 return
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      // 设置新值
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      // 对新值进行观察，让新值也是响应式的
      childOb = !shallow && observe(newVal)
      // 依赖通知更新
      dep.notify()
    }
  })
}

复制代码
```

### dependArray

> /src/core/observer/index.js

```javascript
/**
 * 遍历每个数组元素，递归处理数组项为对象的情况，为其添加依赖
 * 因为前面的递归阶段无法为数组中的对象元素添加依赖
 */
function dependArray (value: Array<any>) {
  for (let e, i = 0, l = value.length; i < l; i++) {
    e = value[i]
    e && e.__ob__ && e.__ob__.dep.depend()
    if (Array.isArray(e)) {
      dependArray(e)
    }
  }
}

复制代码
```

## 数组响应式

> src/core/observer/array.js

```javascript
/**
 * 定义 arrayMethods 对象，用于增强 Array.prototype
 * 当访问 arrayMethods 对象上的那七个方法时会被拦截，以实现数组响应式
 */
import { def } from '../util/index'

// 备份 数组 原型对象
const arrayProto = Array.prototype
// 通过继承的方式创建新的 arrayMethods
export const arrayMethods = Object.create(arrayProto)

// 操作数组的七个方法，这七个方法可以改变数组自身
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * 拦截变异方法并触发事件
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  // 缓存原生方法，比如 push
  const original = arrayProto[method]
  // def 就是 Object.defineProperty，拦截 arrayMethods.method 的访问
  def(arrayMethods, method, function mutator (...args) {
    // 先执行原生方法，比如 push.apply(this, args)
    const result = original.apply(this, args)
    const ob = this.__ob__
    // 如果 method 是以下三个之一，说明是新插入了元素
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    // 对新插入的元素做响应式处理
    if (inserted) ob.observeArray(inserted)
    // 通知更新
    ob.dep.notify()
    return result
  })
})


复制代码
```

### def

> /src/core/util/lang.js

```javascript
/**
 * Define a property.
 */
export function def (obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}

复制代码
```

### protoAugment

> /src/core/observer/index.js

```javascript
/**
 * 设置 target.__proto__ 的原型对象为 src
 * 比如 数组对象，arr.__proto__ = arrayMethods
 */
function protoAugment (target, src: Object) {
  /* eslint-disable no-proto */
  target.__proto__ = src
  /* eslint-enable no-proto */
}

复制代码
```

### copyAugment

> /src/core/observer/index.js

```javascript
/**
 * 在目标对象上定义指定属性
 * 比如数组：为数组对象定义那七个方法
 */
function copyAugment (target: Object, src: Object, keys: Array<string>) {
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i]
    def(target, key, src[key])
  }
}

复制代码
```

## Dep

> /src/core/observer/dep.js

```javascript
import type Watcher from './watcher'
import { remove } from '../util/index'
import config from '../config'

let uid = 0

/**
 * 一个 dep 对应一个 obj.key
 * 在读取响应式数据时，负责收集依赖，每个 dep（或者说 obj.key）依赖的 watcher 有哪些
 * 在响应式数据更新时，负责通知 dep 中那些 watcher 去执行 update 方法
 */
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  // 在 dep 中添加 watcher
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  // 像 watcher 中添加 dep
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  /**
   * 通知 dep 中的所有 watcher，执行 watcher.update() 方法
   */
  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort((a, b) => a.id - b.id)
    }
    // 遍历 dep 中存储的 watcher，执行 watcher.update()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}

/**
 * 当前正在执行的 watcher，同一时间只会有一个 watcher 在执行
 * Dep.target = 当前正在执行的 watcher
 * 通过调用 pushTarget 方法完成赋值，调用 popTarget 方法完成重置（null)
 */
Dep.target = null
const targetStack = []

// 在需要进行依赖收集的时候调用，设置 Dep.target = watcher
export function pushTarget (target: ?Watcher) {
  targetStack.push(target)
  Dep.target = target
}

// 依赖收集结束调用，设置 Dep.target = null
export function popTarget () {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}

复制代码
```

## Watcher

> /src/core/observer/watcher.js

```javascript
/**
 * 一个组件一个 watcher（渲染 watcher）或者一个表达式一个 watcher（用户watcher）
 * 当数据更新时 watcher 会被触发，访问 this.computedProperty 时也会触发 watcher
 */
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      // this.getter = function() { return this.xx }
      // 在 this.get 中执行 this.getter 时会触发依赖收集
      // 待后续 this.xx 更新时就会触发响应式
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * 执行 this.getter，并重新收集依赖
   * this.getter 是实例化 watcher 时传递的第二个参数，一个函数或者字符串，比如：updateComponent 或者 parsePath 返回的读取 this.xx 属性值的函数
   * 为什么要重新收集依赖？
   *   因为触发更新说明有响应式数据被更新了，但是被更新的数据虽然已经经过 observe 观察了，但是却没有进行依赖收集，
   *   所以，在更新页面时，会重新执行一次 render 函数，执行期间会触发读取操作，这时候进行依赖收集
   */
  get () {
    // 打开 Dep.target，Dep.target = this
    pushTarget(this)
    // value 为回调函数执行的结果
    let value
    const vm = this.vm
    try {
      // 执行回调函数，比如 updateComponent，进入 patch 阶段
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value)
      }
      // 关闭 Dep.target，Dep.target = null
      popTarget()
      this.cleanupDeps()
    }
    return value
  }

  /**
   * Add a dependency to this directive.
   * 两件事：
   *   1、添加 dep 给自己（watcher）
   *   2、添加自己（watcher）到 dep
   */
  addDep (dep: Dep) {
    // 判重，如果 dep 已经存在则不重复添加
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      // 缓存 dep.id，用于判重
      this.newDepIds.add(id)
      // 添加 dep
      this.newDeps.push(dep)
      // 避免在 dep 中重复添加 watcher，this.depIds 的设置在 cleanupDeps 方法中
      if (!this.depIds.has(id)) {
        // 添加 watcher 自己到 dep
        dep.addSub(this)
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
  cleanupDeps () {
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }

  /**
   * 根据 watcher 配置项，决定接下来怎么走，一般是 queueWatcher
   */
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      // 懒执行时走这里，比如 computed

      // 将 dirty 置为 true，可以让 computedGetter 执行时重新计算 computed 回调函数的执行结果
      this.dirty = true
    } else if (this.sync) {
      // 同步执行，在使用 vm.$watch 或者 watch 选项时可以传一个 sync 选项，
      // 当为 true 时在数据更新时该 watcher 就不走异步更新队列，直接执行 this.run 
      // 方法进行更新
      // 这个属性在官方文档中没有出现
      this.run()
    } else {
      // 更新时一般都这里，将 watcher 放入 watcher 队列
      queueWatcher(this)
    }
  }

  /**
   * 由 刷新队列函数 flushSchedulerQueue 调用，完成如下几件事：
   *   1、执行实例化 watcher 传递的第二个参数，updateComponent 或者 获取 this.xx 的一个函数(parsePath 返回的函数)
   *   2、更新旧值为新值
   *   3、执行实例化 watcher 时传递的第三个参数，比如用户 watcher 的回调函数
   */
  run () {
    if (this.active) {
      // 调用 this.get 方法
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // 更新旧值为新值
        const oldValue = this.value
        this.value = value

        if (this.user) {
          // 如果是用户 watcher，则执行用户传递的第三个参数 —— 回调函数，参数为 val 和 oldVal
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          // 渲染 watcher，this.cb = noop，一个空函数
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }

  /**
   * 懒执行的 watcher 会调用该方法
   *   比如：computed，在获取 vm.computedProperty 的值时会调用该方法
   * 然后执行 this.get，即 watcher 的回调函数，得到返回值
   * this.dirty 被置为 false，作用是页面在本次渲染中只会一次 computed.key 的回调函数，
   *   这也是大家常说的 computed 和 methods 区别之一是 computed 有缓存的原理所在
   * 而页面更新后会 this.dirty 会被重新置为 true，这一步是在 this.update 方法中完成的
   */
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   */
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  /**
   * Remove self from all dependencies' subscriber list.
   */
  teardown () {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}

复制代码
```

# 总结

**面试官 问**：Vue 响应式原理是怎么实现的？

**答**：

- 响应式的核心是通过 `Object.defineProperty` 拦截对数据的访问和设置
- 响应式的数据分为两类：
  - 对象，循环遍历对象的所有属性，为每个属性设置 getter、setter，以达到拦截访问和设置的目的，如果属性值依旧为对象，则递归为属性值上的每个 key 设置 getter、setter
    - 访问数据时（obj.key)进行依赖收集，在 dep 中存储相关的 watcher
    - 设置数据时由 dep 通知相关的 watcher 去更新
  - 数组，增强数组的那 7 个可以更改自身的原型方法，然后拦截对这些方法的操作
    - 添加新数据时进行响应式处理，然后由 dep 通知 watcher 去更新
    - 删除数据时，也要由 dep 通知 watcher 去更新

**面试官 问**：methods、computed 和 watch 有什么区别？

**答**：

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <title>methods、computed、watch 有什么区别</title>
</head>

<body>
  <div id="app">
    <!-- methods -->
    <div>{{ returnMsg() }}</div>
    <div>{{ returnMsg() }}</div>
    <!-- computed -->
    <div>{{ getMsg }}</div>
    <div>{{ getMsg }}</div>
  </div>
  <script src="../../dist/vue.js"></script>
  <script>
    new Vue({
    el: '#app',
    data: {
      msg: 'test'
    },
    mounted() {
      setTimeout(() => {
        this.msg = 'msg is changed'
      }, 1000)
    },
    methods: {
      returnMsg() {
        console.log('methods: returnMsg')
        return this.msg
      }
    },
    computed: {
      getMsg() {
        console.log('computed: getMsg')
        return this.msg + ' hello computed'
      }
    },
    watch: {
      msg: function(val, oldVal) {
        console.log('watch: msg')
        new Promise(resolve => {
          setTimeout(() => {
            this.msg = 'msg is changed by watch'
          }, 1000)
        })
      }
    }
  })
  </script>
</body>

</html>

复制代码
```

![methodsComputedWatch.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c957654bb484ae7ba4ace1b912cff03~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

示例其实就是答案了

- 使用场景

  - methods 一般用于封装一些较为复杂的处理逻辑（同步、异步）
  - computed 一般用于封装一些简单的同步逻辑，将经过处理的数据返回，然后显示在模版中，以减轻模版的重量
  - watch 一般用于当需要在数据变化时执行异步或开销较大的操作

- 区别

  - methods VS computed

    > 通过示例会发现，如果在一次渲染中，有多个地方使用了同一个 methods 或 computed 属性，methods 会被执行多次，而 computed 的回调函数则只会被执行一次。

    > 通过阅读源码我们知道，在一次渲染中，多次访问 computedProperty，只会在第一次执行 computed 属性的回调函数，后续的其它访问，则直接使用第一次的执行结果（watcher.value），而这一切的实现原理则是通过对 watcher.dirty 属性的控制实现的。而 methods，每一次的访问则是简单的方法调用（this.xxMethods）。

  - computed VS watch

    > 通过阅读源码我们知道，computed 和 watch 的本质是一样的，内部都是通过 Watcher 来实现的，其实没什么区别，非要说区别的化就两点：1、使用场景上的区别，2、computed 默认是懒执行的，切不可更改。

  - methods VS watch

    > methods 和 watch 之间其实没什么可比的，完全是两个东西，不过在使用上可以把 watch 中一些逻辑抽到 methods 中，提高代码的可读性。



作者：李永宁
链接：https://juejin.cn/post/6950826293923414047
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 找入口

想知道 `new Vue(options)` 都做了什么，就得先找到 Vue 的构造函数是在哪声明的，有两个办法：

- 从 rollup 配置文件中找到编译的入口，然后一步步找到 Vue 构造函数，这种方式 **费劲**
- 通过编写示例代码，然后打断点的方式，一步到位，**简单**

我们就采用第二种方式，写示例，打断点，一步到位。

- 在 `/examples` 目录下增加一个示例文件 —— `test.html`，在文件中添加如下内容：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vue 源码解读</title>
</head>
<body>
  <div id="app">
    {{ msg }}
  </div>
  <script src="../dist/vue.js"></script>
  <script>
    debugger
    new Vue({
      el: '#app',
      data: {
        msg: 'hello vue'
      }
    })
  </script>
</body>
</html>
复制代码
```

- 在浏览器中打开控制台，然后打开 `test.html`，则会进入断点调试，然后找到 Vue 构造函数所在的文件

![Mar-26-2021 08-30-52.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d839ea6f3e5d4adcaf1ea9a8f6ff1a70~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

得到 Vue 构造函数在 `/src/core/instance/index.js` 文件中，接下来正式开始源码阅读，带着目标去阅读。

> 在阅读过程中如遇到看不明白的地方，可通过编写示例代码，然后使用浏览器的调试功能进行一步步调试，配合理解，如果还是理解不了，就做个备注继续向后看，也许你看到其它地方，就突然明白这个地方在做什么，或者回头再来看，就会懂了，源码这个东西，一定要多看，要想精通，一遍两遍肯定是不够的

# 源码解读 —— Vue 初始化过程

## Vue

> /src/core/instance/index.js

```javascript
import { initMixin } from './init'

// Vue 构造函数
function Vue (options) {
  // 调用 Vue.prototype._init 方法，该方法是在 initMixin 中定义的
  this._init(options)
}

// 定义 Vue.prototype._init 方法
initMixin(Vue)

export default Vue
复制代码
```

## Vue.prototype._init

> /src/core/instance/init.js

```javascript
/**
 * 定义 Vue.prototype._init 方法 
 * @param {*} Vue Vue 构造函数
 */
export function initMixin (Vue: Class<Component>) {
  // 负责 Vue 的初始化过程
  Vue.prototype._init = function (options?: Object) {
    // vue 实例
    const vm: Component = this
    // 每个 vue 实例都有一个 _uid，并且是依次递增的
    vm._uid = uid++

    // a flag to avoid this being observed
    vm._isVue = true
    // 处理组件配置项
    if (options && options._isComponent) {
      /**
       * 每个子组件初始化时走这里，这里只做了一些性能优化
       * 将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率
       */
      initInternalComponent(vm, options)
    } else {
      /**
       * 初始化根组件时走这里，合并 Vue 的全局配置到根组件的局部配置，比如 Vue.component 注册的全局组件会合并到 根实例的 components 选项中
       * 至于每个子组件的选项合并则发生在两个地方：
       *   1、Vue.component 方法注册的全局组件在注册时做了选项合并
       *   2、{ components: { xx } } 方式注册的局部组件在执行编译器生成的 render 函数时做了选项合并，包括根组件中的 components 配置
       */
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      // 设置代理，将 vm 实例上的属性代理到 vm._renderProxy
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    // 初始化组件实例关系属性，比如 $parent、$children、$root、$refs 等
    initLifecycle(vm)
    /**
     * 初始化自定义事件，这里需要注意一点，所以我们在 <comp @click="handleClick" /> 上注册的事件，监听者不是父组件，
     * 而是子组件本身，也就是说事件的派发和监听者都是子组件本身，和父组件无关
     */
    initEvents(vm)
    // 解析组件的插槽信息，得到 vm.$slot，处理渲染函数，得到 vm.$createElement 方法，即 h 函数
    initRender(vm)
    // 调用 beforeCreate 钩子函数
    callHook(vm, 'beforeCreate')
    // 初始化组件的 inject 配置项，得到 result[key] = val 形式的配置对象，然后对结果数据进行响应式处理，并代理每个 key 到 vm 实例
    initInjections(vm) // resolve injections before data/props
    // 数据响应式的重点，处理 props、methods、data、computed、watch
    initState(vm)
    // 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上
    initProvide(vm) // resolve provide after data/props
    // 调用 created 钩子函数
    callHook(vm, 'created')

    // 如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount，反之，没有 el 则必须手动调用 $mount
    if (vm.$options.el) {
      // 调用 $mount 方法，进入挂载阶段
      vm.$mount(vm.$options.el)
    }
  }
}

复制代码
```

## resolveConstructorOptions

> /src/core/instance/init.js

```javascript
/**
 * 从组件构造函数中解析配置对象 options，并合并基类选项
 * @param {*} Ctor 
 * @returns 
 */
export function resolveConstructorOptions (Ctor: Class<Component>) {
  // 配置项目
  let options = Ctor.options
  if (Ctor.super) {
    // 存在基类，递归解析基类构造函数的选项
    const superOptions = resolveConstructorOptions(Ctor.super)
    const cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      // 说明基类构造函数选项已经发生改变，需要重新设置
      Ctor.superOptions = superOptions
      // 检查 Ctor.options 上是否有任何后期修改/附加的选项（＃4976）
      const modifiedOptions = resolveModifiedOptions(Ctor)
      // 如果存在被修改或增加的选项，则合并两个选项
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      // 选项合并，将合并结果赋值为 Ctor.options
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  return options
}

复制代码
```

## resolveModifiedOptions

> /src/core/instance/init.js

```javascript
/**
 * 解析构造函数选项中后续被修改或者增加的选项
 */
function resolveModifiedOptions (Ctor: Class<Component>): ?Object {
  let modified
  // 构造函数选项
  const latest = Ctor.options
  // 密封的构造函数选项，备份
  const sealed = Ctor.sealedOptions
  // 对比两个选项，记录不一致的选项
  for (const key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) modified = {}
      modified[key] = latest[key]
    }
  }
  return modified
}

复制代码
```

## mergeOptions

> /src/core/util/options.js

```javascript
/**
 * 合并两个选项，出现相同配置项时，子选项会覆盖父选项的配置
 */
export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
): Object {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child)
  }

  if (typeof child === 'function') {
    child = child.options
  }

  // 标准化 props、inject、directive 选项，方便后续程序的处理
  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  // 处理原始 child 对象上的 extends 和 mixins，分别执行 mergeOptions，将这些继承而来的选项合并到 parent
  // mergeOptions 处理过的对象会含有 _base 属性
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm)
    }
    if (child.mixins) {
      for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options = {}
  let key
  // 遍历 父选项
  for (key in parent) {
    mergeField(key)
  }

  // 遍历 子选项，如果父选项不存在该配置，则合并，否则跳过，因为父子拥有同一个属性的情况在上面处理父选项时已经处理过了，用的子选项的值
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }

  // 合并选项，childVal 优先级高于 parentVal
  function mergeField (key) {
    // strats = Object.create(null)
    const strat = strats[key] || defaultStrat
    // 值为如果 childVal 存在则优先使用 childVal，否则使用 parentVal
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}

复制代码
```

## initInjections

> /src/core/instance/inject.js

```javascript
/**
 * 初始化 inject 配置项
 *   1、得到 result[key] = val
 *   2、对结果数据进行响应式处理，代理每个 key 到 vm 实例
 */
export function initInjections (vm: Component) {
  // 解析 inject 配置项，然后从祖代组件的配置中找到 配置项中每一个 key 对应的 val，最后得到 result[key] = val 的结果
  const result = resolveInject(vm.$options.inject, vm)
  // 对 result 做 数据响应式处理，也有代理 inject 配置中每个 key 到 vm 实例的作用。
  // 不不建议在子组件去更改这些数据，因为一旦祖代组件中 注入的 provide 发生更改，你在组件中做的更改就会被覆盖
  if (result) {
    toggleObserving(false)
    Object.keys(result).forEach(key => {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        defineReactive(vm, key, result[key], () => {
          warn(
            `Avoid mutating an injected value directly since the changes will be ` +
            `overwritten whenever the provided component re-renders. ` +
            `injection being mutated: "${key}"`,
            vm
          )
        })
      } else {
        defineReactive(vm, key, result[key])
      }
    })
    toggleObserving(true)
  }
}

复制代码
```

## resolveInject

> /src/core/instance/inject.js

```javascript
/**
 * 解析 inject 配置项，从祖代组件的 provide 配置中找到 key 对应的值，否则用 默认值，最后得到 result[key] = val
 * inject 对象肯定是以下这个结构，因为在 合并 选项时对组件配置对象做了标准化处理
 * @param {*} inject = {
 *  key: {
 *    from: provideKey,
 *    default: xx
 *  }
 * }
 */
export function resolveInject (inject: any, vm: Component): ?Object {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    const result = Object.create(null)
    // inject 配置项的所有的 key
    const keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject)

    // 遍历 key
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i]
      // 跳过 __ob__ 对象
      // #6574 in case the inject object is observed...
      if (key === '__ob__') continue
      // 拿到 provide 中对应的 key
      const provideKey = inject[key].from
      let source = vm
      // 遍历所有的祖代组件，直到 根组件，找到 provide 中对应 key 的值，最后得到 result[key] = provide[provideKey]
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey]
          break
        }
        source = source.$parent
      }
      // 如果上一个循环未找到，则采用 inject[key].default，如果没有设置 default 值，则抛出错误
      if (!source) {
        if ('default' in inject[key]) {
          const provideDefault = inject[key].default
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault
        } else if (process.env.NODE_ENV !== 'production') {
          warn(`Injection "${key}" not found`, vm)
        }
      }
    }
    return result
  }
}

复制代码
```

## initProvide

> /src/core/instance/inject.js

```javascript
/**
 * 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上 
 */
export function initProvide (vm: Component) {
  const provide = vm.$options.provide
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide
  }
}

复制代码
```

# 总结

Vue 的初始化过程（new Vue(options)）都做了什么？

- 处理组件配置项
  - 初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上
  - 初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率
- 初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等
- 处理自定义事件
- 调用 beforeCreate 钩子函数
- 初始化组件的 inject 配置项，得到 `ret[key] = val` 形式的配置对象，然后对该配置对象进行浅层的响应式处理（只处理了对象第一层数据），并代理每个 key 到 vm 实例上
- 数据响应式，处理 props、methods、data、computed、watch 等选项
- 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上
- 调用 created 钩子函数
- 如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount
- 接下来则进入挂载阶段

# 链接

- [配套视频，关注微信公众号回复](https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fliyongning%2Ftypora-image-bed%2Fraw%2Fmaster%2F202202171742614.jpg)："精通 Vue 技术栈源码原理视频版" 获取
- [精通 Vue 技术栈源码原理 专栏](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA3NTk4NjQ1OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2273541436891693065%23wechat_redirect)
- [github 仓库 liyongning/Vue](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fliyongning%2FVue) 欢迎 Star

感谢各位的：**点赞**、**收藏**和**评论**，我们下期见。



作者：李永宁
链接：https://juejin.cn/post/6950084496515399717
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。