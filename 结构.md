## 题目

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

## [#](https://www.conardli.top/docs/algorithm/查找/二维数组查找.html#基本思路)基本思路

二维数组是有序的，比如下面的数据：

```text
1 2 3
4 5 6
7 8 9
```



可以直接利用左下角数字开始查找：

大于：比较上移

小于：比较右移

## [#](https://www.conardli.top/docs/algorithm/查找/二维数组查找.html#代码思路)代码思路

将二维数组看作平面坐标系

从左下角（0,arr.length-1）开始比较：

目标值大于坐标值---x坐标+1

目标值小于坐标值---y坐标-1

注意：

二维数组arr[i][j]中

j代表x坐标

i代表y坐标

## [#](https://www.conardli.top/docs/algorithm/查找/二维数组查找.html#代码)代码

```js
    function Find(target, array) {
      let i = array.length - 1; // y坐标
      let j = 0; // x坐标
      return compare(target, array, i, j);
    }

    function compare(target, array, i, j) {
      if (array[i] === undefined || array[i][j] === undefined) {
        return false;
      }
      const temp = array[i][j];
      if (target === temp) {
        return true;
      }
      else if (target > temp) {
        return compare(target, array, i, j+1);
      }
      else if (target < temp) {
        return compare(target, array, i-1, j);
      }
    }
```



## [#](https://www.conardli.top/docs/algorithm/查找/二维数组查找.html#拓展-二分查找)拓展：二分查找

二分查找的条件是必须有序。

和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。

```js
    function binarySearch(data, arr, start, end) {
        if (start > end) {
            return -1;
        }
        var mid = Math.floor((end + start) / 2);
        if (data == arr[mid]) {
            return mid;
        } else if (data < arr[mid]) {
            return binarySearch(data, arr, start, mid - 1);
        } else {
            return binarySearch(data, arr, mid + 1, end);
        }
    }
```

## 题目

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组`{3,4,5,1,2}`为`{1,2,3,4,5}`的一个旋转，该数组的最小值为1。

> NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

## [#](https://www.conardli.top/docs/algorithm/查找/旋转数组的最小数字.html#基本思路)基本思路

肯定不能直接遍历，失去了这道题的意义

旋转数组其实是由两个有序数组拼接而成的，因此我们可以使用二分法，只需要找到拼接点即可。

(1)`array[mid] > array[high]`:

出现这种情况的`array`类似`[3,4,5,6,0,1,2]`，此时最小数字一定在mid的右边。 `low = mid + 1`

(2)`array[mid] == array[high]`:

出现这种情况的`array`类似 `[1,0,1,1,1]`或者`[1,1,1,0,1]`，此时最小数字不好判断在mid左边 还是右边,这时只好一个一个试 。 `high = high - 1`

(3)`array[mid] < array[high]`:

出现这种情况的`array`类似`[2,2,3,4,5,6,6]`,此时最小数字一定就是`array[mid]`或者在`mid`的左 边。因为右边必然都是递增的。 `high = mid`

## [#](https://www.conardli.top/docs/algorithm/查找/旋转数组的最小数字.html#代码)代码

```js
function minNumberInRotateArray(arr)
{
    let len = arr.length;
    if(len == 0)  return 0;
    let low = 0, high = len - 1;
    while(low < high) {
        let mid = low + Math.floor((high-low)/2);
        if(arr[mid] > arr[high]) {
            low = mid + 1;
        } else if(arr[mid] == arr[high]) {
            high = high - 1;
        } else {
            high = mid;
        }
    }
 
    return arr[low];
}
```



## [#](https://www.conardli.top/docs/algorithm/查找/旋转数组的最小数字.html#扩展)扩展

二分查找

```js
        function binarySearch(data, arr, start, end) {
            if (start > end) {
                return -1;
            }
            var mid = Math.floor((end + start) / 2);
            if (data == arr[mid]) {
                return mid;
            } else if (data < arr[mid]) {
                return binarySearch(data, arr, start, mid - 1);
            } else {
                return binarySearch(data, arr, mid + 1, end);
            }
        }
```

## 题目

统计一个数字在排序数组中出现的次数。

## [#](https://www.conardli.top/docs/algorithm/查找/在排序数组中查找数字.html#思路)思路

本道题有好几种解法

- 1.直接遍历数组，判断前后的值是否相同，找到元素开始位置和结束位置，时间复杂度`O(n)`
- 2.使用二分查找找到目标值，在向前向后遍历，找到所有的数，比上面略优，时间复杂度也是`O(n)`
- 3.使用二分查找分别找到第一个目标值出现的位置和最后一个位置，时间复杂度`O(logn)`

## [#](https://www.conardli.top/docs/algorithm/查找/在排序数组中查找数字.html#代码)代码

在排序数组中找元素，首先考虑使用二分查找

下面是使用二分查找在数组中寻找某个数

```js
        function binarySearch(data, arr, start, end) {
            if (start > end) {
                return -1;
            }
            var mid = Math.floor((end + start) / 2);
            if (data == arr[mid]) {
                return mid;
            } else if (data < arr[mid]) {
                return binarySearch(data, arr, start, mid - 1);
            } else {
                return binarySearch(data, arr, mid + 1, end);
            }
        }
```



找到第一次和最后一次出现的位置我们只需要对上面的代码进行稍加的变形

第一次位置：找到目标值，并且前一位的数字和当前值不相等

最后一次位置：找到目标值，并且后一位的数字和当前值不相等

```js
    function GetNumberOfK(data, k) {
      if (data && data.length > 0 && k != null) {
        const firstIndex = getFirstK(data, 0, data.length - 1, k);
        const lastIndex = getLastK(data, 0, data.length - 1, k);
        if (firstIndex != -1 && lastIndex != -1) {
          return lastIndex - firstIndex + 1;
        }
      }
      return 0;
    }

    function getFirstK(data, first, last, k) {
      if (first > last) {
        return -1;
      }
      const mid = parseInt((first + last) / 2);
      if (data[mid] === k) {
        if (data[mid - 1] != k) {
          return mid;
        } else {
          return getFirstK(data, first, mid-1, k);
        }
      } else if (data[mid] > k) {
        return getFirstK(data, first, mid - 1, k);
      } else if (data[mid] < k) {
        return getFirstK(data, mid + 1, last, k);
      }
    }

    function getLastK(data, first, last, k) {
      if (first > last) {
        return -1;
      }
      const mid = parseInt((first + last) / 2);
      if (data[mid] === k) {
        if (data[mid + 1] != k) {
          return mid;
        } else {
          return getLastK(data, mid + 1, last, k);
        }
      } else if (data[mid] > k) {
        return getLastK(data, first, mid - 1, k);
      } else if (data[mid] < k) {
        return getLastK(data, mid + 1, last, k);
      }
    }
```

### 广度优先搜索

广度优先搜索（`BFS`）是一种遍历或搜索数据结构（如树或图）的算法，也可以在更抽象的场景中使用。

它的特点是越是接近根结点的结点将越早地遍历。

例如，我们可以使用 `BFS` 找到从起始结点到目标结点的路径，特别是最短路径。

在`BFS`中，结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出，所以广度优先搜索一般使用队列实现。

- [从上到下打印二叉树(opens new window)](http://www.conardli.top/docs/dataStructure/二叉树/从上到下打印二叉树.html)
- [单词接龙(opens new window)](https://leetcode-cn.com/problems/word-ladder/)
- [员工的重要性(opens new window)](https://leetcode-cn.com/problems/employee-importance/)
- [岛屿数量(opens new window)](https://leetcode-cn.com/problems/number-of-islands/)

### [#](https://www.conardli.top/docs/algorithm/DFS和BFS/DFS和BFS.html#深度优先搜索)深度优先搜索

和广度优先搜索一样，深度优先搜索（`DFS`）是用于在树/图中遍历/搜索的一种重要算法。

与 `BFS` 不同，更早访问的结点可能不是更靠近根结点的结点。因此，你在`DFS` 中找到的第一条路径可能不是最短路径。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/20/16cac3549dee7c41~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

在`DFS`中，结点的处理顺序是完全相反的顺序，就像它们被添加到栈中一样，它是后进先出。所以深度优先搜索一般使用栈实现。

- [二叉树的中序遍历(opens new window)](http://www.conardli.top/docs/dataStructure/二叉树/二叉树的中序遍历.html)
- [二叉树的最大深度(opens new window)](http://www.conardli.top/docs/dataStructure/二叉树/二叉树的最大深度.html)
- [路径总和(opens new window)](https://leetcode-cn.com/problems/path-sum/)
- [课程表(opens new window)](https://leetcode-cn.com/problems/course-schedule/)
- [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

## 题目1-不分行从上到下打印

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

## [#](https://www.conardli.top/docs/datastructure/二叉树/从上到下打印二叉树.html#思路)思路

- 在打印第一行时，将左孩子节点和右孩子节点存入一个队列里
- 队列元素出队列打印，同时分别将左孩子节点和右孩子节点存入队列
- 这样打印二叉树的顺序就是没行从左到右打印

## [#](https://www.conardli.top/docs/datastructure/二叉树/从上到下打印二叉树.html#代码)代码

```js
    function PrintFromTopToBottom(root) {
      const result = [];
      const queue = [];
      if (root) {
        queue.push(root);
        while (queue.length > 0) {
          const current = queue.shift();
          if (current.left) {
            queue.push(current.left);
          }
          if (current.right) {
            queue.push(current.right);
          }
          result.push(current.val);
        }
      }
      return result;
    }
```



## [#](https://www.conardli.top/docs/datastructure/二叉树/从上到下打印二叉树.html#题目2-把二叉树打印成多行)题目2-把二叉树打印成多行

从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。

## [#](https://www.conardli.top/docs/datastructure/二叉树/从上到下打印二叉树.html#思路-2)思路

- 使用一个队列存储当前层遍历的节点
- 使用两个变量来标记当前遍历的状态
- currentNums：当前层剩余的节点数
- childNums：孩子节点数
- 当前层遍历完成后开始遍历孩子节点，currentNums赋值为childNums，childNums赋值为0，

## [#](https://www.conardli.top/docs/datastructure/二叉树/从上到下打印二叉树.html#代码-2)代码

```js
    function Print(root) {
      const result = [];
      const queue = [];
      let tempArr = [];
      let currentNums = 1;
      let childNums = 0;
      if (root) {
        queue.push(root);
        while (queue.length > 0) {
          const current = queue.shift();
          if (current.left) {
            queue.push(current.left);
            childNums++;
          }
          if (current.right) {
            queue.push(current.right);
            childNums++;
          }
          tempArr.push(current.val);
          currentNums--;
          if (currentNums === 0) {
            currentNums = childNums;
            childNums = 0;
            result.push(tempArr);
            tempArr = [];
          }
        }
      }
      return result;
    }
```



## [#](https://www.conardli.top/docs/datastructure/二叉树/从上到下打印二叉树.html#题目3-按之字形顺序打印二叉树)题目3-按之字形顺序打印二叉树

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

## [#](https://www.conardli.top/docs/datastructure/二叉树/从上到下打印二叉树.html#思路-3)思路

奇数从左到右，偶数从右到左

- 若当前层为奇数层，从左到右打印，同时填充下一层，从右到左打印（先填充左孩子节点再填充右孩子节点）。
- 若当前层为偶数层，从右到左打印，同时填充下一层，从左到右打印（先填充右孩子节点再填充左孩子节点）。
- 不难发现，我们可以使用栈来作为存储结构。
- 分别设定一个奇数栈和一个偶数栈， 从将二叉树头部元素存入奇数栈开始。

> 这里同样可使用上面2题的两个变量来记录层数，只需要一个栈即可，但是代码不如两个栈容易理解。

## [#](https://www.conardli.top/docs/datastructure/二叉树/从上到下打印二叉树.html#代码-3)代码

```js
    function Print(root) {
      const result = [];
      const oddStack = [];
      const evenStack = [];
      let temp = [];
      if (root) {
        oddStack.push(root);
        while (oddStack.length > 0 || evenStack.length > 0) {

          while (oddStack.length > 0) {
            const current = oddStack.pop();
            temp.push(current.val);
            if (current.left) {
              evenStack.push(current.left);
            }
            if (current.right) {
              evenStack.push(current.right);
            }
          }
          if (temp.length > 0) {
            result.push(temp);
            temp = [];
          }

          while (evenStack.length > 0) {
            const current = evenStack.pop();
            temp.push(current.val);
            if (current.right) {
              oddStack.push(current.right);
            }
            if (current.left) {
              oddStack.push(current.left);
            }
          }
          if (temp.length > 0) {
            result.push(temp);
            temp = [];
          }

        }
      }
      return result;
    }
```

## 模拟实现call

- 1.判断当前`this`是否为函数，防止`Function.prototype.myCall()` 直接调用
- 2.`context` 为可选参数，如果不传的话默认上下文为 `window`
- 3.为`context` 创建一个 `Symbol`（保证不会重名）属性，将当前函数赋值给这个属性
- 4.处理参数，传入第一个参数后的其余参数
- 4.调用函数后即删除该`Symbol`属性

```js
    Function.prototype.myCall = function (context = window, ...args) {
      if (this === Function.prototype) {
        return undefined; // 用于防止 Function.prototype.myCall() 直接调用
      }
      context = context || window;
      const fn = Symbol();
      context[fn] = this;
      const result = context[fn](...args);
      delete context[fn];
      return result;
    }
```



## [#](https://www.conardli.top/docs/JavaScript/手动实现call、apply、bind.html#模拟实现apply)模拟实现apply

`apply`实现类似`call`，参数为数组

```js
    Function.prototype.myApply = function (context = window, args) {
      if (this === Function.prototype) {
        return undefined; // 用于防止 Function.prototype.myCall() 直接调用
      }
      const fn = Symbol();
      context[fn] = this;
      let result;
      if (Array.isArray(args)) {
        result = context[fn](...args);
      } else {
        result = context[fn]();
      }
      delete context[fn];
      return result;
    }
```



## [#](https://www.conardli.top/docs/JavaScript/手动实现call、apply、bind.html#模拟实现bind)模拟实现bind

- 1.处理参数，返回一个闭包
- 2.判断是否为构造函数调用，如果是则使用`new`调用当前函数
- 3.如果不是，使用`apply`，将`context`和处理好的参数传入

```js
    Function.prototype.myBind = function (context,...args1) {
      if (this === Function.prototype) {
        throw new TypeError('Error')
      }
      const _this = this
      return function F(...args2) {
        // 判断是否用于构造函数
        if (this instanceof F) {
          return new _this(...args1, ...args2)
        }
        return _this.apply(context, args1.concat(args2))
      }
    }
```



## [#](https://www.conardli.top/docs/JavaScript/手动实现call、apply、bind.html#扩展)扩展

获取函数中的参数：

```js
    // 获取argument对象 类数组对象 不能调用数组方法
    function test1() {
      console.log('获取argument对象 类数组对象 不能调用数组方法', arguments);
    }

    // 获取参数数组  可以调用数组方法
    function test2(...args) {
      console.log('获取参数数组  可以调用数组方法', args);
    }

    // 获取除第一个参数的剩余参数数组
    function test3(first, ...args) {
      console.log('获取argument对象 类数组对象 不能调用数组方法', args);
    }

    // 透传参数
    function test4(first, ...args) {
      fn(...args);
      fn(...arguments);
    }

    function fn() {
      console.log('透传', ...arguments);
    }

    test1(1, 2, 3);
    test2(1, 2, 3);
    test3(1, 2, 3);
    test4(1, 2, 3);
```

## 观察者模式

![image](http://img.blog.csdn.net/20161126191512446)

这就类似我们在微信平台订阅了公众号 , 当它有新的文章发表后，就会推送给我们所有订阅的人。

我们作为订阅者不必每次都去查看这个公众号有没有新文章发布，公众号作为发布者会在合适时间通知我们。

我们与公众号之间不再强耦合在一起。公众号不关心谁订阅了它， 不管你是男是女还是宠物狗，它只需要定时向所有订阅者发布消息即可。

### [#](https://www.conardli.top/docs/JavaScript/EventEmitter.html#观察者模式的优点)观察者模式的优点

- 可以广泛应用于异步编程，它可以代替我们传统的回调函数
- 我们不需要关注对象在异步执行阶段的内部状态，我们只关心事件完成的时间点
- 取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起 。

虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象。

## [#](https://www.conardli.top/docs/JavaScript/EventEmitter.html#nodejs的eventemitter)Nodejs的EventEmitter

`Nodejs`的`EventEmitter`就是观察者模式的典型实现，`Nodejs`的`events`模块只提供了一个对象： `events.EventEmitter``。EventEmitter` 的核心就是事件触发与事件监听器功能的封装。

> Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。

### [#](https://www.conardli.top/docs/JavaScript/EventEmitter.html#api)Api

**addListener(event, listener)**

为指定事件添加一个监听器，默认添加到监听器数组的尾部。

**removeListener(event, listener)**

移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。

**setMaxListeners(n)**

默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。

**once(event, listener)**

为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。

**emit(event, [arg1], [arg2], [...])**

按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 `true`，否则返回 `false`。

### [#](https://www.conardli.top/docs/JavaScript/EventEmitter.html#基本使用)基本使用

```js
var events = require('events');
var eventEmitter = new events.EventEmitter();

// 监听器 #1
var listener1 = function listener1() {
   console.log('监听器 listener1 执行。');
}

// 监听器 #2
var listener2 = function listener2() {
  console.log('监听器 listener2 执行。');
}

// 绑定 connection 事件，处理函数为 listener1 
eventEmitter.addListener('connection', listener1);

// 绑定 connection 事件，调用一次，处理函数为 listener2
eventEmitter.once('connection', listener2);

// 处理 connection 事件 
eventEmitter.emit('connection');

// 处理 connection 事件 
eventEmitter.emit('connection');
```



## [#](https://www.conardli.top/docs/JavaScript/EventEmitter.html#手动实现eventemitter)手动实现EventEmitter

```js
    function EventEmitter() {
      this._maxListeners = 10;
      this._events = Object.create(null);
    }

    // 向事件队列添加事件
    // prepend为true表示向事件队列头部添加事件
    EventEmitter.prototype.addListener = function (type, listener, prepend) {
      if (!this._events) {
        this._events = Object.create(null);
      }
      if (this._events[type]) {
        if (prepend) {
          this._events[type].unshift(listener);
        } else {
          this._events[type].push(listener);
        }
      } else {
        this._events[type] = [listener];
      }
    };

    // 移除某个事件
    EventEmitter.prototype.removeListener = function (type, listener) {
      if (Array.isArray(this._events[type])) {
        if (!listener) {
          delete this._events[type]
        } else {
          this._events[type] = this._events[type].filter(e => e !== listener && e.origin !== listener)
        }
      }
    };

    // 向事件队列添加事件，只执行一次
    EventEmitter.prototype.once = function (type, listener) {
      const only = (...args) => {
        listener.apply(this, args);
        this.removeListener(type, listener);
      }
      only.origin = listener;
      this.addListener(type, only);
    };

    // 执行某类事件
    EventEmitter.prototype.emit = function (type, ...args) {
      if (Array.isArray(this._events[type])) {
        this._events[type].forEach(fn => {
          fn.apply(this, args);
        });
      }
    };

    // 设置最大事件监听个数
    EventEmitter.prototype.setMaxListeners = function (count) {
      this.maxListeners = count;
    };
```



测试代码：

```js
    var emitter = new EventEmitter();

    var onceListener = function (args) {
      console.log('我只能被执行一次', args, this);
    }

    var listener = function (args) {
      console.log('我是一个listener', args, this);
    }

    emitter.once('click', onceListener);
    emitter.addListener('click', listener);

    emitter.emit('click', '参数');
    emitter.emit('click');

    emitter.removeListener('click', listener);
    emitter.emit('click');
```



## [#](https://www.conardli.top/docs/JavaScript/EventEmitter.html#javascript自定义事件)JavaScript自定义事件

`DOM`也提供了类似上面`EventEmitter`的`API`，基本使用：

```js
//1、创建事件
var myEvent = new Event("myEvent");

//2、注册事件监听器
elem.addEventListener("myEvent",function(e){
  
})

//3、触发事件
elem.dispatchEvent(myEvent);
```

## 原理

防抖（`debounce`）：不管事件触发频率多高，一定在事件触发`n`秒后才执行，如果你在一个事件触发的 `n` 秒内又触发了这个事件，就以新的事件的时间为准，`n`秒后才执行，总之，触发完事件 `n` 秒内不再触发事件，`n`秒后再执行。

![foo](https://www.conardli.top/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96.gif)

### [#](https://www.conardli.top/docs/JavaScript/防抖.html#窗口大小变化-调整样式)窗口大小变化，调整样式

```js
window.addEventListener('resize', debounce(handleResize, 200));
```



### [#](https://www.conardli.top/docs/JavaScript/防抖.html#搜索框-输入后1000毫秒搜索)搜索框，输入后1000毫秒搜索

```js
debounce(fetchSelectData, 300);
```



### [#](https://www.conardli.top/docs/JavaScript/防抖.html#表单验证-输入1000毫秒后验证)表单验证，输入1000毫秒后验证

```js
debounce(validator, 1000);
```



## [#](https://www.conardli.top/docs/JavaScript/防抖.html#实现)实现

注意考虑两个问题：

- 在`debounce`函数中返回一个闭包，这里用的普通`function`，里面的`setTimeout`则用的箭头函数，这样做的意义是让`this`的指向准确，`this`的真实指向并非`debounce`的调用者，而是返回闭包的调用者。
- 对传入闭包的参数进行透传。

```js
    function debounce(event, time) {
      let timer = null;
      return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
          event.apply(this, args);
        }, time);
      };
    }
```



有时候我们需要让函数立即执行一次，再等后面事件触发后等待`n`秒执行，我们给`debounce`函数一个`flag`用于标示是否立即执行。

当定时器变量`timer`为空时，说明是第一次执行，我们立即执行它。

```js
    function debounce(event, time, flag) {
      let timer = null;
      return function (...args) {
        clearTimeout(timer);
        if (flag && !timer) {
          event.apply(this, args);
        }
        timer = setTimeout(() => {
          event.apply(this, args);
        }, time);
      };
    }
```

## 定义

节流（`throttle`）:不管事件触发频率多高，只在单位时间内执行一次。

![foo](https://www.conardli.top/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96.gif)

有两种方式可以实现节流，使用时间戳和定时器。

### [#](https://www.conardli.top/docs/JavaScript/节流.html#时间戳实现)时间戳实现

> 第一次事件肯定触发，最后一次不会触发

```js
    function throttle(event, time) {
      let pre = 0;
      return function (...args) {
        if (Date.now() - pre > time) {
          pre = Date.now();
          event.apply(this, args);
        }
      }
```



### [#](https://www.conardli.top/docs/JavaScript/节流.html#定时器实现)定时器实现

> 第一次事件不会触发，最后一次一定触发

```js
    function throttle(event, time) {
      let timer = null;
      return function (...args) {
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            event.apply(this, args);
          }, time);
        }
      }
    }
```



### [#](https://www.conardli.top/docs/JavaScript/节流.html#结合版)结合版

> 定时器和时间戳的结合版，也相当于节流和防抖的结合版，第一次和最后一次都会触发

```js
    function throttle(event, time) {
      let pre = 0;
      let timer = null;
      return function (...args) {
        if (Date.now() - pre > time) {
          clearTimeout(timer);
          timer = null;
          pre = Date.now();
          event.apply(this, args);
        } else if (!timer) {
          timer = setTimeout(() => {
            event.apply(this, args);
          }, time);
        }
      }
    }
```

关于为什么会有深拷贝和浅拷贝，实际上就是基本类型和引用类型的问题，可以参考我这篇文章：[JS进阶】你真的掌握变量和类型了吗(opens new window)](http://www.conardli.top/2019/05/28/【JS进阶】你真的掌握变量和类型了吗/)

### [#](https://www.conardli.top/docs/JavaScript/浅拷贝和深拷贝.html#浅拷贝)浅拷贝

我们用很多简单的方法都能实现浅拷贝：

```js
arr.slice();
arr.concat();
```



### [#](https://www.conardli.top/docs/JavaScript/浅拷贝和深拷贝.html#深拷贝)深拷贝

我们也能用简单的办法实现深拷贝：

```
JSON.parse(JSON.stringify(obj))
```

手动实现：

> 代码解析后面放出来。

```js
const mapTag = '[object Map]';
const setTag = '[object Set]';
const arrayTag = '[object Array]';
const objectTag = '[object Object]';
const argsTag = '[object Arguments]';

const boolTag = '[object Boolean]';
const dateTag = '[object Date]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];


function forEach(array, iteratee) {
    let index = -1;
    const length = array.length;
    while (++index < length) {
        iteratee(array[index], index);
    }
    return array;
}

function isObject(target) {
    const type = typeof target;
    return target !== null && (type === 'object' || type === 'function');
}

function getType(target) {
    return Object.prototype.toString.call(target);
}

function getInit(target) {
    const Ctor = target.constructor;
    return new Ctor();
}

function cloneSymbol(targe) {
    return Object(Symbol.prototype.valueOf.call(targe));
}

function cloneReg(targe) {
    const reFlags = /\w*$/;
    const result = new targe.constructor(targe.source, reFlags.exec(targe));
    result.lastIndex = targe.lastIndex;
    return result;
}

function cloneFunction(func) {
    const bodyReg = /(?<={)(.|\n)+(?=})/m;
    const paramReg = /(?<=\().+(?=\)\s+{)/;
    const funcString = func.toString();
    if (func.prototype) {
        const param = paramReg.exec(funcString);
        const body = bodyReg.exec(funcString);
        if (body) {
            if (param) {
                const paramArr = param[0].split(',');
                return new Function(...paramArr, body[0]);
            } else {
                return new Function(body[0]);
            }
        } else {
            return null;
        }
    } else {
        return eval(funcString);
    }
}

function cloneOtherType(targe, type) {
    const Ctor = targe.constructor;
    switch (type) {
        case boolTag:
        case numberTag:
        case stringTag:
        case errorTag:
        case dateTag:
            return new Ctor(targe);
        case regexpTag:
            return cloneReg(targe);
        case symbolTag:
            return cloneSymbol(targe);
        case funcTag:
            return cloneFunction(targe);
        default:
            return null;
    }
}

function clone(target, map = new WeakMap()) {

    // 克隆原始类型
    if (!isObject(target)) {
        return target;
    }

    // 初始化
    const type = getType(target);
    let cloneTarget;
    if (deepTag.includes(type)) {
        cloneTarget = getInit(target, type);
    } else {
        return cloneOtherType(target, type);
    }

    // 防止循环引用
    if (map.get(target)) {
        return target;
    }
    map.set(target, cloneTarget);

    // 克隆set
    if (type === setTag) {
        target.forEach(value => {
            cloneTarget.add(clone(value));
        });
        return cloneTarget;
    }

    // 克隆map
    if (type === mapTag) {
        target.forEach((value, key) => {
            cloneTarget.set(key, clone(value));
        });
        return cloneTarget;
    }

    // 克隆对象和数组
    const keys = type === arrayTag ? undefined : Object.keys(target);
    forEach(keys || target, (value, key) => {
        if (keys) {
            key = value;
        }
        cloneTarget[key] = clone(target[key], map);
    });

    return cloneTarget;
}
```

## 去重

### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#object)Object

开辟一个外部存储空间用于标示元素是否出现过。

```js
const unique = (array)=> {
    var container = {};
    return array.filter((item, index) =>  container.hasOwnProperty(item) ? false : (container[item] = true));
}
```



### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#indexof-filter)indexOf + filter

```js
const unique = arr => arr.filter((e,i) => arr.indexOf(e) === i);
```



### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#set)Set

```js
const unique = arr => Array.from(new Set(arr));
```



```js
const unique = arr => [...new Set(arr)];
```



### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#排序)排序

通过比较相邻数字是否重复，将排序后的数组进行去重。

```js
    const unique = (array) => {
      array.sort((a, b) => a - b);
      let pre = 0;
      const result = [];
      for (let i = 0; i < array.length; i++) {
        if (!i || array[i] != array[pre]) {
          result.push(array[i]);
        }
        pre = i;
      }
      return result;
    }
```



### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#去除重复的值)去除重复的值

不同于上面的去重，这里是只要数字出现了重复次，就将其移除掉。

```js
const filterNonUnique = arr => arr.filter(i => 
  arr.indexOf(i) === arr.lastIndexOf(i)
)
```



## [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#扁平)扁平

### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#基本实现)基本实现

```js
    const flat = (array) => {
      let result = [];
      for (let i = 0; i < array.length; i++) {
        if (Array.isArray(array[i])) {
          result = result.concat(flat(array[i]));
        } else {
          result.push(array[i]);
        }
      }
      return result;
    }
```



### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#使用reduce简化)使用reduce简化

```js
    function flatten(array) {
      return array.reduce(
        (target, current) =>
          Array.isArray(current) ?
            target.concat(flatten(current)) :
            target.concat(current)
        , [])
    }
```



### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#根据指定深度扁平数组)根据指定深度扁平数组

```js
    function flattenByDeep(array, deep = 1) {
      return array.reduce(
        (target, current) =>
          Array.isArray(current) && deep > 1 ?
            target.concat(flattenByDeep(current, deep - 1)) :
            target.concat(current)
        , [])
    }
```



## [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#最值)最值

### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#reduce)reduce

```js
array.reduce((c,n)=>Math.max(c,n))
```



### [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#math-max)Math.max

`Math.max`参数原本是一组数字，只需要让他可以接收数组即可。

```js
const array = [3,2,1,4,5];
Math.max.apply(null,array);
Math.max(...array);
```



## [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#使用reduce实现map)使用reduce实现map

```js
    Array.prototype.reduceToMap = function (handler) {
      return this.reduce((target, current, index) => {
        target.push(handler.call(this, current, index))
        return target;
      }, [])
    };
```



## [#](https://www.conardli.top/docs/JavaScript/数组去重、扁平、最值.html#使用reduce实现filter)使用reduce实现filter

```js
    Array.prototype.reduceToFilter = function (handler) {
      return this.reduce((target, current, index) => {
        if (handler.call(this, current, index)) {
          target.push(current);
        }
        return target;
      }, [])
    };
```

从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。

```js
    function disorder(array) {
      const length = array.length;
      let current = length - 1;
      let random;
      while (current >-1) {
        random = Math.floor(length * Math.random());
        [array[current], array[random]] = [array[random], array[current]];
        current--;
      }
      return array;
    }
```

- 1.将传入的data数据转化为url字符串形式
- 2.处理url中的回调函数
- 3.创建一个script标签并插入到页面中
- 4.挂载回调函数

```js
(function (window,document) {
    "use strict";
    var jsonp = function (url,data,callback) {

        // 1.将传入的data数据转化为url字符串形式
        // {id:1,name:'jack'} => id=1&name=jack
        var dataString = url.indexof('?') == -1? '?': '&';
        for(var key in data){
            dataString += key + '=' + data[key] + '&';
        };

        // 2 处理url中的回调函数
        // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）
        var cbFuncName = 'my_json_cb_' + Math.random().toString().replace('.','');
        dataString += 'callback=' + cbFuncName;

        // 3.创建一个script标签并插入到页面中
        var scriptEle = document.createElement('script');
        scriptEle.src = url + dataString;

        // 4.挂载回调函数
        window[cbFuncName] = function (data) {
            callback(data);
            // 处理完回调函数的数据之后，删除jsonp的script标签
            document.body.removeChild(scriptEle);
        }

        document.body.appendChild(scriptEle);
    }

    window.$jsonp = jsonp;

})(window,document)
```

## 基础版本

- 设定三个状态 `PENDING、FULFILLED、REJECTED` ，只能由`PENDING`改变为`FULFILLED、REJECTED`，并且只能改变一次
- `MyPromise`接收一个函数`executor`，`executor`有两个参数`resolve`方法和`reject`方法
- `resolve`将`PENDING`改变为`FULFILLED`
- `reject`将`PENDING`改变为`FULFILLED`
- `promise`变为`FULFILLED`状态后具有一个唯一的`value`
- `promise`变为`REJECTED`状态后具有一个唯一的`reason`

```js
    const PENDING = 'pending';
    const FULFILLED = 'fulfilled';
    const REJECTED = 'rejected';

    function MyPromise(executor) {
      this.state = PENDING;
      this.value = null;
      this.reason = null;

      const resolve = (value) => {
        if (this.state === PENDING) {
          this.state = FULFILLED;
          this.value = value;
        }
      }

      const reject = (reason) => {
        if (this.state === PENDING) {
          this.state = REJECTED;
          this.reason = reason;
        }
      }

      try {
        executor(resolve, reject);
      } catch (reason) {
        reject(reason);
      }
    }
```



## [#](https://www.conardli.top/docs/JavaScript/模拟实现promise.html#then方法)then方法

- `then`方法接受两个参数`onFulfilled、onRejected`，它们分别在状态由`PENDING`改变为`FULFILLED、REJECTED`后调用
- 一个`promise`可绑定多个`then`方法
- `then`方法可以同步调用也可以异步调用
- 同步调用：状态已经改变，直接调用`onFulfilled`方法
- 异步调用：状态还是`PENDING`，将`onFulfilled、onRejected`分别加入两个函数数组`onFulfilledCallbacks、onRejectedCallbacks`，当异步调用`resolve`和`reject`时，将两个数组中绑定的事件循环执行。

```js
  function MyPromise(executor) {
      this.state = PENDING;
      this.value = null;
      this.reason = null;
      this.onFulfilledCallbacks = [];
      this.onRejectedCallbacks = [];

      const resolve = (value) => {
        if (this.state === PENDING) {
          this.state = FULFILLED;
          this.value = value;
          this.onFulfilledCallbacks.forEach(fun => {
            fun();
          });
        }
      }

      const reject = (reason) => {
        if (this.state === PENDING) {
          this.state = REJECTED;
          this.reason = reason;
          this.onRejectedCallbacks.forEach(fun => {
            fun();
          });
        }
      }

      try {
        executor(resolve, reject);
      } catch (reason) {
        reject(reason);
      }
    }

    MyPromise.prototype.then = function (onFulfilled, onRejected) {
      switch (this.state) {
        case FULFILLED:
          onFulfilled(this.value);
          break;
        case REJECTED:
          onFulfilled(this.value);
          break;
        case PENDING:
          this.onFulfilledCallbacks.push(() => {
            onFulfilled(this.value);
          })
          this.onRejectedCallbacks.push(() => {
            onRejected(this.reason);
          })
          break;
      }
    }
```



## [#](https://www.conardli.top/docs/JavaScript/模拟实现promise.html#then方法异步调用)then方法异步调用

如下面的代码：输入顺序是：`1、2、ConardLi`

```js
console.log(1);

let promise = new Promise((resolve, reject) => {
  resolve('ConardLi');
});

promise.then((value) => {
  console.log(value);
});

console.log(2);
```



虽然`resolve`是同步执行的，我们必须保证`then`是异步调用的，我们用`settimeout`来模拟异步调用（并不能实现微任务和宏任务的执行机制，只是保证异步调用）

```js
    MyPromise.prototype.then = function (onFulfilled, onRejected) {
      if (typeof onFulfilled != 'function') {
        onFulfilled = function (value) {
          return value;
        }
      }
      if (typeof onRejected != 'function') {
        onRejected = function (reason) {
          throw reason;
        }
      }
      switch (this.state) {
        case FULFILLED:
          setTimeout(() => {
            onFulfilled(this.value);
          }, 0);
          break;
        case REJECTED:
          setTimeout(() => {
            onRejected(this.reason);
          }, 0);
          break;
        case PENDING:
          this.onFulfilledCallbacks.push(() => {
            setTimeout(() => {
              onFulfilled(this.value);
            }, 0);
          })
          this.onRejectedCallbacks.push(() => {
            setTimeout(() => {
              onRejected(this.reason);
            }, 0);
          })
          break;
      }
    }
```



## [#](https://www.conardli.top/docs/JavaScript/模拟实现promise.html#then方法链式调用)then方法链式调用

保证链式调用，即`then`方法中要返回一个新的`promise`，并将`then`方法的返回值进行`resolve`。

> 注意：这种实现并不能保证`then`方法中返回一个新的`promise`，只能保证链式调用。

```js
    MyPromise.prototype.then = function (onFulfilled, onRejected) {
      if (typeof onFulfilled != 'function') {
        onFulfilled = function (value) {
          return value;
        }
      }
      if (typeof onRejected != 'function') {
        onRejected = function (reason) {
          throw reason;
        }
      }
      const promise2 = new MyPromise((resolve, reject) => {
        switch (this.state) {
          case FULFILLED:
            setTimeout(() => {
              try {
                const x = onFulfilled(this.value);
                resolve(x);
              } catch (reason) {
                reject(reason);
              }
            }, 0);
            break;
          case REJECTED:
            setTimeout(() => {
              try {
                const x = onRejected(this.reason);
                resolve(x);
              } catch (reason) {
                reject(reason);
              }
            }, 0);
            break;
          case PENDING:
            this.onFulfilledCallbacks.push(() => {
              setTimeout(() => {
                try {
                  const x = onFulfilled(this.value);
                  resolve(x);
                } catch (reason) {
                  reject(reason);
                }
              }, 0);
            })
            this.onRejectedCallbacks.push(() => {
              setTimeout(() => {
                try {
                  const x = onRejected(this.reason);
                  resolve(x);
                } catch (reason) {
                  reject(reason);
                }
              }, 0);
            })
            break;
        }
      })
      return promise2;
    }
```



## [#](https://www.conardli.top/docs/JavaScript/模拟实现promise.html#catch方法)catch方法

若上面没有定义`reject`方法，所有的异常会走向`catch`方法：

```js
MyPromise.prototype.catch = function(onRejected) {
  return this.then(null, onRejected);
};
```



## [#](https://www.conardli.top/docs/JavaScript/模拟实现promise.html#finally方法)finally方法

不管是`resolve`还是`reject`都会调用`finally`。

```js
MyPromise.prototype.finally = function(fn) {
    return this.then(value => {
       fn();
       return value;
    }, reason => {
        fn();
        throw reason;
    });
};
```



## [#](https://www.conardli.top/docs/JavaScript/模拟实现promise.html#promise-resolve)Promise.resolve

`Promise.resolve`用来生成一个直接处于`FULFILLED`状态的Promise。

```js
MyPromise.reject = function(value) {
  return new MyPromise((resolve, reject) => {
    resolve(value);
  });
};
```



## [#](https://www.conardli.top/docs/JavaScript/模拟实现promise.html#promise-reject)Promise.reject

`Promise.reject`用来生成一个直接处于`REJECTED`状态的Promise。

```js
MyPromise.reject = function(reason) {
  return new MyPromise((resolve, reject) => {
    reject(reason);
  });
};
```



## [#](https://www.conardli.top/docs/JavaScript/模拟实现promise.html#all方法)all方法

接受一个`promise`数组，当所有`promise`状态`resolve`后，执行`resolve`

```js
    MyPromise.all = function (promises) {
      return new Promise((resolve, reject) => {
        if (promises.length === 0) {
          resolve([]);
        } else {
          let result = [];
          let index = 0;
          for (let i = 0; i < promises.length; i++) {
            promises[i].then(data => {
              result[i] = data;
              if (++index === promises.length) {
                resolve(result);
              }
            }, err => {
              reject(err);
              return;
            });
          }
        }
      });
    }
```



## [#](https://www.conardli.top/docs/JavaScript/模拟实现promise.html#race方法)race方法

接受一个`promise`数组，当有一个`promise`状态`resolve`后，执行`resolve`

```js
    MyPromise.race = function (promises) {
      return new Promise((resolve, reject) => {
        if (promises.length === 0) {
          resolve();
        } else {
          let index = 0;
          for (let i = 0; i < promises.length; i++) {
            promises[i].then(data => {
              resolve(data);
            }, err => {
              reject(err);
              return;
            });
          }
        }
      });
    }
```

有下面两个类，下面实现`Man`继承`People`：

```js
    function People() {
      this.type = 'prople'
    }

    People.prototype.eat = function () {
      console.log('吃东西啦');
    }

    function Man(name) {
      this.name = name;
      this.color = 'black';
    }
```



## [#](https://www.conardli.top/docs/JavaScript/手动实现ES5继承.html#原型继承)原型继承

> 将父类指向子类的原型。

```js
Man.prototype = new People();
```



缺点：原型是所有子类实例共享的，改变一个其他也会改变。

------

## [#](https://www.conardli.top/docs/JavaScript/手动实现ES5继承.html#构造继承)构造继承

> 在子类构造函数中调用父类构造函数

```js
    function Man(name) {
      People.call(this);
    }
```



缺点：不能继承父类原型，函数在构造函数中，每个子类实例不能共享函数，浪费内存。

## [#](https://www.conardli.top/docs/JavaScript/手动实现ES5继承.html#组合继承)组合继承

> 使用构造继承继承父类参数，使用原型继承继承父类函数

```js
    function Man(name) {
      People.call(this);
    }

    Man.prototype = People.prototype;
```



缺点：父类原型和子类原型是同一个对象，无法区分子类真正是由谁构造。

## [#](https://www.conardli.top/docs/JavaScript/手动实现ES5继承.html#寄生组合继承)寄生组合继承

> 在组合继承的基础上，子类继承一个由父类原型生成的空对象。

```js
    function Man(name) {
      People.call(this);
    }

    Man.prototype = Object.create(People.prototype, {
      constructor: {
        value: Man
      }
    })
```



## [#](https://www.conardli.top/docs/JavaScript/手动实现ES5继承.html#inherits函数)inherits函数：

```js
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}; 
```



使用：

```js
function Man() {
  People.call(this);
  //...
}
inherits(Man, People);

Man.prototype.fun = ...
```

## 原理

```js
a instanceof Object
```



判断`Object`的prototype是否在`a`的原型链上。

## [#](https://www.conardli.top/docs/JavaScript/手动实现instanceof.html#实现)实现

```js
    function myInstanceof(target, origin) {
      const proto = target.__proto__;
      if (proto) {
        if (origin.prototype === proto) {
          return true;
        } else {
          return myInstanceof(proto, origin)
        }
      } else {
        return false;
      }
    }
```

基于把原生`ajax`封装为`Promise`形式。

参数封装的有点简陋...后面继续优化

```js
    function ajax(url, method = 'get', param = {}) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const paramString = getStringParam(param);
        if (method === 'get' && paramString) {
          url.indexOf('?') > -1 ? url += paramString : url += `?${paramString}`
        }
        xhr.open(method, url);
        xhr.onload = function () {
          const result = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: xhr.getAllResponseHeaders(),
            data: xhr.response || xhr.responseText
          }
          if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
            resolve(result);
          } else {
            reject(result);
          }
        }
        // 设置请求头
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        // 跨域携带cookie
        xhr.withCredentials = true;
        // 错误处理
        xhr.onerror = function () {
          reject(new TypeError('请求出错'));
        }
        xhr.timeout = function () {
          reject(new TypeError('请求超时'));
        }
        xhr.onabort = function () {
          reject(new TypeError('请求被终止'));
        }
        if (method === 'post') {
          xhr.send(paramString);
        } else {
          xhr.send();
        }
      })
    }

    function getStringParam(param) {
      let dataString = '';
      for (const key in param) {
        dataString += `${key}=${param[key]}&`
      }
      return dataString;
    }
```

在合适的时候才创建对像，并且只创建唯一的一个。

创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。

使用闭包实现：

```js
var Singleton = function(name) {
    this.name = name;
};

Singleton.prototype.getName = function() {
    alert(this.name);
};

Singleton.getInstance = (function(name) {
    var instance;
    return function(name){
        if (!instance) {
            instance = new Singleton(name);
        }
        return instance;
    }
})();

var a = Singleton.getInstance('ConardLi');
var b = Singleton.getInstance('ConardLi2');

console.log(a===b);   //true
```

### 引言

不同与我们之前介绍的线性结构，今天我们介绍一种非线性结构：树，树的内容比较多，包括BST树、AVL树、Trie树等，这部分内容将放在下几个章节陆续放出，本章将介绍树与二叉树的基础必会内容，在开始这一章节前，请思考以下内容：

- 什么是树？
- 树的高度怎么计算？
- 什么是二叉树？
- 什么是平衡二叉树？
- 在代码中如何表示一棵二叉树？
- 二叉树的前序、中序、后序遍历又是什么？如何实现？
- 能否用递归及迭代两种方式实现喃？

下面进入本节内容👇

### 一、树

不同于我们上面介绍的线性结构，树是一种非线性结构。

图：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e0db6a424~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



它遵循：

- 仅有唯一一个根节点，没有节点则为空树
- 除根节点外，每个节点都有并仅有唯一一个父节点
- 节点间不能形成闭环

这就是树！

树有几个概念：

- 拥有相同父节点的节点，互称为兄弟节点
- **节点的深度** ：从根节点到该节点所经历的边的个数
- **节点的高度** ：节点到叶节点的最长路径
- 树的高度：根节点的高度



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e4a831d24~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



B、C、D就互称为兄弟节点，其中，节点B的高度为2，节点B的深度为 1，树的高度为3

#### 高度

树的高度计算公式：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e57410c78~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



下图每个节点值都代表来当前节点的高度：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e1e136378~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



### 二、二叉树

二叉树，故名思义，最多仅有两个子节点的树（最多能分两个叉的树🤦‍♀️）：

图：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e1c381b26~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



### 三、平衡二叉树

二叉树中，每一个节点的左右子树的高度相差不能大于 1，称为平衡二叉树。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e1dfd954f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



另外还有满二叉树、完全二叉树等：

- **满二叉树**：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树
- **完全二叉树**：深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h 层所有的结点都连续集中在最左边

### 四、在代码中如何去表示一棵二叉树

#### 1. 链式存储法

二叉树的存储很简单，在二叉树中，我们看到每个节点都包含三部分：

- 当前节点的 val
- 左子节点 left
- 右子节点 right

所以我们可以将每个节点定义为：

```kotlin
function Node(val) {
    // 保存当前节点 key 值
    this.val = val
    // 指向左子节点
    this.left = null
    // 指向右子节点
    this.right = null
}
复制代码
```

一棵二叉树可以由根节点通过左右指针连接起来形成一个树。

```javascript
function BinaryTree() {
  let Node = function (val) {
    this.val = val
    this.left = null
    this.right = null
  }
  let root = null
}
复制代码
```

#### 2. 数组存储法（适用于完全二叉树）

下图就是一棵完全二叉树，

如果我们把根节点存放在位置 `i=1` 的位置，则它的左子节点位置为 `2i = 2` ，右子节点位置为 `2i+1 = 3` 。

如果我们选取 B 节点 `i=2` ，则它父节点为 `i/2 = 1` ，左子节点 `2i=4` ，右子节点  `2i+1=5` 。

以此类推，我们发现所有的节点都满足这三种关系：

- 位置为 i 的节点，它的父节点位置为 `i/2`
- 它的左子节点 `2i`
- 它的右子节点  `2i+1`

因此，如果我们把完全二叉树存储在数组里（从下标为 1 开始存储），我们完全可以通过下标找到任意节点的父子节点。从而完整的构建出这个完全二叉树。这就是数组存储法。

数组存储法相对于链式存储法不需要为每个节点创建它的左右指针，更为节省内存。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e4acfb302~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



### 五、二叉树的遍历

二叉树的遍历可分为：

- 前序遍历
- 中序遍历
- 后序遍历

所谓前、中、后，不过是根的顺序，即也可以称为先根遍历、中根遍历、后根遍历

#### 1. 前序遍历

对于二叉树中的任意一个节点，先打印该节点，然后是它的左子树，最后右子树



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e66c55995~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



#### 2. 中序遍历

对于二叉树中的任意一个节点，先打印它的左子树，然后是该节点，最后右子树



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e5defdbab~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



#### 3. 后序遍历

对于二叉树中的任意一个节点，先打印它的左子树，然后是右子树，最后该节点



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/12/1720480e69652b1f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



#### 4. 代码实现（前序遍历为例）

所以，遍历二叉树的过程也就是一个递归的过程，例如前序遍历，先遍历根节点，然后是根的左子树，最后右子树；遍历根节点的左子树的时候，又是先遍历左子树的根节点，然后左子树的左子树，左子树的右子树…….

所以，它的核心代码就是：

```scss
// 前序遍历核心代码
var preOrderTraverseNode = (node) => {
    if(node) {
        // 先根节点
        result.push(node.val)
        // 然后遍历左子树
        preOrderTraverseNode(node.left)
        // 再遍历右子树
        preOrderTraverseNode(node.right)
    }
}
复制代码
```

完整代码如下：

##### 递归实现

```scss
// 前序遍历
var preorderTraversal = (root) => {
    let result = []
    var preOrderTraverseNode = (node) => {
        if(node) {
            // 先根节点
            result.push(node.val)
            // 然后遍历左子树
            preOrderTraverseNode(node.left)
            // 再遍历右子树
            preOrderTraverseNode(node.right)
        }
    }
    preOrderTraverseNode(root)
    return result
};
复制代码
```

我们既然可以使用递归实现，那么是否也可以使用迭代实现喃？

##### 迭代实现

利用栈来记录遍历的过程，实际上，递归就使用了调用栈，所以这里我们可以使用栈来模拟递归的过程

- 首先根入栈
- 将根节点出栈，将根节点值放入结果数组中
- 然后遍历左子树、右子树，因为栈是先入后出，所以，我们先右子树入栈，然后左子树入栈
- 继续出栈（左子树被出栈）…….

依次循环出栈遍历入栈，直到栈为空，遍历完成

```scss
// 前序遍历
const preorderTraversal = (root) => {
    const list = [];
    const stack = [];
    
    // 当根节点不为空的时候，将根节点入栈
    if(root) stack.push(root)
    while(stack.length > 0) {
        const curNode = stack.pop()
        // 第一步的时候，先访问的是根节点
        list.push(curNode.val)
        
        // 我们先打印左子树，然后右子树
        // 所以先加入栈的是右子树，然后左子树
        if(curNode.right !== null) {
            stack.push(curNode.right)
        }
        if(curNode.left !== null) {
            stack.push(curNode.left)
        }
    }
    return list
}
复制代码
```

##### 复杂度分析：

空间复杂度：O(n)

时间复杂度：O(n)

至此，我们已经实现了二叉树的前序遍历，尝试思考一下二叉树的中序遍历如何实现喃？

### 六、leetcode94：二叉树的中序遍历

给定一个二叉树，返回它的 **中序** 遍历。

**示例:**

```ini
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
复制代码
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

欢迎将解答提交到 [JavaScript-Algorithms](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms) ，这里我们提交了前端所用到的算法系列文章以及题目（已解答），欢迎star，如果感觉不错，点个赞支持一下呗😊

### 七、往期精彩

- [前端进阶算法6：队列、双端队列、滑动窗口及配套算法题](https://juejin.cn/post/6844904149541191693)
- [前端进阶算法：常见算法题及完美题解](https://juejin.cn/post/6844904138044604424)
- [视频面试超高频在线编程题，搞懂这些足以应对大部分公司](https://juejin.cn/post/6844904132105469960)
- [10问10答，带你快速入门前端算法](https://juejin.cn/post/6844904122496319495)
- [前端进阶算法5：全方位解读前端用到的栈结构（+leetcode刷题）](https://juejin.cn/post/6844904134341033998)
- [前端进阶算法4：链表原来如此简单（+leetcode刷题）](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F12)
- [前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F9)
- [瓶子君前端进阶算法营首周总结](https://juejin.cn/post/6844904115877707784)
- [前端进阶算法2：从Chrome V8源码看JavaScript数组（附赠腾讯面试题）](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F2)
- [前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F1)

### 八、前端算法集训营第一期免费加入啦

扫码加入前端算法集训营，从0到1构建完整的数据结构与算法体系！

在这里，瓶子君不仅介绍算法，还将算法与前端各个领域进行结合，包括浏览器、HTTP、V8、React、Vue源码等。



作者：前端瓶子君
链接：https://juejin.cn/post/6844904154066845703
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 引言

队列这种数据结构，据瓶子君了解，前端需要了解的队列结构主要有：双端队列、滑动窗口，它们都是算法中是比较常用的数据结构。

因此，本节主要内容为：

- 数据结构：队列（Queue）
- 双端队列（Deque）
- 双端队列的应用：翻转字符串中的单词
- 滑动窗口
- 滑动窗口应用：无重复字符的最长公共子串
- 最后来一道 leetcode 题目：滑动窗口最大值问题

下面进入正文吧👇，如果还可以，点个赞👍支持一下呗😊

### 一、数据结构：队列

队列和栈类似，不同的是队列是先进先出 (FIFO) 原则的有序集合，它的结构类似如下：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/6/171ea4523338fdc3~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



常见队列的操作有： `enqueue(e)` 进队、 `dequeue()` 出队、 `isEmpty()` 是否是空队、 `front()` 获取队头元素、`clear()` 清空队，以及 `size()` 获取队列长度。

**代码实现**

```javascript
function Queue() {
  let items = []
  this.enqueue = function(e) {
    items.push(e)
  }
  this.dequeue = function() {
    return items.shift()
  }
  this.isEmpty = function() {
    return items.length === 0
  }
  this.front = function() {
    return items[0]
  }
  this.clear = function() { 
    items = [] 
  }
  this.size = function() {
    return items.length
  }
}
复制代码
```

**查找：从对头开始查找，从时间复杂度为 O(n)**

**插入或删除：进栈与出栈的时间复杂度为 O(1)**

### 二、双端队列（Deque）

#### 1. 什么是 Deque

Deque 在原有队列的基础上扩充了：队头、队尾都可以进队出队，它的数据结构如下：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/6/171ea4521bdf513f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



**代码实现：**

```javascript
function Deque() {
  let items = []
  this.addFirst = function(e) {
    items.unshift(e)
  }
  this.removeFirst = function() {
    return items.shift()
  }
  this.addLast = function(e) {
    items.push(e)
  }
  this.removeLast = function() {
    return items.pop()
  }
  this.isEmpty = function() {
    return items.length === 0
  }
  this.front = function() {
    return items[0]
  }
  this.clear = function() { 
    items = [] 
  }
  this.size = function() {
    return items.length
  }
}
复制代码
```

下面看一道经典的双端队列问题👇

#### 2. 字节&leetcode151：翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词。

**示例 1：**

```arduino
输入: "the sky is blue"
输出: "blue is sky the"
复制代码
```

**示例 2：**

```makefile
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
复制代码
```

**示例 3：**

```makefile
输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
复制代码
```

**说明：**

- 无空格字符构成一个单词。
- 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
- 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

**解题思路：使用双端队列解题**

- 首先去除字符串左右空格
- 逐个读取字符串中的每个单词，依次放入双端队列的对头
- 再将队列转换成字符串输出（已空格为分隔符）

**画图理解：**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/6/171ea451de96f15a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)





![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/6/171ea45141a14a69~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)





![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/6/171ea4518a5ff1ec~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



**代码实现：**

```sql
var reverseWords = function(s) {
    let left = 0
    let right = s.length - 1
    let queue = []
    let word = ''
    while (s.charAt(left) === ' ') left ++
    while (s.charAt(right) === ' ') right --
    while (left <= right) {
        let char = s.charAt(left)
        if (char === ' ' && word) {
            queue.unshift(word)
            word = ''
        } else if (char !== ' '){
            word += char
        }
        left++
    }
    queue.unshift(word)
    return queue.join(' ')
};
复制代码
```

更多解法详见 [图解字节&leetcode151：翻转字符串里的单词](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F18)

### 三、滑动窗口

#### 1. 什么是滑动窗口

这是队列的另一个重要应用

顾名思义，滑动窗口就是一个运行在一个大数组上的子列表，该数组是一个底层元素集合。

假设有数组 [a b c d e f g h ]，一个大小为 3 的 **滑动窗口**在其上滑动，则有：

```csharp
[a b c]
  [b c d]
    [c d e]
      [d e f]
        [e f g]
          [f g h]
复制代码
```

一般情况下就是使用这个窗口在数组的 **合法区间** 内进行滑动，同时 **动态地** 记录一些有用的数据，很多情况下，能够极大地提高算法地效率。

下面看一道经典的滑动窗口问题👇

#### 2. 字节&Leetcode3：无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```makefile
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
复制代码
```

**示例 2:**

```makefile
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
复制代码
```

**示例 3:**

```makefile
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
复制代码
```

**解题思路：** 使用一个数组来维护滑动窗口

遍历字符串，判断字符是否在滑动窗口数组里

- 不在则 `push` 进数组
- 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 `push` 进数组
- 然后将 `max` 更新为当前最长子串的长度

遍历完，返回 `max` 即可

**画图帮助理解一下：**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/6/171ea451f551d565~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



**代码实现：**

```ini
var lengthOfLongestSubstring = function(s) {
    let arr = [], max = 0
    for(let i = 0; i < s.length; i++) {
        let index = arr.indexOf(s[i])
        if(index !== -1) {
            arr.splice(0, index+1);
        }
        arr.push(s.charAt(i))
        max = Math.max(arr.length, max) 
    }
    return max
};
复制代码
```

**时间复杂度：O(n2)， 其中 `arr.indexOf()` 时间复杂度为 O(n) ，`arr.splice(0, index+1)` 的时间复杂度也为 O(n)**

**空间复杂度：O(n)**

更多解法详见 [字节&Leetcode3：无重复字符的最长子串](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F21)

最后，来尝试一道leetcode题目吧！

### 四、leetcode239：滑动窗口最大值问题

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

**示例:**

```ini
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
复制代码
```

**解释:**

> 滑动窗口的位置                最大值
>
> [1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7

**提示：**

你可以假设 `k` 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。

可以自己尝试解答一下，欢迎将答案提交到 [github.com/sisterAn/Ja…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F33) ，瓶子君将明日解答😊



作者：前端瓶子君
链接：https://juejin.cn/post/6844904149541191693
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#### 2. 解法

##### 解法一：维护数组

**解题思路：** 使用一个数组来维护滑动窗口

遍历字符串，判断字符是否在滑动窗口数组里

- 不在则 `push` 进数组
- 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 `push` 进数组
- 然后将 `max` 更新为当前最长子串的长度

遍历完，返回 `max` 即可

**画图帮助理解一下：**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/25/171af6ebb321bef9~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



**代码实现：**

```ini
var lengthOfLongestSubstring = function(s) {
    let arr = [], max = 0
    for(let i = 0; i < s.length; i++) {
        let index = arr.indexOf(s[i])
        if(index !== -1) {
            arr.splice(0, index+1);
        }
        arr.push(s.charAt(i))
        max = Math.max(arr.length, max) 
    }
    return max
};
复制代码
```

**时间复杂度：O(n2)， 其中 `arr.indexOf()` 时间复杂度为 O(n) ，`arr.splice(0, index+1)` 的时间复杂度也为 O(n)**

**空间复杂度：O(n)**

##### 解法二：维护下标

**解题思路：** 使用下标来维护滑动窗口

**代码实现：**

```ini
var lengthOfLongestSubstring = function(s) {
    let index = 0, max = 0
    for(let i = 0, j = 0; j < s.length; j++) {
        index = s.substring(i, j).indexOf(s[j]) 
        if(index !== -1) { 
            i = i + index + 1 
        } 
        max = Math.max(max, j - i + 1) 
    }
    return max
};
复制代码
```

**时间复杂度：O(n2)**

**空间复杂度：O(n)**

##### 解法三：优化的Map

**解题思路：**

使用 `map` 来存储当前已经遍历过的字符，`key` 为字符，`value` 为下标

使用 `i` 来标记无重复子串开始下标，`j` 为当前遍历字符下标

遍历字符串，判断当前字符是否已经在 `map` 中存在，存在则更新无重复子串开始下标 `i` 为相同字符的下一位置，此时从 `i` 到 `j` 为最新的无重复子串，更新 `max` ，将当前字符与下标放入 `map` 中

最后，返回 `max` 即可

**代码实现：**

```ini
var lengthOfLongestSubstring = function(s) {
    let map = new Map(), max = 0
    for(let i = 0, j = 0; j < s.length; j++) {
        if(map.has(s[j])) {
            i = Math.max(map.get(s[j]) + 1, i)
        }
        max = Math.max(max, j - i + 1)
        map.set(s[j], j)
    }
    return max
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(n)**

#### 3. 更多题解

详见 [字节&Leetcode3：无重复字符的最长子串](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F21)

### 三、文章：全方位解读栈结构

#### 1. 数据结构栈

栈是一种遵从后进先出 (LIFO / Last In First Out) 原则的有序集合，它的结构类似如下：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/25/171af6ebb416840c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



**代码实现**

```javascript
function Stack() {
  let items = []
  this.push = function(e) { 
    items.push(e) 
  }
  this.pop = function() { 
    return items.pop() 
  }
  this.isEmpty = function() { 
    return items.length === 0 
  }
  this.size = function() { 
    return items.length 
  }
  this.clear = function() { 
    items = [] 
  }
}
复制代码
```

**查找：从栈头开始查找，时间复杂度为 O(n)**

**插入或删除：进栈与出栈的时间复杂度为 O(1)**

#### 2. 面试：调用栈

> 调用栈是 JavaScript 用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行。 如果我们执行一个函数，就会为函数创建执行上下文并放入栈顶。 如果我们从函数返回，就将它的执行上下文从栈顶弹出。 也可以说调用栈是用来管理这种执行上下文的栈，或称执行上下文栈（执行栈）。

#### 3. 面试：栈空间与堆空间

JavaScript 中的内存空间主要分为三种类型：

- 代码空间：主要用来存放可执行代码
- 栈空间：调用栈的存储空间就是栈空间。
- 堆空间

代码空间主要用来存放可执行代码的。栈空间及堆空间主要用来存放数据的。接下来我们主要介绍栈空间及堆空间。

当调用栈中执行完成一个执行上下文时，需要进行垃圾回收该上下文以及相关数据空间，存放在栈空间上的数据通过 ESP 指针来回收，存放在堆空间的数据通过副垃圾回收器（新生代）与主垃圾回收器（老生代）来回收。

#### 4. 详情

详细请看 [前端进阶算法5：全方位解读前端用到的栈结构（+leetcode刷题）](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F24)

### 四、字节&leetcode155：最小栈（包含getMin函数的栈）

#### 1. 题目

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` —— 将元素 x 推入栈中。
- `pop()` —— 删除栈顶的元素。
- `top()` —— 获取栈顶元素。
- `getMin()` —— 检索栈中的最小元素。

**示例:**

```ini
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
复制代码
```

#### 2. 解法

在常数时间内检索到最小元素的栈，即仅需保证 `getMin` 的时间复杂度为 O(1) 即可

```kotlin
var MinStack = function() {
    this.items = []
    this.min = null
};

// 进栈
MinStack.prototype.push = function(x) {
    if(!this.items.length) this.min = x 
    this.min = Math.min(x, this.min)
    this.items.push(x) 
};

// 出栈
MinStack.prototype.pop = function() {
    let num = this.items.pop() 
    this.min = Math.min(...this.items)
    return num
};

// 获取栈顶元素
MinStack.prototype.top = function() {
    if(!this.items.length) return null
    return this.items[this.items.length -1] 
};

// 检索栈中的最小元素
MinStack.prototype.getMin = function() {
    return this.min
};
复制代码
```

**时间复杂度：进栈O(1)，出栈O(n)，获取栈顶元素O(1)，获取最小元素O(1)**

**空间复杂度：O(n)**

#### 3. 更多题解

详见 [字节&leetcode155：最小栈（包含getMin函数的栈）](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F23)

### 五、图解腾讯&leetcode20：有效的括号

#### 1. 题目

给定一个只包括 `'('` ，`')'` ，`'{'` ，`'}'` ，`'['` ，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

```arduino
输入: "()"
输出: true
复制代码
```

**示例 2:**

```arduino
输入: "()[]{}"
输出: true
复制代码
```

**示例 3:**

```arduino
输入: "(]"
输出: false
复制代码
```

**示例 4:**

```arduino
输入: "([)]"
输出: false
复制代码
```

**示例 5:**

```arduino
输入: "{[]}"
输出: true
复制代码
```

#### 2. 解法：利用栈结构

**解题思路：** 将字符串中的字符依次入栈，遍历字符依次判断：

- 首先判断该元素是否是 `{` 、 `(` 、 `[` ，直接入栈
- 否则该字符为 `}` 、 `)` 、 `]` 中的一种，如果该字符串有效，则该元素应该与栈顶匹配，例如栈中元素有 `({`， 如果继续遍历到的元素为 `)`, 那么当前元素序列为 `({)` 是不可能有效的，所以此时与栈顶元素匹配失败，则直接返回 `false` ，字符串无效

当遍历完成时，所有已匹配的字符都已匹配出栈，如果此时栈为空，则字符串有效，如果栈不为空，说明字符串中还有未匹配的字符，字符串无效

**画图帮助理解一下：**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/25/171af6ebb637241d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



**代码实现：**

```arduino
var isValid = function(s) {
    let map = {
        '{': '}',
        '(': ')',
        '[': ']'
    }
    let stack = []
    for(let i = 0; i < s.length ; i++) {
        if(map[s[i]]) {
            stack.push(s[i])
        } else if(s[i] !== map[stack.pop()]){
            return false
        }
    }
    return stack.length === 0
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(n)**

#### 3. 更多题解

详见 [图解腾讯&leetcode20：有效的括号](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F25)

### 六、leetcode1047：删除字符串中的所有相邻重复项

#### 1. 题目

给出由小写字母组成的字符串 `S` ，**重复项删除操作** 会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

```arduino
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
复制代码
```

**提示：**

1. `<= S.length <= 20000`
2. `S` 仅由小写英文字母组成。

#### 2. 解法：利用栈

**解题思路：** 遍历字符串，依次入栈，入栈时判断与栈头元素是否一致，如果一致，即这两个元素相同相邻，则需要将栈头元素出栈，并且当前元素也无需入栈

**解题步骤：** 遍历字符串，取出栈头字符，判断当前字符与栈头字符是否一致

- 不一致，栈头字符进栈，当前字符进栈
- 一致，即栈头字符与当前字符相同相邻，都不需要进栈，直接进入下次遍历即可

遍历完成后，返回栈中字符串

**代码实现：**

```scss
var removeDuplicates = function(S) {
    let stack = []
    for(c of S) {
        let prev = stack.pop()
        if(prev !== c) {
            stack.push(prev)
            stack.push(c)
        }
    }
    return stack.join('')
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(n)**



作者：前端瓶子君
链接：https://juejin.cn/post/6844904138044604424
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 三、前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法

#### 1. 浏览器缓存淘汰策略

当我们打开一个网页时，例如 `https://github.com/sisterAn/JavaScript-Algorithms` ，它会在发起真正的网络请求前，查询浏览器缓存，看是否有要请求的文件，如果有，浏览器将会拦截请求，返回缓存文件，并直接结束请求，不会再去服务器上下载。如果不存在，才会去服务器请求。

其实，浏览器中的缓存是一种在本地保存资源副本，它的大小是有限的，当我们请求数过多时，缓存空间会被用满，此时，继续进行网络请求就需要确定缓存中哪些数据被保留，哪些数据被移除，这就是**浏览器缓存淘汰策略**，最常见的淘汰策略有 FIFO（先进先出）、LFU（最少使用）、LRU（最近最少使用）。

LRU （ `Least Recently Used` ：最近最少使用 ）缓存淘汰策略，故名思义，就是根据数据的历史访问记录来进行淘汰数据，其核心思想是 **如果数据最近被访问过，那么将来被访问的几率也更高** ，优先淘汰最近没有被访问到的数据。

画个图帮助我们理解 LRU：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714fb580920fc36~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



#### 2. Vue 的 keep-alive 源码解读

在 `keep-alive` 缓存超过 `max` 时，使用的缓存淘汰算法就是 LRU 算法，它在实现的过程中用到了 `cache` 对象用于保存缓存的组件实例及 `key` 值，`keys` 数组用于保存缓存组件的 `key` ，当 `keep-alive` 中渲染一个需要缓存的实例时：

- 判断缓存中是否已缓存了该实例，缓存了则直接获取，并调整 `key` 在 `keys` 中的位置（移除 `keys` 中 `key` ，并放入 `keys` 数组的最后一位）
- 如果没有缓存，则缓存该实例，若 `keys` 的长度大于 `max` （缓存长度超过上限），则移除 `keys[0]` 缓存

主要实现LRU代码：

```scss
// --------------------------------------------------
// 下面就是 LRU 算法了，
// 如果在缓存里有则调整，
// 没有则放入（长度超过 max，则淘汰最近没有访问的）
// --------------------------------------------------
// 如果命中缓存，则从缓存中获取 vnode 的组件实例，
// 并且调整 key 的顺序放入 keys 数组的末尾
if (cache[key]) {
  vnode.componentInstance = cache[key].componentInstance;
  // make current key freshest
  remove(keys, key);
  keys.push(key);
}
// 如果没有命中缓存,就把 vnode 放进缓存
else {
  cache[key] = vnode;
  keys.push(key);
  // prune oldest entry
  // 如果配置了 max 并且缓存的长度超过了 this.max，还要从缓存中删除第一个
  if (this.max && keys.length > parseInt(this.max)) {
    pruneCacheEntry(cache, keys[0], keys, this._vnode);
  }
}
复制代码
```

源码详情：[前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F9)

### 四、前端进阶算法4：链表原来如此简单（+leetcode刷题）

#### 1. 图解链表

常用的链表类型有单链表、双链表以及循环链表，其中 `next` 为后继指针，指向它的后继节点，`prev` 为前驱指针，指向它的前驱节点。

**单链表**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/8/1715a7158c2aa9ce~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



**双链表**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/8/1715a7159cfc7be0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



**循环链表**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/8/1715a715bdf7f73c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



#### 2. 链表复杂度一览表

**单链表**

| 操作方法   | 时间复杂度 | 说明                                 |
| ---------- | ---------- | ------------------------------------ |
| append     | O(n)       | 在链表尾部追加节点                   |
| search     | O(n)       | 在链表中查找任意元素                 |
| insert     | O(n)       | 在链表中任意位置插入一个节点         |
| remove     | O(n)       | 删除链表中任意位置的一个节点         |
| searchNext | O(1)       | 查找某节点的后继节点                 |
| insertNext | O(1)       | 在某一节点后插入一个节点（后继节点） |
| removeNext | O(1)       | 在某一节点后删除一个节点（后继节点） |

**双链表**

| 操作方法                | 时间复杂度 | 说明                           |
| ----------------------- | ---------- | ------------------------------ |
| search                  | O(n)       | 在链表中查找任意元素           |
| insert                  | O(n)       | 在链表中任意位置插入一个节点   |
| remove                  | O(n)       | 删除链表中任意位置的一个节点   |
| searchNext 或 searchPre | O(1)       | 查找某节点的后继节点或前驱节点 |
| insertNext 或 insertPre | O(1)       | 插入某节点的后继节点或前驱节点 |
| removeNext 或 removePre | O(1)       | 删除某节点的前驱节点或后继节点 |

**循环链表**

| 操作方法   | 时间复杂度 | 说明                                 |
| ---------- | ---------- | ------------------------------------ |
| search     | O(n)       | 在链表中查找任意元素                 |
| insert     | O(n)       | 在链表中任意位置插入一个节点         |
| remove     | O(n)       | 删除链表中任意位置的一个节点         |
| searchNext | O(1)       | 查找某节点的后继节点                 |
| insertNext | O(1)       | 在某一节点后插入一个节点（后继节点） |
| removeNext | O(1)       | 在某一节点后删除一个节点（后继节点） |

详情：[前端进阶算法4：链表原来如此简单（+leetcode刷题）](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F12)

### 五、图解leetcode88：合并两个有序数组

#### 1. 题目

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中，使 `num1` 成为一个有序数组。

说明:

初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n` 。 你可以假设 `nums1` 有足够的空间（空间大小大于或等于 `m + n` ）来保存 `nums2` 中的元素。

**示例:**

```ini
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
复制代码
```

#### 2. 解答

**解题思路：**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/12/1716e1b870d9c299~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



- `nums1` 、 `nums2` 有序，若把 `nums2` 全部合并到 `nums1` ，则合并后的 `nums1` 长度为 `m+n`

- 我们可以从下标 

  ```
  m+n-1
  ```

   的位置填充 

  ```
  nums1
  ```

   ，比较 

  ```
  nums1[len1]
  ```

   与 

  ```
  nums2[len2]
  ```

   的大小，将最大值写入 

  ```
  nums1[len]
  ```

  ，即 

  - `nums1[len1]>=nums2[len2]` ，`nums1[len--] = nums1[len1--]` ,这里 `--` 是因为写入成功后，下标自动建议，继续往前比较
  - 否则 `nums1[len--] = nums2[len2--]`

- 边界条件： 

  - 若 `len1 < 0`，即 `len2 >= 0` ，此时 `nums1` 已重写入， `nums2` 还未合并完，仅仅需要将 `nums2` 的剩余元素（0…len）写入 `nums2` 即可，写入后，合并完成
  - 若 `len2 < 0`，此时 `nums2` 已全部合并到 `nums1` ，合并完成

**时间复杂度为 O(m+n)**

**代码实现：**

```ini
var merge = function(nums1, m, nums2, n) {
    let len1 = m - 1,
        len2 = n - 1,
        len = m + n - 1
    while(len2 >= 0) {
        if(len1 < 0) {
            nums1[len--] = nums2[len2--]
            continue
        }
        nums1[len--] = nums1[len1] >= nums2[len2] ? nums1[len1--]: nums2[len2--]
    }
};
复制代码
```

#### 3. 更多解答请看：[图解leetcode88：合并两个有序数组](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F3)

### 六、字节&leetcode1：两数之和

#### 1. 题目

给定一个整数数组 `nums` 和一个目标值 `target` ，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

**示例:**

```ini
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
复制代码
```

#### 2. 解答

**解题思路：**

- 初始化一个 `map = new Map()`

- 从第一个元素开始遍历 `nums`

- 获取目标值与 

  ```
  nums[i]
  ```

   的差值，即 

  ```
  k = target - nums[i]
  ```

   ，判断差值在 

  ```
  map
  ```

   中是否存在 

  - 不存在（ `map.has(k)` 为 `false` ） ，则将 `nums[i]` 加入到 `map` 中（key为`nums[i]`, value为 `i` ，方便查找map中是否存在某值，并可以通过 `get` 方法直接拿到下标）
  - 存在（ `map.has(k)` ），返回 `[map.get(k), i]` ，求解结束

- 遍历结束，则 `nums` 中没有符合条件的两个数，返回 `[]`

**时间复杂度：O(n)**

**代码实现：**

```ini
var twoSum = function(nums, target) {
    let map = new Map()
    for(let i = 0; i< nums.length; i++) {
        let k = target-nums[i]
        if(map.has(k)) {
            return [map.get(k), i]
        }
        map.set(nums[i], i)
    }
    return [];
};
复制代码
```

#### 3. 更多解答请看：[字节&leetcode1：两数之和](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F4)

### 七、腾讯：数组扁平化、去重、排序

#### 1. 题目

> 已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
>
> 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

#### 2. 答案：

```javascript
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]
// 扁平化
let flatArr = arr.flat(4)
// 去重
let disArr = Array.from(new Set(flatArr))
// 排序
let result = disArr.sort(function(a, b) {
    return a-b
})
console.log(result)
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
复制代码
```

感谢 **352800205** 的补充：`flat()` 方法对node版本有要求，至少需要12.0以上

#### 3. 更多解答请看：[腾讯：数组扁平化、去重、排序](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F5)

### 八、leetcode349：给定两个数组，编写一个函数来计算它们的交集

#### 1. 题目

给定两个数组，编写一个函数来计算它们的交集。

**示例 1:**

```ini
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
复制代码
```

**示例 2:**

```ini
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]
复制代码
```

**说明:**

输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。

#### 2. 答案

**解题思路：**

- `filter` 过滤
- `Set` 去重

**代码实现：**

```javascript
var intersection = function(nums1, nums2) {
    return [...new Set(nums1.filter((item)=>nums2.includes(item)))]
};
复制代码
```

#### 3. 更多解答请看：[leetcode349：给定两个数组，编写一个函数来计算它们的交集](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F6)

### 九、leetcode146：设计和实现一个LRU（最近最少使用）缓存机制

#### 1. 题目

运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 `get` 和写入数据 `put` 。

获取数据 `get(key)` - 如果密钥 ( `key` ) 存在于缓存中，则获取密钥的值（总是正数），否则返回 `-1` 。 写入数据 `put(key, value)` - 如果密钥不存在，则写入数据。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据，从而为新数据留出空间。

**进阶:**

你是否可以在 **O(1)** 时间复杂度内完成这两种操作？

**示例:**

```scss
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
复制代码
```

#### 2. 答案

**基础解法：数组+对象实现**

类 vue keep-alive 实现

```kotlin
var LRUCache = function(capacity) {
    this.keys = []
    this.cache = Object.create(null)
    this.capacity = capacity
};

LRUCache.prototype.get = function(key) {
    if(this.cache[key]) {
        // 调整位置
        remove(this.keys, key)
        this.keys.push(key)
        return this.cache[key]
    }
    return -1
};

LRUCache.prototype.put = function(key, value) {
    if(this.cache[key]) {
        // 存在即更新
        this.cache[key] = value
        remove(this.keys, key)
        this.keys.push(key)
    } else {
        // 不存在即加入
        this.keys.push(key)
        this.cache[key] = value
        // 判断缓存是否已超过最大值
        if(this.keys.length > this.capacity) {
            removeCache(this.cache, this.keys, this.keys[0])
        }
    }
};

// 移除 key
function remove(arr, key) {
    if (arr.length) {
        const index = arr.indexOf(key)
        if (index > -1) {
            return arr.splice(index, 1)
        }
    }
}

// 移除缓存中 key
function removeCache(cache, keys, key) {
    cache[key] = null
    remove(keys, key)
}
复制代码
```

**进阶：Map**

利用 Map 既能保存键值对，并且能够记住键的原始插入顺序

```kotlin
var LRUCache = function(capacity) {
    this.cache = new Map()
    this.capacity = capacity
}

LRUCache.prototype.get = function(key) {
    if (this.cache.has(key)) {
        // 存在即更新
        let temp = this.cache.get(key)
        this.cache.delete(key)
        this.cache.set(key, temp)
        return temp
    }
    return -1
}

LRUCache.prototype.put = function(key, value) {
    if (this.cache.has(key)) {
        // 存在即更新（删除后加入）
        this.cache.delete(key)
    } else if (this.cache.size >= this.capacity) {
        // 不存在即加入
        // 缓存超过最大值，则移除最近没有使用的
        this.cache.delete(this.cache.keys().next().value)
    }
    this.cache.set(key, value)
}
复制代码
```

#### 3. 更多解答请看：[leetcode146：设计和实现一个LRU（最近最少使用）缓存机制](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F7)

### 十、阿里算法题：编写一个函数计算多个数组的交集

#### 1. 题目

**要求：** 输出结果中的每个元素一定是唯一的

#### 2. 答案

使用 reducer 函数

```javascript
var intersection = function(...args) {
    if (args.length === 0) {
    return []
  }
  if (args.length === 1) {
    return args[0]
  }
  return [...new Set(args.reduce((result, arg) => {
    return result.filter(item => arg.includes(item))
  }))]
};
复制代码
```

#### 3. 更多解答请看：[阿里算法题：编写一个函数计算多个数组的交集](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F10)

### 十一、leetcode21：合并两个有序链表

#### 1. 题目

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```rust
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
复制代码
```

#### 2. 答案

**解答：**

**确定解题的数据结构：** 单链表

**确定解题思路：** 从链表头开始比较，`l1` 与 `l2` 是有序递增的，所以比较 `l1.val` 与 `l2.val` 的较小值就是合并后链表的最小值，次小值就是小节点的 `next.val` 与大节点的 `val` 比较的较小值，依次递归，直到递归到 `l1` `l2` 均为 `null`

**画图实现：** 画图帮助理解一下



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/8/1715a715e8758073~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



**确定边界条件：** 当递归到任意链表为 `null` ，直接将 `next` 指向另外的链表即可，不需要继续递归了

**代码实现：**

```kotlin
function mergeTwoLists(l1, l2) {
    if(l1 === null) {
        return l2
    }
    if(l2 === null) {
        return l1
    }
    if(l1.val <= l2.val) {
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    } else {
        l2.next = mergeTwoLists(l2.next, l1)
        return l2
    }
}
复制代码
```

#### 3. 更多解答请看：[leetcode21：合并两个有序链表](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F11)

### 十二、有赞&leetcode141：判断一个单链表是否有环

#### 1. 题目

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 `0` 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

**示例 1：**

```bash
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
复制代码
```



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/12/1716e1b86bbc654a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



**示例 2：**

```bash
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
复制代码
```



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/12/1716e1b87efb996a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



**示例 3：**

```bash
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
复制代码
```



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/12/1716e1b96ab686f6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



**进阶：**

你能用 O(1)（即，常量）内存解决此问题吗？

#### 2. 答案

##### 解法一：标志法

给每个已遍历过的节点加标志位，遍历链表，当出现下一个节点已被标志时，则证明单链表有环

```bash
var hasCycle = function(head) {
    while(head) {
        if(head.flag) return true
        head.flag = true
        head = head.next
    }
    return false
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(n)**

##### 解法二：利用 `JSON.stringify()` 不能序列化含有循环引用的结构

```javascript
var hasCycle = function(head) {
    try{
        JSON.stringify(head);
        return false;
    }
    catch(err){
        return true;
    }
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(n)**

##### 解法三：快慢指针（双指针法）

设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 `null` 时，快慢指针都不可能相遇

```lua
var hasCycle = function(head) {
    if(!head || !head.next) {
        return false
    }
    let fast = head.next.next, slow = head.next
    while(fast !== slow) {
        if(!fast || !fast.next) return false
        fast = fast.next.next
        slow = slow.next
    }
    return true
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(1)**

#### 3. 更多解答请看：[有赞&leetcode141：判断一个单链表是否有环](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F13)

### 十三、图解leetcode206：反转链表

#### 1. 题目

**示例:**

```rust
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
复制代码
```

**进阶:** 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

#### 2. 解答

##### 解法一：迭代法

**解题思路：** 将单链表中的每个节点的后继指针指向它的前驱节点即可

**画图实现：** 画图帮助理解一下



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/12/1716e1b87098dc10~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



**确定边界条件：** 当链表为 `null` 或链表中仅有一个节点时，不需要反转

**代码实现：**

```ini
var reverseList = function(head) {
    if(!head || !head.next) return head
    var prev = null, curr = head
    while(curr) {
        // 用于临时存储 curr 后继节点
        var next = curr.next
        // 反转 curr 的后继指针
        curr.next = prev
        // 变更prev、curr 
        // 待反转节点指向下一个节点 
        prev = curr
        curr = next
    }
    head = prev
    return head
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(1)**

##### 解法二：尾递归法

**解题思路：** 从头节点开始，递归反转它的每一个节点，直到 `null` ，思路和解法一类似

**代码实现：**

```lua
var reverseList = function(head) {
    if(!head || !head.next) return head
    head = reverse(null, head)
    return head
};

var reverse = function(prev, curr) {
    if(!curr) return prev
    var next = curr.next
    curr.next = prev
    return reverse(curr, next)
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(n)**

##### 解法三：递归法

**解题思路：** 不断递归反转当前节点 `head` 的后继节点 `next`

**画图实现：** 画图帮助理解一下



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/12/1716e1b87885d7dc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



**代码实现：**

```ini
var reverseList = function(head) {
    if(!head || !head.next) return head
    var next = head.next
    // 递归反转
    var reverseHead = reverseList(next)
    // 变更指针
    next.next = head
    head.next = null
    return reverseHead
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(n)**

#### 3. 更多解答请看：[图解 leetcode206：反转链表](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F14)

### 十四、leetcode876：求链表的中间结点

#### 1. 题目

给定一个带有头结点 `head` 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

**示例 1：**

```vbscript
输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。

注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
复制代码
```

**示例 2：**

```css
输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])

由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
复制代码
```

**提示：**

给定链表的结点数介于 1 和 100 之间。

#### 2. 解法：快慢指针

**解题思路：** 快指针一次走两步，慢指针一次走一步，当快指针走到终点时，慢指针刚好走到中间

```ini
var middleNode = function(head) {
    let fast = head, slow = head
    while(fast && fast.next) {
        slow = slow.next
        fast = fast.next.next
    }
    return slow
};
复制代码
```

**时间复杂度：O(n)**

**空间复杂度：O(1)**



作者：前端瓶子君
链接：https://juejin.cn/post/6844904122496319495
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 一、栈

## 简介

> 栈是一种**后进先出**（即LIFO:Last in, First out）的数据结构，在`JavaScript`中没有栈的结构，但是可以用数组来实现栈的所有功能: `push(入栈)`和`pop（出栈）`

## 代码实现

```js
function Stack() {
    this.stack = []
    this.push = function(item) {
        this.stack.push(item)
    }
    this.pop = function() {
        this.stack.pop()
    }
}
复制代码
```

## 应用场景

### 函数调用堆栈

为了便于理解这个场景，先来看一段代码：

```js
function first() {
  console.log('first start')
  second()
  console.log('first end')
}

function second() {
  console.log('second start')
}

console.log('start')
first()
console.log('end')

// start
// first start
// second start
// first end
// end
复制代码
```

> 这段代码执行的结果说明：函数在执行过程中，最先执行的函数会在最后执行完成，遇到`first`函数时，则进入函数执行，当遇到`second`函数时，则执行second，在`second`函数执行完成后继续执行`first`，最后执行`end`结束。
>  这样就很容易的理解为什么说函数调用的逻辑实际就是利用了这种栈的数据结构实现的。

# 二、队列

## 简介

> 队列是一种**先进先出**（即FIFO:First in, First out）的数据结构，在`JavaScript`中没有队列的数据结构，不过我们依旧可以使用数组来实现队列的功能：`enqueue（入队）`和`dequeue（出队）`

## 代码实现

```js
function Queue() {
  this.queue = []
  this.enqueue = function(item) {
    this.queue.push(item)
  }
  this.dequeue = function() {
    return this.queue.shift()
  }
}
复制代码
```

## 应用场景

### JS任务队列

由于js是单线程的，所以在处理多个异步函数同时执行的情况下，当异步任务有了结果时，会先进入一个任务队列，在js主线程的同步任务执行完成后，才会读取任务队列，按照异步函数进入任务队列的顺序开始一次支持异步函数的回调函数，即先进入任务队列中的函数会先执行

# 三、链表

## 简介

> 链接也是由多个元素组成的列表，但是与队列和栈不同的是，链表的存储是不连续的，而是使用next指向下一个元素。在链表中，我们需要添加删除元素，只需要修改next指针即可。在`js`中我们可以用`object`来模拟链表。

## 代码实现

```js
/**
 * 链表
 * @param {*} val
 */
function LinkList(val) {
  /**
   * 创建一个node结点
   * @param {*} val
   * @param node
   */
  function _creatNode(val) {
    return {
      val: val,
      next: null,
    }
  }

  this.head = _creatNode(val)
  this.tail = this.head

  /**
   * 查找
   * @param {*} val 查找val
   * @returns node
   */
  this.find = function (val) {
    let node = this.head
    while (node) {
      if (val === node.val) {
        return node
      }
      node = node.next
    }
    return null
  }

  /**
   * 在node结点后插入结点
   */
  this.insert = function (insertVal, val) {
    const insertNode = _creatNode(insertVal)
    if (val) {
      const node = this.find(val)
      insertNode.next = node.next
      node.next = insertNode
    } else {
      this.tail.next = insertNode
      this.tail = insertNode
    }
  }

  /**
   * 遍历
   * @param {Function} fn 回调函数
   */
  this.map = function (fn) {
    let p = this.head
    while (p) {
      fn(p)
      p = p.next
    }
  }
}
复制代码
```

## 应用场景

### 1. 原型链

在js中原型链的结构与链表结构非常类似。链表中我们使用next属性来链接下一个元素，而原型链则使用`__proto__`属性来链接原型对象

# 四、集合

## 简介

> 集合是一种**无序且唯一**的数据结构，在`JavaScript`中，我们可以用es6的[Set](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSet)方法直接创建一个集合

## 代码实现

```js
// 由于es6中有专门的数据结构，可以直接创建一个集合
const set = new Set()

set.add(1)
set.add(2)
...
复制代码
```

## 应用场景

### 1.数组去重

通常我们在实际开发中使用`Set`这种数据结构最多的就是用来去重了，不过在数组去重时，要注意对于引用类型的数据，如果引用不同那么会按不同的值存在集合中，同时`Set`也可以存储`NaN undefined`这类的特殊数据

### 2.数组判断、删除等操作

比如在判断数组中是否存在某一个值，或者删除数组中某一个值时，也可以使用`Set.prototype.has`和`Set.prototype.delete`等方法方便的对数组进行操作

# 五、字典

## 简介

> 字典也是一种存储唯一值的数据结构，但是以**键值对**的方式进行存储。在`JavaScript`中，我们可以用es6的[Map](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FMap)方法直接创建一个字典

## 代码实现

```js
const map = new Map()

复制代码
```

## 应用场景

### 用来存储数据

`Map`通常可以用来存储一些具有映射关系的数据，类似一个id对应一个内容，这种实现与js中普通对象的功能类似，但是`Map`的功能更加强大，`Objet`只能使用字符串、数字等简单类型当作键值，但是`Map`可以使用任意类型作为键，同时`Map`也可以直接获取长度；而且就是同样取值的操作，`Map`执行会比`Object[key]`这种方式更快。

## 与其他类似数据结构区别

> `Map`和普通`Object`或`Set`，都有一些相似或不同的地方，这里也统一总结起来，在之后使用中也更好的根据需求和场景选择合适的数据结构

### 与普通对象`Object`的区别

1. 有序性：`Map`会按照原有的添加顺序存储，`Object`会根据`key`自动排序
2. 可迭代：`Map`实现了迭代器，可以使用`for...of`方式进行遍历
3. Map可直接获取长度
4. Map的key可以是任何基本类型，`Object`只可以是字符串、数字、Symbol

### 与集合`Set`的区别

1. 存储：`Set`只能存储`key`不能存`value`，由于`key`不能重复，所以`Set`没有重复的`key`
2. 展开：`Map`展开后每项格式为`[key, value]`

# 六、树

## 简介

> 树是一种**分层**数据的抽象模型，在`JavaScript`中没有树这个数据结构，所以通常我们使用`Object`来模拟一个树的结构

## 代码实现

为了后面方便测试树的相关操作，我们先模拟一个树的数据结构：

```js
const treeData = {
  value: '1',
  children: [
    {
      value: '1-1',
      children: [
        {
          value: '1-1-1',
          children: []
        },
        {
          value: '1-1-2',
          children: [
            {
              value: '1-1-2-1',
              children: []
            }
          ]
        },
      ],
    },
    {
      value: '1-2',
      children: [
        {
          value: '1-2-1',
          children: [],
        },
      ],
    },
  ],
}
复制代码
```

### 深度优先遍历

树的深度优先遍历即有children就继续遍历children，直到没有children后再遍历下一个结点: 深度优先遍历流程：

1. 访问根结点
2. 对根结点的children继续深度优先遍历

```js
function des(root) {
  console.log('value', root.value)
  root.children.forEach(item => {
    des(item)
  })
}

des(treeData)
// value 1
// value 1-1
// value 1-1-1
// value 1-1-2
// value 1-1-2-1
// value 1-2
// value 1-2-1
复制代码
```

可以看出其顺序为优先遍历children，知道children遍历结束开始下一个结点的深度遍历

### 广度优先遍历

广度优先遍历即优先遍历子结点，如果子结点遍历完成，则遍历各子结点的children： 广度优先遍历流程：

1. 创建一个数组，将根结点作为第一项
2. 将数组中第一项弹出并访问
3. 将弹出项中的children遍历并依次添加至数组中
4. 重复2、3步骤直到队列为空

```js
function bfs(root) {
  let arr = [root]

  while(tree = arr.shift()) {
    console.log('value', tree.value)
    tree.children.forEach(item => {
      arr.push(item)
    })
  }
}

bfs(treeData)
// value 1
// value 1-1
// value 1-2
// value 1-1-1
// value 1-1-2
// value 1-2-1
// value 1-1-2-1
复制代码
```

从输出结果可以看到树的遍历是按照优先遍历子结点，待子结点遍历后继续遍历子结点的子结点...直到arr数组为空表示遍历完成

### 二叉树

> **二叉树**: 树中的每个结点最多只能有两个结点，通常我们使用`Object`来模拟一个二叉树,二叉树的遍历有先、中、后序遍历三种
>  **满二叉树**：除最后一层无任何子结点外，每一层所有的节点都有两个子节点的二叉树，如果一个二叉树层数为`n`,那么满二叉树的结点总数为`2^k - 1`个
>  **完全二叉树**：二叉树（除最后一层）的每一个结点必须全部填满，在最后一层所有结点连续集中在最左边

先模拟一个二叉树的数据结构:

```js
const binaryTreeData = {
  value: 'root',
  left: {
    value: 'left',
    left: {
      value: 'left-left',
      left: null,
      right: null,
    },
    right: {
      value: 'left-right',
      left: {
        value: 'left-right-left',
        left: null,
        right: null,
      },
      right: null,
    },
  },
  right: {
    value: 'right',
    left: {
      value: 'right-left',
      left: null,
      right: null,
    },
    right: {
      value: 'right-right',
      left: null,
      right: null,
    },
  },
}
复制代码
```

**二叉树关系图：**

rootleftrightleft-leftleft-rightleft-right-leftnullright-leftright-right

#### 先序遍历

**根**结点 -> **左**子树先序遍历 -> **右**子树先序遍历, 即：

```js
function preOrder(binaryTree) {
  if (!binaryTree) return
  console.log(binaryTree.value)
  preOrder(binaryTree.left)
  preOrder(binaryTree.right)
}

preOrder(binaryTreeData)
// root
// left
// left-left
// left-right
// left-right-left
// right
// right-left
// right-right
复制代码
```

#### 中序遍历

**左**子树中序遍历 -> **根**结点 -> **右**子树中序遍历，即：

```js
function inOrder(binaryTree) {
  if (!binaryTree) return
  inOrder(binaryTree.left)
  console.log(binaryTree.value)
  inOrder(binaryTree.right)
}

inOrder(binaryTreeData)
// left-left
// left
// left-right-left
// left-right
// root
// right-left
// right
// right-right
复制代码
```

#### 后序遍历

**左**子树后序遍历 -> **右**子树后序遍历 -> **根**结点，即：

```js
function postOrder(binaryTree) {
  if (!binaryTree) return
  postOrder(binaryTree.left)
  postOrder(binaryTree.right)
  console.log(binaryTree.value)
}

postOrder(binaryTreeData)
// left-left
// left-right-left
// left-right
// left
// right-left
// right-right
// right
// root
复制代码
```

## 应用场景

### domTree、vDom

在浏览器中的dom结构和react、vue这类框架中的虚拟dom都应用到了树这个数据结构来表示页面元素之间的关系

# 七、图

## 简介

> 图是**网络结构**的抽象模型，是一组由**边**链接的结点。图可以表示任何二元关系（如：道路等），在`javaScript`中可以使用`Object`来模拟一个图的数据结构

## 图的表示法

为了更直观的理解`图`的数据结构及其表示，我们先举一个例子，后面对图的其他操作都基于这个例子来测试：

ABDCE

在这个图中我们可以很清晰的看出`A、B、C、D、E`这几个结点的相互关系，那么在`javaScript`中我们要如何表示这种关系：

### 邻接矩阵

|      | A    | B    | C    | D    | E    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| A    | 0    | 1    | 0    | 0    | 0    |
| B    | 0    | 0    | 1    | 1    | 0    |
| C    | 0    | 0    | 0    | 0    | 1    |
| D    | 0    | 1    | 0    | 0    | 0    |
| E    | 1    | 0    | 0    | 0    | 0    |

> ```
> 邻接矩阵`是用一个二维数组来表各顶点之间的关系, 例如`A --> B`,那么这个二维数组中的`arr[0][1]`为1，若不能链接，则为0，这种二维数组表示图内每个顶点之间关系的方法就是`邻接矩阵
> ```

### 邻街表

```js
{
    A: [B],
    B: [C, D],
    C: [E],
    D: [B],
    E: [A]
}
复制代码
```

> ```
> 邻街表`使用一个对象来表示图中的关系，`key`为各顶点，`value`是一个数组，表示该顶点可链接的顶点，使用这种方式表示图中各顶点的方式就叫做`邻街表
> ```

## 图的遍历

### 深度优先遍历

深度优先遍历是从某一个顶点开始，对该顶点的`未遍历`相邻顶点依次进行`深度优先遍历`,即：

```js
// 记录遍历过的顶点
const visited = new Set()
function dfs(node) {
  console.log(node)
  visited.add(node)
  graph[node].forEach(childNode => {
    if (!visited.has(childNode)) {
      dfs(childNode)
    }
  })
}

dfs('A')
// A B C E D
复制代码
```

我们假设从`A`顶点开始进行`深度优先遍历`,那么输入结果为`A B C E D`,对比前面那张关系图可以看出深度优先遍历的顺序当遍历到`C`时，会继续遍历`E`之后才遍历到了`D`,符合深度优先遍历的规则。

### 广度优先遍历

图的广度优先遍历和`树`的广度优先遍历类似：

1. 需要将`根`元素入队
2. 再出队并访问
3. 将`未遍历`的相邻结点依次入队
4. 重复2、3步，直到队列为空, 即：

```js
const visited = new Set()
function bfs(node) {
  const queue = [node]
  // 根元素在遍历时要手动添加至已访问队列，后面只是添加了根元素的相邻结点
  visited.add(node)
  while(visitNode = queue.shift()) {
    console.log(visitNode)
    graph[visitNode].forEach(childNode => {
      if (!visited.has(childNode)) {
        visited.add(childNode)
        queue.push(childNode)
      }
    })
  }
}

bfs('A')
// A B C D E
复制代码
```

我们从`A`顶点进行`广度优先遍历`，当遍历到`C`结点时，没有继续遍历`C`下的相邻结点，而是遍历了`D`,符合广度优先遍历的规则。

# 八、堆

## 简介

> 堆是一种**特殊的完全二叉树**，堆中的所有所有结点都**大于等于或小于等于**他的子结点，若**大于等于子结点**则为`最大堆`，否则为`最小堆`。在`javaScript`中通常使用数组来表示堆
>  对于第`i`个结点:
>  其父结点的索引为：`Math.floor((i - 1) / 2)`
>  其左子结点的索引为：`(2 * i) + 1`
>  其右子结点的索引为：`(2 * i) + 2`

## 代码实现

### 实现最小堆

```js
function MinHeap() {
  this.heap = []

  this.getParentIndex = function (childIndex) {
    return Math.floor((childIndex - 1) / 2)
  }
  /**
   * 交换位置
   * @param {number} index1
   * @param {number} index2
   */
  this.swap = function (index1, index2) {
    const temp = this.heap[index1]
    this.heap[index1] = this.heap[index2]
    this.heap[index2] = temp
  }

  /**
   * 上移到合适位置,和父结点比较，如果比父结点小则交换
   * @param {number} index 索引
   */
  this.moveUp = function (index) {
    if (index === 0) return
    const parentIndex = this.getParentIndex(index)
    if (this.heap[index] < this.heap[parentIndex]) {
      this.swap(index, parentIndex)
      this.moveUp(parentIndex)
    }
  }
  /**
   * 添加元素
   * @param {number} value
   */
  this.append = function (value) {
    this.heap.push(value)
    this.moveUp(this.heap.length - 1)
  }
}

const minHeap = new MinHeap()
minHeap.append(3)
minHeap.append(4)
minHeap.append(1)
minHeap.append(0)
minHeap.append(2)
minHeap.append(7)
minHeap.append(9)
// [0, 1, 3, 4, 2, 7, 9]
复制代码
```

通过`heap`可以模拟一个堆的表示，即：

0123479

可以看到这个结构满足`最小堆`的定义

## 应用场景

### 1. 高效快速找到最大值最小值

可以通过构建`最大堆`或`最小堆`快速找到最大最小值

### 2. 实现堆排序

上面我们实现了一个简单构建`最小堆`的方法，那么实现堆排序的原理其实就是先构建一个`最小堆`然后将堆顶（最小值弹出），再将其他元素构建堆，每次都弹出`堆顶`元素直到剩余元素为1时结束，这样就是实现了一个堆排序。



作者：liangyue
链接：https://juejin.cn/post/6957919292352364551
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。